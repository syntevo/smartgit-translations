:*"Cancel"=取消
:*"Add Branch"=创建分支
:*"Discard"=丢弃
:*"Git-Flow"=Git 工作流
:*"Commit"=提交
:*"Branch"=分支
:*"Check Out"=检出
:*"Merge"=合并
:*"Pull"=拉取
:*"Push"=推送
:*"Rebase"=变基
:*"Save Stash"=贮藏
:*"Stage"=暂存
:*"Sync"=同步
:*"Unstage"=取消暂存
:*"Deselect All"=取消全选
:*"Select All"=全选
:*"Output"=输出
:*"Repositories"=仓库
:*"Add Tag"=创建标签
:*"Apply Stash"=应用贮藏
:*"Working Tree"=工作区
:*"Refresh"=刷新
:*"Email"=电子邮箱

*.btn"< Back"=< 上一步
*.btn"Cancel"=取消
*.btn"Close"=关闭
*.btn"Finish"=完成
*.btn"Next >"=下一步 >
*.btn"OK"=确定
*.hnt"Filter"=过滤器
dlgCommit.replaceMessage.btn"Replace"=替换
dlgCommit.replaceMessage.chk=始终替换
dlgCommit.replaceMessage.fur=替换后，您可以在单击历史记录按钮时找到上一条消息。
dlgCommit.replaceMessage.hdl=是否替换现有消息？
dlgCommit.replaceMessage.tle=替换消息
dlgDgAbout.edt"Build Date"=编译日期
dlgDgAbout.edt"Email"=电子邮箱
dlgDgAbout.edt"Java Version"=Java 版本
dlgDgAbout.edt"Maximum Heap"=最大堆
dlgDgAbout.edt"Name"=用户名
dlgDgAbout.edt"Settings Path"=设置路径
dlgDgAbout.edt"Version"=版本
dlgDgAbout.tab"Credits"=基本信息
dlgDgAbout.tab"Information"=软件信息
dlgDgAbout.tab"Licensee"=被许可人
dlgDgAbout.tle=关于 DeepGit
dlgDgRefMapperGroupConfig.hdl=Configure patterns for grouping tags of this repository
dlgDgRefMapperGroupConfig.inf=Tags, branches and other refs matched by this configuration will be displayed in the Navigation graph.
dlgDgRefMapperGroupConfig.tle=Configure Tag-Grouping
dlgDgSetEncoding.edt"Text File Encoding"=文本文件编码
dlgDgSetEncoding.hdl=配置编码
dlgDgSetEncoding.inf=指定应用于处理和查看文件的编码。请注意,UTF-8 编码将自动检测到,而不考虑此处的配置。
dlgDgSetEncoding.tle=设置编码
dlgDgSetPerspectiveCantSwitch.fur=In order to inspect available Origins, they have to be evaluated first. Select a line in the Blame view. Then wait until the calculation of possible Origins has finished.
dlgDgSetPerspectiveCantSwitch.hdl=Can't switch perspective.
dlgDgSetPerspectiveCantSwitch.tle=Origins Perspective
dlgInfo.tle=丢弃
dlgProgress.btn"Stop"=停止
dlgProgress.tle"Checking connectivity"=检查连接
dlgProgress.tle"Checking push conditions"=检查推送条件
dlgProgress.tle"JIRA"=JIRA
dlgProgress.tle"Jump To"=跳转到
dlgProgress.tle"Layouting Graph"=布局图
dlgProgress.tle"Refresh"=刷新
dlgProgress.tle"Reveal Commit"=显示提交
dlgProgress.tle"SmartGit Installation Update"=SmartGit 安装更新
dlgProgress.tle"Upgrade"=升级
dlgQBugFileSendingFailed.fur%1=也许您需要配置代理才能访问我们服务器或我们的服务器暂时关闭。\n详情：$1
dlgQBugFileSendingFailed.hdl%1=无法将崩溃记录发送到 $1
dlgQBugFileSendingFailed.tle=本机崩溃记录
dlgQBugReportSend.btn"Force Exit"=强制退出
dlgQBugReportSend.btn"Ignore \(Dangerous\)"=忽略 \(危险\)
dlgQBugReportSend.btn"Just Exit"=仅退出
dlgQBugReportSend.btn"Report && Exit"=报告并退出
dlgQBugReportSend.btn"Report Bug"=反馈 Bug
dlgQBugReportSend.edt"Comments or Steps to Reproduce"=重现注释或步骤
dlgQBugReportSend.edt"Email"=电子邮箱
dlgQBugReportSend.edt"Reply To"=回复
dlgQBugReportSend.lbl"Sorry for the trouble!"=Sorry for the trouble!
dlgQBugReportSend.tle=内部错误
dlgQDockManagerClosedView.chk=不再显示
dlgQDockManagerClosedView.fur=要再次重新打开它，请使用窗口菜单中的相应菜单项。
dlgQDockManagerClosedView.hdl%1=您已经关闭了视图 $1。
dlgQDockManagerClosedView.tle=关闭视图
dlgQFileSaveAcceptFilterOverwrite.btn"Overwrite"=覆盖
dlgQFileSaveAcceptFilterOverwrite.fur=要保存到其他文件，请单击 “取消”。
dlgQFileSaveAcceptFilterOverwrite.hdl%1=文件 $1 已存在。你确定覆盖它吗？
dlgQFileSaveAcceptFilterOverwrite.tle=覆盖文件
dlgQFrameManagerExit.btn"Discard Changes && Exit"=放弃更改并退出
dlgQFrameManagerExit.fur=存在未保存的变更，这些变更将在退出时丢失!
dlgQFrameManagerExit.hdl=是否确实要退出 SmartGit ？
dlgQFrameManagerExit.tle=退出
dlgQIntegerInputProviderInvalidValue.fur%2=端口必须在 $1 到 $2 的范围内。
dlgQIntegerInputProviderInvalidValue.hdl%1=字段 “$1” 中的文本无效。
dlgQIntegerInputProviderInvalidValue.tle=输入验证
dlgQProxyConfigure.chk"Proxy requires authentication"=代理需要身份验证
dlgQProxyConfigure.edt"Host"=服务器
dlgQProxyConfigure.edt"Password"=密码
dlgQProxyConfigure.edt"Port"=端口
dlgQProxyConfigure.edt"Username"=用户名
dlgQProxyConfigure.lbl"Note: The password will be stored in plain text in SmartGit's configuration area!"=\
 注意：密码将以明文形式存储在 SmartGit 的配置区域中！
dlgQProxyConfigure.rbt"Auto-detect the system proxy"=自动检测系统代理
dlgQProxyConfigure.rbt"Don't use a proxy"=不使用代理
dlgQProxyConfigure.rbt"Use following proxy"=使用以下代理
dlgQProxyConfigure.tle=设置代理
dlgQProxyConnectionFailed.btn"Configure Proxy"=配置代理
dlgQProxyConnectionFailed.btn"Retry"=重试
dlgQProxyConnectionFailed.fur=详情：syntevo.com
dlgQProxyConnectionFailed.hdl%1=无法连接到 $1。
dlgQProxyConnectionFailed.tle=连接失败
dlgQUpdateCheckForNewVersion.btn"Configure Proxy"=配置代理
dlgQUpdateCheckForNewVersion.btn"Exit"=退出
dlgQUpdateCheckForNewVersion.btn"Retry"=重试
dlgQUpdateCheckForNewVersion.btn"Skip"=跳过
dlgQUpdateCheckForNewVersion.hdl=SmartGit 需要检查更新
dlgQUpdateCheckForNewVersion.inf=如果需要，请配置代理并重试。
dlgQUpdateCheckForNewVersion.tle=检查新版本
dlgQUpdateCheckForNewVersionFailed.fur%1=详细信息：无法连接到 “$1”。
dlgQUpdateCheckForNewVersionFailed.hdl=检查新版本失败。
dlgQUpdateCheckForNewVersionFailed.tle=检查新版本
dlgQUpdateCheckLatestBuild.btn"Get Latest Build"=确认
dlgQUpdateCheckLatestBuild.fur=仅在支持团队要求时使用最新版本。
dlgQUpdateCheckLatestBuild.hdl=您确定要下载最新编译版本吗？
dlgQUpdateCheckLatestBuild.tle=检查最新编译版本
dlgQUpdateCheckLatestBuildFetchFailed.fur%1=详细信息：$1
dlgQUpdateCheckLatestBuildFetchFailed.hdl=初始化升级失败。
dlgQUpdateCheckLatestBuildFetchFailed.tle=检查最新编译版本
dlgQUpdateCheckNewVersion.btn"Download"=下载
dlgQUpdateCheckNewVersion.fur=建议更新到新版
dlgQUpdateCheckNewVersion.hdl=发现版本更新
dlgQUpdateCheckNewVersion.tle=检测更新
dlgQUpdateCheckNoNewerLatestBuild.fur=您已经在使用最新编译版本。
dlgQUpdateCheckNoNewerLatestBuild.hdl=未找到需要更新的编译版本
dlgQUpdateCheckNoNewerLatestBuild.tle=检查最新编译版本
dlgQUpdateCheckNowNewerVersion.fur=当前版本已是最新
dlgQUpdateCheckNowNewerVersion.hdl=未找到需要更新的版本
dlgQUpdateCheckNowNewerVersion.tle=检查新版本
dlgRewriteTextFiles.btn"Fix Line-Endings"=修复行尾
dlgRewriteTextFiles.chk"Enforce line-ending on end of file"=\
 在文件末尾强制使用行尾
dlgRewriteTextFiles.edt"Line-Endings"=行尾
dlgRewriteTextFiles.hdl=用选定的行尾重写文本文件
dlgRewriteTextFiles.inf=选择应用于写入文本文件的行尾。
dlgRewriteTextFiles.tle=修复行尾
dlgScAboutUpdateInstallation.btn"Upgrade Installation"=升级安装
dlgScAboutUpdateInstallation.fur=这将需要一些时间，必须重新启动 SmartGit。
dlgScAboutUpdateInstallation.hdl%1=是否要将安装目录升级到版本 $1？
dlgScAboutUpdateInstallation.tle=升级安装
dlgScApplicationStarterRestart.btn"Exit"=退出
dlgScApplicationStarterRestart.btn"Remind Later"=稍后提醒
dlgScApplicationStarterRestart.btn"Restart"=重新启动
dlgScApplicationStarterRestart.fur=下载的程序更新现在应该应用。
dlgScApplicationStarterRestart.hdl=SmartGit 需要重新启动。
dlgScApplicationStarterRestart.tle=重新启动
dlgScConflictSolverAdd.hdl=添加冲突解决方案
dlgScConflictSolverAdd.tle=添加
dlgScConflictSolverEdit.hdl=变基冲突解决方案
dlgScConflictSolverEdit.tle=编辑
dlgScConflictSolverInconsistentLineEndings.fur=The merge file content contains mixed \(inconsistent\) line-endings. If these line-endings are intentionally mixed, be sure to not overwrite them while saving this file.
dlgScConflictSolverInconsistentLineEndings.hdl=The file contains mixed \(inconsistent\) line-endings.
dlgScConflictSolverInconsistentLineEndings.tle%1=\[$1\] - Conflict Solver
dlgScConflictSolverUnresolvedConflicts.chk=不再显示警告
dlgScConflictSolverUnresolvedConflicts.fur=并非所有冲突都已得到解决。
dlgScConflictSolverUnresolvedConflicts.hdl=你想关闭冲突解决器吗？
dlgScConflictSolverUnresolvedConflicts.tle=未解决的冲突
dlgScConflictSolver(Add|Edit).edt"Arguments"=参数
dlgScConflictSolver(Add|Edit).edt"Command"=命令
dlgScConflictSolver(Add|Edit).edt"File Pattern"=文件模式
dlgScConflictSolver(Add|Edit).inf=定义文件模式 \(例如：\*.txt\) 并选择合并工具，该工具用于解决与此模式匹配的冲突文件。
dlgScConflictSolver(Add|Edit).lbl"Valid wildcards are ?\u00a0\(one arbitrary character\) and \*\u00a0\(any number of arbitrary characters\). Separate multiple patterns by comma. Example:\u00a0\*.txt,\u00a0\*.html"=\
 有效的通配符是 ?\u00a0\(一个任意字符\)和\*\u00a0\(任意数量的任意字符\)。用逗号分隔多个模式。例如：\u00a0\*.txt,\u00a0\*.html。
dlgScConflictSolver(Add|Edit).lbl"You must use the variables \$\{leftFile\}, \$\{rightFile\} and \$\{mergedFile\}."=\
 You must use the variables \$\{leftFile\}, \$\{rightFile\} and \$\{mergedFile\}.
dlgScConflictSolver(Add|Edit).mni"Base File"=Base File
dlgScConflictSolver(Add|Edit).mni"Encoding"=Encoding
dlgScConflictSolver(Add|Edit).mni"Left File"=Left File
dlgScConflictSolver(Add|Edit).mni"Left Title"=Left Title
dlgScConflictSolver(Add|Edit).mni"Merged File"=Merged File
dlgScConflictSolver(Add|Edit).mni"Merged Title"=Merged Title
dlgScConflictSolver(Add|Edit).mni"Right File"=Right File
dlgScConflictSolver(Add|Edit).mni"Right Title"=Right Title
dlgScConflictSolver(Add|Edit).rbt"Built-in Conflict Solver"=内置冲突解决器
dlgScConflictSolver(Add|Edit).rbt"External Conflict Solver"=外部冲突解决器
dlgScCustomizeAccelerators.btn"Assign"=分配
dlgScCustomizeAccelerators.btn"Clear"=清除
dlgScCustomizeAccelerators.btn"Reset"=重置
dlgScCustomizeAccelerators.col"Accelerator"=加速器
dlgScCustomizeAccelerators.col"Default"=默认
dlgScCustomizeAccelerators.col"Menu Item"=菜单项
dlgScCustomizeAccelerators.edt"Accelerator"=加速器
dlgScCustomizeAccelerators.hdl=自定义加速器
dlgScCustomizeAccelerators.inf=双击要更改加速器的菜单项，然后按加速器键并单击 “分配” 按钮。
dlgScCustomizeAccelerators.tle=自定义
dlgScCustomizeToolBar.btn"Add"=添加
dlgScCustomizeToolBar.btn"Remove"=移除
dlgScCustomizeToolBar.btn"Reset to Default"=重置为默认值
dlgScCustomizeToolBar.chk"Show text below icon"=在图标下方显示文本
dlgScCustomizeToolBar.col"Available"=可用
dlgScCustomizeToolBar.col"Selected"=选择
dlgScCustomizeToolBar.tle=配置工具栏
dlgScDevOpsCredentials.btn"Login"=登录
dlgScDevOpsCredentials.chk"Store password"=存储密码
dlgScDevOpsCredentials.edt"Password"=密码
dlgScDevOpsCredentials.edt"User Name"=用户名
dlgScDevOpsCredentials.hdl%1=登录 “$1”
dlgScDevOpsCredentials.inf=提供用于向 JIRA 进行身份验证的用户名和密码。
dlgScDevOpsCredentials.tle=登录到 JIRA
dlgScDevOpsCredentials.wrn"HTTP response code $1"=HTTP 响应代码 $1
dlgScDevOpsSslClientCertificate.btn"Login"=登录
dlgScDevOpsSslClientCertificate.chk"Store passphrase"=存储密码
dlgScDevOpsSslClientCertificate.edt"Certificate"=证书
dlgScDevOpsSslClientCertificate.edt"Passphrase"=密码
dlgScDevOpsSslClientCertificate.hdl%1=选择 $1 的客户端证书
dlgScDevOpsSslClientCertificate.inf=选择用于向 JIRA 进行身份验证的客户端证书文件。
dlgScDevOpsSslClientCertificate.tle=JIRA 客户证书
dlgScDevOpsSslClientCertificate.wrn"$1"=$1
dlgScDevOpsSslFingerprintNew.btn"Accept"=接受
dlgScDevOpsSslFingerprintNew.btn"Reject"=拒绝
dlgScDevOpsSslFingerprintNew.edt"MD5 fingerprint"=MD5 指纹
dlgScDevOpsSslFingerprintNew.edt"SHA fingerprint"=SHA 指纹
dlgScDevOpsSslFingerprintNew.edt"Server"=服务器
dlgScDevOpsSslFingerprintNew.lbl"Is the following server fingerprint correct?"=\
 以下服务器指纹是否正确？
dlgScDevOpsSslFingerprintNew.lbl"When in doubt, contact your server administrator."=\
 如有疑问，请与你的服务器管理员联系。
dlgScDevOpsSslFingerprintNew.tle=SSL 身份验证
dlgScDialogAssertionHandler.btn"Send Logs"=发送记录
dlgScDialogAssertionHandler.edt"Email"=电子邮箱
dlgScDialogAssertionHandler.edt"Optional comments or steps to reproduce \(in case you still recall\)"=\
 可选的评论注释或重现步骤 \(如果您还记得\)
dlgScDialogAssertionHandler.tle=本机崩溃记录
dlgScDialogAssertionHandlerLinkageError.btn"Copy"=复制
dlgScDialogAssertionHandlerLinkageError.btn"Force Exit"=强制退出
dlgScDialogAssertionHandlerLinkageError.lbl"SmartGit has detected inconsistencies within its installation files \(JAR files\), what has most likely been caused by a faulty installation.\n\nPlease uninstall SmartGit completely, make sure there are no more installation files left \(especially JAR files\), then reinstall.\n\nIf the problem persists, send following log file as an attachment to smartgit@syntevo.com."=\
 SmartGit 已检测到其安装文件 \(JAR 文件\) 中的不一致，这很可能是由安装错误引起的。\n\n请完全卸载 SmartGit，确保没有剩余的安装文件 \(尤其是 JAR 文件\) ，然后重新安装。\n\n如果问题仍然存在，请将以下记录文件作为附件发送到 smartgit@syntevo.com。
dlgScDialogAssertionHandlerLinkageError.tle=内部错误
dlgScEvaluationReminderContinue.btn"Continue"=继续
dlgScEvaluationReminderContinue.btn"Register"=注册
dlgScEvaluationReminderContinue.fur%2=在商业环境中使用 SmartGit，您必须 \[$1 购买许可证 \]。\n\n对于 \[$2 某些用途 \]，我们授予免费许可证。
dlgScEvaluationReminderContinue.hdl%1=您的 SmartGit 试用将在 $1 天后结束。
dlgScEvaluationReminderContinue.tle=试用
dlgScExternalFileStarterCommandInvocationFailed.hdl%2=Cannot run program "$1": $2
dlgScExternalFileStarterCommandInvocationFailed.tle%1=\[$1\] - Conflict Solver
dlgScFileComparatorAdd.hdl=添加外部差异工具
dlgScFileComparatorAdd.mni"Base Encoding"=基本编码
dlgScFileComparatorAdd.mni"Base File"=基本文件
dlgScFileComparatorAdd.mni"Base Title"=基本标题
dlgScFileComparatorAdd.tle=添加
dlgScFileComparatorEdit.hdl=编辑外部差异工具
dlgScFileComparatorEdit.mni"Base Encoding"=基本编码
dlgScFileComparatorEdit.mni"Base File"=基本文件
dlgScFileComparatorEdit.mni"Base Title"=基本标题
dlgScFileComparatorEdit.tle=编辑
dlgScFileComparator(Add|Edit).edt"Arguments"=参数
dlgScFileComparator(Add|Edit).edt"Command"=命令
dlgScFileComparator(Add|Edit).edt"File Pattern"=文件模式
dlgScFileComparator(Add|Edit).inf=定义文件模式 \(例如：\*.png\) 并选择比较命令，该命令应用于比较与文件模式匹配的文件。
dlgScFileComparator(Add|Edit).lbl"Valid wildcards are ?\u00a0\(one arbitrary character\) and \*\u00a0\(any number of arbitrary characters\). Separate multiple patterns by comma. Example:\u00a0\*.txt,\u00a0\*.html"=\
 有效的通配符是 ?\u00a0\(一个任意字符\)和\*\u00a0\(任意数量的任意字符\)。用逗号分隔多个模式。例如：\u00a0\*.txt,\u00a0\*.html。
dlgScFileComparator(Add|Edit).mni"File"=文件
dlgScFileComparator(Add|Edit).mni"Left Encoding"=左编码
dlgScFileComparator(Add|Edit).mni"Left File"=左文件
dlgScFileComparator(Add|Edit).mni"Left Local File"=左本地文件
dlgScFileComparator(Add|Edit).mni"Left Title"=左标题
dlgScFileComparator(Add|Edit).mni"Right Encoding"=右编码
dlgScFileComparator(Add|Edit).mni"Right File"=右文件
dlgScFileComparator(Add|Edit).mni"Right Local File"=右本地文件
dlgScFileComparator(Add|Edit).mni"Right Title"=右标题
dlgScFileComparator(Add|Edit).rbt"Built-in file compare"=内置文件比较
dlgScFileComparator(Add|Edit).rbt"External diff tool:"=外部差异工具：
dlgScFileComparator(Add|Edit).rbt"External viewer \(invoked for both compared files\):"=\
 外部查看器 \(两个文件比较时使用\)
dlgScFileCompareFileChanged.btn"Discard"=丢弃
dlgScFileCompareFileChanged.btn"Save"=保存
dlgScFileCompareFileChanged.fur=如果您不保存更改，您的更改将会丢失。
dlgScFileCompareFileChanged.hdl=你确定要保存更改吗？
dlgScFileCompareFileChanged.tle=文件已更改
dlgScFilePatternsEdit.edt"File Pattern"=文件模式
dlgScFilePatternsEdit.hdl%1=语言：$1
dlgScFilePatternsEdit.inf=文件模式用于确定文件语言，该文件用于语法着色。
dlgScFilePatternsEdit.lbl"Valid wildcards are ?\u00a0\(one arbitrary character\) and \*\u00a0\(any number of arbitrary characters\). Separate multiple patterns by comma. Example:\u00a0\*.txt,\u00a0\*.html"=\
 有效的通配符是 ?\u00a0\(一个任意字符\)和\*\u00a0\(任意数量的任意字符\)。用逗号分隔多个模式。例如：\u00a0\*.txt,\u00a0\*.html。
dlgScFilePatternsEdit.tle=文件模式
dlgScFindAction.edt"Action name"=命令
dlgScFindAction.tle=查找命令
dlgScHostKeyVerifier.btn"Accept"=接受
dlgScHostKeyVerifier.btn"Reject"=拒绝
dlgScHostKeyVerifier.edt"Fingerprint"=指纹
dlgScHostKeyVerifier.edt"Server"=服务器
dlgScHostKeyVerifier.fur=如果您不确定，请与管理员联系。
dlgScHostKeyVerifier.hdl=请确认 SSH 服务器指纹。
dlgScHostKeyVerifier.tle=SSH 服务器验证
dlgScJiraCommitMessageSelect.btn"Refresh"=刷新
dlgScJiraCommitMessageSelect.btn"Reset to default"=重置为默认
dlgScJiraCommitMessageSelect.btn"Select"=选择
dlgScJiraCommitMessageSelect.chk"Query Configuration"=查询配置
dlgScJiraCommitMessageSelect.col"Fix Version"=修复版本
dlgScJiraCommitMessageSelect.col"Key"=键
dlgScJiraCommitMessageSelect.col"Status"=状态
dlgScJiraCommitMessageSelect.col"Summary"=摘要
dlgScJiraCommitMessageSelect.hdl=按 JIRA 问题选择提交消息
dlgScJiraCommitMessageSelect.inf=选定的问题摘要将用作提交消息。
dlgScJiraCommitMessageSelect.lbl"Enter the JQL-Queries which will be loaded in the specified order: every query on a new line, \$\{projects\} will be substituted by the JIRA project key\(s\) which is derived or explicitly specified in your .gitbugtraq file.\n\nYou can compose a JQL query directly in JIRA, using Issues\|Search and go to Advanced view there."=\
 输入将按指定顺序加载的 JQL 查询：新行上的每个查询，\$\{projects\} 将替换为 .gitbugtraq 文件中派生或明确指定的 JIRA 项目密钥。\r\n您可以直接在 JIRA 中编写 JQL 查询，使用问题|搜索并转到高级视图。
dlgScJiraCommitMessageSelect.lbl"Load All Issues"=加载所有问题
dlgScJiraCommitMessageSelect.lbl"Query Configuration"=查询配置
dlgScJiraCommitMessageSelect.tle=选择问题
dlgScJiraResolveIssue.btn"Don't Resolve"=不解决
dlgScJiraResolveIssue.btn"Ignore"=忽略
dlgScJiraResolveIssue.btn"Resolve Issue"=解决问题
dlgScJiraResolveIssue.btn"Resolve"=解决
dlgScJiraResolveIssue.edt"Resolution"=解决
dlgScJiraResolveIssue.edt"Summary"=摘要
dlgScJiraResolveIssue.hdl%1=解决问题 $1
dlgScJiraResolveIssue.inf=选择是否解决此问题以及要标记为已解决的版本。
dlgScJiraResolveIssue.tle=解决 JIRA 问题
dlgScMasterPasswordChange.edt"Current Master Password"=当前主密码
dlgScMasterPasswordChange.edt"New Master Password"=新主密码
dlgScMasterPasswordChange.edt"Retype New Master Password"=再次输入
dlgScMasterPasswordChange.hdl=更改或重置主密码
dlgScMasterPasswordChange.inf=要更改主密码，请输入当前密码。要没有主密码，请将字段留空。
dlgScMasterPasswordChange.lbl"When setting a new master password, all stored passwords and passphrases will be lost and need to be re-entered when required!"=\
 设置新的主密码时，所有存储的密码和口令都将丢失，需要时需要重新输入！
dlgScMasterPasswordChange.rbt"Change master password"=更改主密码
dlgScMasterPasswordChange.rbt"Set new master password"=设置新的主密码
dlgScMasterPasswordChange.tle=更改主密码
dlgScMasterPasswordCreate.edt"Master Password"=主密码
dlgScMasterPasswordCreate.edt"Retype Again"=重新输入
dlgScMasterPasswordCreate.hdl=配置加密密码存储的主密码
dlgScMasterPasswordCreate.inf=主密码用于保护用于向服务器进行身份验证的密码和口令。
dlgScMasterPasswordCreate.lbl"Not using a master password makes your passwords and passphrases readable for everyone who has access to the password file located at $1. Use this option only if you are sure that this file is safe."=\
 不使用主密码使您的密码和密码短语对访问位于 $1 的密码文件的每个人都是可读的。仅当您确定此文件安全时才使用此选项。
dlgScMasterPasswordCreate.lbl"This master password is case-sensitive and should contain lowercase and uppercase characters, digits and other characters. Longer passwords are in general more secure than shorter ones."=\
 此主密码区分大小写，应包含小写和大写字符、数字和其他字符。长密码通常比短密码更安全。
dlgScMasterPasswordCreate.rbt"Don't use a master password"=不要使用主密码
dlgScMasterPasswordCreate.rbt"Use the following master password"=使用以下主密码
dlgScMasterPasswordCreate.tle=主密码
dlgScMasterPasswordEnter.edt"Master Password"=主密码
dlgScMasterPasswordEnter.hdl=输入主密码
dlgScMasterPasswordEnter.inf=已从密码库中申请了一个存储的密码或口令。
dlgScMasterPasswordEnter.tle=密码
dlgScNotificationUpdateCheckHandlerUpdateFailure.fur=The process could not be started.
dlgScNotificationUpdateCheckHandlerUpdateFailure.hdl=Launching updater directly failed.
dlgScNotificationUpdateCheckHandlerUpdateFailure.tle=SmartGit Installation Update
dlgScPasswordMasterChangeSuccessfulChange.fur=请务必记住它，否则您将无法再访问您存储的密码。
dlgScPasswordMasterChangeSuccessfulChange.hdl=主密码已更改。
dlgScPasswordMasterChangeSuccessfulChange.tle=更改主密码
dlgScPropertiesReset.btn"Reset"=重置
dlgScPropertiesReset.fur=新值只有在重新启动 SmartGit 后才会激活。
dlgScPropertiesReset.hdl%1=是否要将系统属性 $1 重置为默认值？
dlgScPropertiesReset.tle=重置属性
dlgScPropertyEdit.edt"Value"=值
dlgScPropertyEdit.hdl=编辑低级属性值
dlgScPropertyEdit.inf%1=设置属性 “$1” 的值
dlgScPropertyEdit.rbt"false"=假
dlgScPropertyEdit.rbt"true"=真
dlgScPropertyEdit.tle=编辑属性
dlgScRegisterFormLicenseConfirmDetails.edt"Add-on"=附加组件
dlgScRegisterFormLicenseConfirmDetails.edt"Address"=地址
dlgScRegisterFormLicenseConfirmDetails.edt"Email"=电子邮箱
dlgScRegisterFormLicenseConfirmDetails.edt"Free Updates Until"=免费更新有效期
dlgScRegisterFormLicenseConfirmDetails.edt"Name"=用户名
dlgScRegisterFormLicenseConfirmDetails.edt"Support Until"=技术支持有效期
dlgScRegisterFormLicenseConfirmDetails.edt"User Count"=用户计数
dlgScRegisterFormLicenseConfirmDetails.tle=SmartGit 许可证
dlgScRegisterFreeUpdatesExpiredLicense.btn"Purchase Update"=购买更新
dlgScRegisterFreeUpdatesExpiredLicense.fur=您可以使用旧的 SmartGit 版本或购买更新许可证。
dlgScRegisterFreeUpdatesExpiredLicense.hdl=此许可证的免费更新期不包括此版本。
dlgScRegisterFreeUpdatesExpiredLicense.tle=SmartGit 许可证
dlgScRegisterRequestRejected.fur=许可证服务器拒绝了该请求。请手动注册你通过电子邮件得到的最新许可文件，或稍后再试。
dlgScRegisterRequestRejected.hdl=更新许可文件失败。
dlgScRegisterRequestRejected.tle=SmartGit 许可证
dlgScSetupLicense.btn"Configure Proxy"=设置代理
dlgScSetupLicense.btn"Purchase Update"=购买更新
dlgScSetupLicense.btn"Register"=注册产品
dlgScSetupLicense.edt"License File"=许可证文件
dlgScSetupLicense.hdl=注册许可证文件
dlgScSetupLicense.inf=请提供您在购买后通过电子邮件收到的 SmartGit 许可文件。
dlgScSetupLicense.tle=SmartGit 许可证
dlgScSpellCheckDictionaryAdd.hdl=添加拼写检查字典
dlgScSpellCheckDictionaryAdd.tle=添加
dlgScSpellCheckDictionaryEdit.hdl=编辑拼写检查字典
dlgScSpellCheckDictionaryEdit.tle=编辑
dlgScSpellCheckDictionary(Add|Edit).edt"Dictionary File"=字典文件
dlgScSpellCheckDictionary(Add|Edit).edt"Name"=名称
dlgScSpellCheckDictionary(Add|Edit).inf=指定拼写字典文件 \(例如:\*.dic 来自 Mozilla Firefox 或 Thunderbird 的 “词典” 目录\). 该名称用来切换不同的字典。
dlgScSslFingerprint.btn"Accept"=接受
dlgScSslFingerprint.btn"Reject"=拒绝
dlgScSslFingerprint.edt"SHA fingerprint"=SHA 指纹
dlgScSslFingerprint.edt"Server"=服务器
dlgScSslFingerprint.lbl"The server fingerprint has changed! Is the change correct?"=\
 服务器指纹已更改！ 变化是否正确？
dlgScSslFingerprint.lbl"This might indicate a security problem! When in doubt, contact your server administrator."=\
 这可能表示存在安全问题！ 如有疑问，请与服务器管理员联系。
dlgScSslFingerprint.tle=服务器指纹
dlgScTextFinderFindFromEnd.btn"Find from End"=Find from End
dlgScTextFinderFindFromEnd.fur=No occurrences have been found until the beginning of the document.
dlgScTextFinderFindFromEnd.hdl=Do you want to continue from the end of the document?
dlgScTextFinderFindFromEnd.tle=Find Text
dlgScTextFinderFindFromStart.btn"Find from Beginning"=从头查找
dlgScTextFinderFindFromStart.fur=直到文档底部无法查找更多文本
dlgScTextFinderFindFromStart.hdl=您想从文档的开头继续查找吗？
dlgScTextFinderFindFromStart.tle=查找文本
dlgScTextFinderNothingFound.hdl=没有找到 \(更多\) 文本。
dlgScTextFinderNothingFound.tle=查找文本
dlgScTextMultiComponentGoToLine.edt"Line Number"=行号
dlgScTextMultiComponentGoToLine.tle=转到行
dlgScTextMultiComponentSyntaxHighlightingSelection.tle=选择语法-高亮显示
dlgScTextReplace.btn"< Find"=查找上一个
dlgScTextReplace.btn"Find >"=查找下一个
dlgScTextReplace.btn"Replace All"=全部替换
dlgScTextReplace.btn"Replace"=替换
dlgScTextReplace.chk"Case-sensitive"=区分大小写
dlgScTextReplace.chk"Regular Expression search"=正则表达式
dlgScTextReplace.chk"Replace With:"=替换为：
dlgScTextReplace.edt"Text to Find"=查找文本
dlgScTextReplace.tle=查找并替换
dlgScTextSettings.chk"Coalesce nearby change blocks"=合并附近的更改块
dlgScTextSettings.chk"Split leading/trailing added or removed lines into separate blocks"=\
 将创建或删除的前导/尾随行拆分为单独的块
dlgScTextSettings.chk"Trim equal start/end of Inner-Line changes"=\
 修剪内线变化的相等开始/结束
dlgScTextSettings.edt"Inner-Line Comparison"=内线比较
dlgScTextSettings.edt"Show Whitespaces"=显示空格
dlgScTextSettings.edt"Tab Size"=Tab 大小
dlgScTextSettings.rbt"All"=所有
dlgScTextSettings.rbt"Alphanumeric words"=字母数字
dlgScTextSettings.rbt"C identifiers"=C 标识符
dlgScTextSettings.rbt"Character-based"=基于字符
dlgScTextSettings.rbt"Java identifiers"=Java 标识符
dlgScTextSettings.rbt"None"=不显示
dlgScTextSettings.rbt"Off"=关闭
dlgScTextSettings.rbt"Trailing and changed"=跟踪和更改
dlgScTextSettings.tab"Compare"=比较
dlgScTextSettings.tab"General"=常规
dlgScTextSettings.tle=设置
dlgScUpdateInstallationUpdateManuallyFailure.fur=The process could not be started.
dlgScUpdateInstallationUpdateManuallyFailure.hdl=Launching updater directly failed.
dlgScUpdateInstallationUpdateManuallyFailure.tle=SmartGit Installation Update
dlgScUpdateInstallationUpdateManuallyInfo.fur%1=Please get rid of '$1' manually and retry the upgrade.
dlgScUpdateInstallationUpdateManuallyInfo.hdl=Clearing updater directory failed.
dlgScUpdateInstallationUpdateManuallyInfo.tle=SmartGit Installation Update
dlgScUpdateInstallationUpgrade.btn"Upgrade Now"=现在升级
dlgScUpdateInstallationUpgrade.fur%1=新版本 $1 已经下载，需要安装。
dlgScUpdateInstallationUpgrade.hdl=是否要立即升级 SmartGit？
dlgScUpdateInstallationUpgrade.tle=升级 SmartGit
dlgSelectDiff.col"Command"=命令
dlgSelectDiff.hdl=选择比较工具
dlgSelectDiff.inf=选择应使用的匹配比较工具。
dlgSelectDiff.tle=文件比较
dlgSgAbortBisectingConfirm.btn"Abort Bisect"=中止二分
dlgSgAbortBisectingConfirm.fur=您的工作区处于 “二分” 状态。您可以中止它以退出此状态。\n\n在开始二分之前，将检查分支或提交。
dlgSgAbortBisectingConfirm.hdl=是否要重置工作区？
dlgSgAbortBisectingConfirm.tle=中止
dlgSgAbortCherryPickingConfirm.btn"Abort Cherry-Pick"=中止摘取
dlgSgAbortCherryPickingConfirm.fur=您的工作区处于 “摘取” 状态。你可以中止它以摆脱这种状态，然后重新开始摘取。\n\n中止将清理任何本地修改 \(通过调用 “git reset --hard”\)！
dlgSgAbortCherryPickingConfirm.hdl=您想重置您的工作区吗？
dlgSgAbortCherryPickingConfirm.tle=中止
dlgSgAbortMergingConfirm.btn"Abort Merge"=中止合并
dlgSgAbortMergingConfirm.fur=您的工作区处于 “合并” 状态。您可以中止它以退出此状态，然后重新开始合并。\n\n中止将尝试重建合并前状态 \(通过调用 “git merge --abort”\)！
dlgSgAbortMergingConfirm.hdl=您想中止当前的合并吗？
dlgSgAbortMergingConfirm.tle=丢弃
dlgSgAbortRebasingConfirm.btn"Abort Rebase"=中止变基
dlgSgAbortRebasingConfirm.fur=您的工作区处于 “变基” 状态。你可以放弃变基; 如果您只想跳过当前的补丁，请使用 Branch \| Rebase \| Rebase HEAD 改为。\n\n中止将清除任何本地修改 \(通过调用 “git reset --hard”\)！
dlgSgAbortRebasingConfirm.hdl=您想中止变基吗？
dlgSgAbortRebasingConfirm.tle=丢弃
dlgSgAbortRevertingConfirm.btn"Abort Revert"=中止还原
dlgSgAbortRevertingConfirm.fur=您的工作区处于 “还原” 状态。您可以中止它以退出此状态，然后重新开始还原。\n\n中止将清除任何本地修改 \(通过调用 “git reset --hard”\)!
dlgSgAbortRevertingConfirm.hdl=你想重置你的工作区吗？
dlgSgAbortRevertingConfirm.tle=丢弃
dlgSgAbout.btn"Register"=注册
dlgSgAbout.edt"Add-on"=插件
dlgSgAbout.edt"Address"=地址
dlgSgAbout.edt"Build Date"=编译日期
dlgSgAbout.edt"Email"=电子邮箱
dlgSgAbout.edt"Free Updates Until"=免费更新有效期
dlgSgAbout.edt"Java Version"=Java 版本
dlgSgAbout.edt"Maximum Heap"=最大堆
dlgSgAbout.edt"Name"=用户名
dlgSgAbout.edt"Settings Path"=设置路径
dlgSgAbout.edt"Support Until"=技术支持有效期
dlgSgAbout.edt"User Count"=用户数量
dlgSgAbout.edt"Version"=版本
dlgSgAbout.tab"Credits"=基本信息
dlgSgAbout.tab"Information"=软件信息
dlgSgAbout.tab"Licensee"=被许可人
dlgSgAbout.tle=关于 SmartGit
dlgSgApplicationUpgradeError.fur=The process could not be started.
dlgSgApplicationUpgradeError.hdl=Launching updater directly failed.
dlgSgApplicationUpgradeError.tle=Upgrade
dlgSgAuthenticationRemoveAllCredentials.btn"Remove All"=移除所有
dlgSgAuthenticationRemoveAllCredentials.fur=您必须重新输入所有身份验证详细信息。
dlgSgAuthenticationRemoveAllCredentials.hdl=您确定要删除所有已知凭据吗？
dlgSgAuthenticationRemoveAllCredentials.tle=移除所有
dlgSgAuthenticationShowPassword.edt"Password"=密码
dlgSgAuthenticationShowPassword.tle%1=$1 的密码
dlgSgBisectResult.btn"Continue Bisect"=继续二分
dlgSgBisectResult.btn"Leave Bisect"=离开二分
dlgSgBisectResult.fur%1=$1
dlgSgBisectResult.hdl=二分决定了第一次错误的提交。
dlgSgBisectResult.tle=完成二分
dlgSgBisectStartConfirm.btn"Start Bisect with Bad HEAD"=从坏的 HEAD 开始二分
dlgSgBisectStartConfirm.btn"Start Bisect"=开始二分
dlgSgBisectStartConfirm.fur=在 Git 开始二进制搜索之前，你需要将 1 个提交标记为好，1 个提交为坏。
dlgSgBisectStartConfirm.hdl=是否应该以错误的提交开始？
dlgSgBisectStartConfirm.tle=开始二分
dlgSgBitbucketGenerateToken.edt"Code"=代码
dlgSgBitbucketGenerateToken.edt"Link"=链接
dlgSgBitbucketGenerateToken.hdl=输入生成的代码
dlgSgBitbucketGenerateToken.inf=在 Bitbucket 进行身份验证并输入生成的令牌
dlgSgBitbucketGenerateToken.lbl"Your browser should have opened automatically, let you authenticate with your preferred account at Bitbucket and grant access to SmartGit. If this didn't happen, manually open following link:"=\
 您的浏览器应该已自动打开，让您使用 Bitbucket 上的首选账户进行身份验证并授予对 SmartGit 的访问权限。如果没有发生这种情况，请手动打开以下链接：
dlgSgBitbucketGenerateToken.tle=请求访问令牌
dlgSgBranchAddCheckout.btn"Add Branch && Checkout"=创建分支并检出
dlgSgBranchAddCheckout.btn"Add Branch"=创建分支
dlgSgBranchAddCheckout.edt"Branch"=分支
dlgSgBranchAddCheckout.err"A remote branch with this name already exists. Use a different name."=\
 已存在具有此名称的远程分支。请使用不同的名称。
dlgSgBranchAddCheckout.err"Choose a different branch, the current branch can't be used."=\
 选择其他分支，当前分支不能使用。
dlgSgBranchAddCheckout.err"Enter the name of the local branch."=\
 输入本地分支的名称。
dlgSgBranchAddCheckout.err"The name must not end with a slash or dot."=\
 名称不得以斜杠或点结尾。
dlgSgBranchAddCheckout.err"This branch already exists at this commit."=\
 此分支在此提交时已存在。
dlgSgBranchAddCheckout.hdl"Add branch at commit $1"=在 $1 提交处创建分支
dlgSgBranchAddCheckout.hdl"Add branch at current HEAD commit"=\
 在当前 HEAD 提交处创建分支
dlgSgBranchAddCheckout.inf=输入要创建的本地分支的名称。
dlgSgBranchAddCheckout.tle=创建分支
dlgSgBranchAddCheckoutOverwriteExisting.btn"Overwrite"=覆盖
dlgSgBranchAddCheckoutOverwriteExisting.fur=单击 “取消” 以选择其他分支名称。
dlgSgBranchAddCheckoutOverwriteExisting.hdl%1=分支 “$1” 已经存在。你想覆盖它吗？
dlgSgBranchAddCheckoutOverwriteExisting.tle=创建分支
dlgSgBranchDeleteCurrentNotPossible.fur=默认情况下，SmartGit 不允许删除当前分支。 要跳过此限制，请设置低级属性 “branch.delete.allowToDeleteCurrentBranch”。
dlgSgBranchDeleteCurrentNotPossible.hdl=您无法删除当前分支。
dlgSgBranchDeleteCurrentNotPossible.tle=删除
dlgSgBranchDeleteLocalConfirmMultiple.btn"Delete"=删除
dlgSgBranchDeleteLocalConfirmMultiple.chk"Delete from remote repository"=从远程仓库中删除
dlgSgBranchDeleteLocalConfirmMultiple.chk"Delete tracked branches"=删除跟踪的分支
dlgSgBranchDeleteLocalConfirmMultiple.fur=还原已删除的分支可能会变得很复杂。\n\n您只能从本地远程分支列表中删除分支，但这分支可能会在下一次获取中恢复。
dlgSgBranchDeleteLocalConfirmMultiple.hdl%1=您确定要删除 $1 本地分支吗？
dlgSgBranchDeleteLocalConfirmMultiple.tle=删除
dlgSgBranchDeleteLocalConfirmSingle.btn"Delete"=删除
dlgSgBranchDeleteLocalConfirmSingle.chk"Delete from remote repository '$1'"=从远程仓库 “$1” 中删除
dlgSgBranchDeleteLocalConfirmSingle.chk"Delete tracked branch '$1'"=删除跟踪分支 “$1”
dlgSgBranchDeleteLocalConfirmSingle.fur=您可能会丢失未经推送的更改，或还原分支可能会很复杂 \(es\)！
dlgSgBranchDeleteLocalConfirmSingle.hdl%1=您确定要删除本地分支 “$1” 吗？
dlgSgBranchDeleteLocalConfirmSingle.tle=删除
dlgSgBranchDeleteRemoteConfirmSingle.btn"Delete"=删除
dlgSgBranchDeleteRemoteConfirmSingle.chk"Delete from remote '$1'"=从远程 “$1” 删除
dlgSgBranchDeleteRemoteConfirmSingle.chk"Delete from remote repository '$1'"=从远程仓库中删除 '$1'
dlgSgBranchDeleteRemoteConfirmSingle.fur=您只能从本地远程分支列表中删除分支，但这分支可能会在下一次获取中恢复。
dlgSgBranchDeleteRemoteConfirmSingle.hdl"Do you want to delete the branch '$1'?"=\
 您要删除分支 “$1” 吗？
dlgSgBranchDeleteRemoteConfirmSingle.hdl"Do you want to delete the remote branch '$1'?"=\
 您要删除远程分支 “$1” 吗？
dlgSgBranchDeleteRemoteConfirmSingle.tle=删除
dlgSgBranchTrackingResetConfirm.btn"Stop Tracking"=停止跟踪
dlgSgBranchTrackingResetConfirm.fur=必要的配置将在 .git/config 文件中执行。
dlgSgBranchTrackingResetConfirm.hdl%2=分支 '$1' 是否应该停止跟踪 '$2'？
dlgSgBranchTrackingResetConfirm.tle=停止跟踪
dlgSgBranchTrackingSetConfirm.btn"Configure"=配置
dlgSgBranchTrackingSetConfirm.fur=必要的配置将在 .git/config 文件中执行。
dlgSgBranchTrackingSetConfirm.hdl%2=你想配置 '$1' 跟踪 '$2' 吗？
dlgSgBranchTrackingSetConfirm.tle=设置跟踪分支
dlgSgBugReportSettings.btn"Exit"=退出
dlgSgBugReportSettings.chk"Automatically send 'crash footprints' after an internal error has occurred"=\
 发生内部错误后自动发送 “崩溃追踪”
dlgSgBugReportSettings.chk"Send 'crash footprints' after an internal error has occurred"=\
 在发生内部错误后发送 “崩溃追踪”
dlgSgBugReportSettings.err"Sending 'crash footprints' is required for preview builds, because their main purposes is to get as much as possible bugs reported and fixed before release."=\
 预览版本需要发送 “崩溃追踪”，因为它们的主要目的是尽可能多地获取在发布之前报告和修复的错误。
dlgSgBugReportSettings.hdl=崩溃报告
dlgSgBugReportSettings.inf=请通过自动发送不包含任何敏感信息的 “崩溃追踪” 来帮助提高 SmartGit 的质量。您可以稍后在偏好设置中更改此选项。
dlgSgBugReportSettings.lbl"A 'crash footprint' contains details about your machine \(e.g. version of operating system\), SmartGit's version/build number, the JVM state and where the internal error occurred.\n\nIt contains NO POTENTIALLY SENSITIVE INFORMATION like user names, email addresses, file contents, file paths or server names."=\
 “崩溃追踪” 包含有关您的计算机的详细信息 \(例如，操作系统的版本\)，SmartGit 的版本/内部版本号，JVM 状态以及发生内部错误的位置。\n\n它不包含任何潜在的敏感信息，如用户名，电子邮件地址，文件内容，文件路径或服务器名称。
dlgSgBugReportSettings.tle=SmartGit
dlgSgCheckout.btn"Branches"=Branches
dlgSgCheckout.btn"Check Out"=检出
dlgSgCheckout.hdl=Check out a commit
dlgSgCheckout.inf=Select the commit to check out. This allows to switch \(back\) the working tree to any commit.
dlgSgCheckout.tle=Check Out
dlgSgCheckoutFastForwardMerge.btn"Fast-Forward-Merge"=快进合并
dlgSgCheckoutFastForwardMerge.btn"Just Checkout"=仅检出
dlgSgCheckoutFastForwardMerge.fur=快进合并会自动将分支向前移动到跟踪的远程分支。
dlgSgCheckoutFastForwardMerge.hdl%1=检出 “$1” 后，您想要快进合并远程更改吗？
dlgSgCheckoutFastForwardMerge.tle=检出
dlgSgCheckoutLocalBranchConfirm.btn"Checkout"=检出
dlgSgCheckoutLocalBranchConfirm.chk=不再显示
dlgSgCheckoutLocalBranchConfirm.fur%1=这将使 “$1” 成为您当前的分支。
dlgSgCheckoutLocalBranchConfirm.hdl%1=你想检出 “$1” 分支吗?
dlgSgCheckoutLocalBranchConfirm.tle=检出
dlgSgCheckoutTarget.btn"Checkout"=检出
dlgSgCheckoutTarget.chk"Track remote branch '$1'"=跟踪远程分支 “$1”
dlgSgCheckoutTarget.chk"Track remote branch"=跟踪远程分支
dlgSgCheckoutTarget.hdl"Check out commit"=检出提交
dlgSgCheckoutTarget.hdl"Check out remote branch"=检出远程分支
dlgSgCheckoutTarget.hdl"Checkout commit"=检出提交
dlgSgCheckoutTarget.hdl"Checkout remote branch"=检出远程分支
dlgSgCheckoutTarget.inf=当检出一个提交而不是本地分支的时候需要小心：在该提交之后的提交很容易丢失。
dlgSgCheckoutTarget.rbt"Checkout and fast-forward local branch 'dev'"=\
 Checkout and fast-forward local branch 'dev'
dlgSgCheckoutTarget.rbt"Checkout local branch '$1'"=检出本地分支 '$1'
dlgSgCheckoutTarget.rbt"Create local branch:"=创建本地分支：
dlgSgCheckoutTarget.rbt"Don't create local branch \(just work read-only\)"=\
 不创建本地分支 \(只是以只读方式工作\)
dlgSgCheckoutTarget.tle=检出
dlgSgCheckoutTarget.wrn"Local branch '$1' is behind checkout target '$2'."=\
 本地分支 “$1” 落后于检出目标 “$2”。
dlgSgCheckoutTarget.wrn"Local branch '$1' is diverged from checkout target '$2'."=\
 本地分支 “$1” 与检出目标 “$2” 不同。
dlgSgCheckoutTarget.wrn"Local branch is ahead of remote branch. The checkout will end up at a more recent commit."=\
 本地分支位于远程分支之前。检出将在最近的提交时结束。
dlgSgCheckoutTargetAlreadyExistsOverwrite.btn"Overwrite"=覆盖
dlgSgCheckoutTargetAlreadyExistsOverwrite.fur=单击 “取消” 以选择其他分支名称。
dlgSgCheckoutTargetAlreadyExistsOverwrite.hdl%1=分支 “$1” 已经存在。您想覆盖它吗？
dlgSgCheckoutTargetAlreadyExistsOverwrite.tle=检出
dlgSgCherryPickConfigurationFile.btn"Cherry-Pick"=摘取
dlgSgCherryPickConfigurationFile.fur=只有这些文件的更改才会被摘取 \(不提交\)。
dlgSgCherryPickConfigurationFile.hdl"Do you want to cherry-pick changes of $1 files?"=\
 你想要摘取 $1 文件的更改？
dlgSgCherryPickConfigurationFile.hdl"Do you want to cherry-pick changes of '$1'?"=\
 你想要摘取 $1 文件的更改？
dlgSgCherryPickConfigurationFile.tle=摘取
dlgSgCherryPickConfirmation.btn"Cherry-Pick && Commit"=摘取并提交
dlgSgCherryPickConfirmation.btn"Cherry-Pick"=摘取
dlgSgCherryPickConfirmation.chk=将源 SHA 附加到提交消息
dlgSgCherryPickConfirmation.fur=选中的提交将会被摘取到工作区中
dlgSgCherryPickConfirmation.hdl=你想要摘取提交吗？
dlgSgCherryPickConfirmation.tle=摘取
dlgSgCherryPickFailedBecauseOfConflicts.chk=不再显示
dlgSgCherryPickFailedBecauseOfConflicts.fur=您可能需要在继续之前解决冲突。
dlgSgCherryPickFailedBecauseOfConflicts.hdl=由于冲突，摘取失败。
dlgSgCherryPickFailedBecauseOfConflicts.tle=摘取
dlgSgCherryPickUnpushedCommits.btn"Cherry-Pick"=摘取
dlgSgCherryPickUnpushedCommits.fur=至少有一个选定的提交尚未推送，因此摘取只是本地的，不会转换为 SVN \(合并信息\)。
dlgSgCherryPickUnpushedCommits.hdl=你想要摘取未推送的提交吗？
dlgSgCherryPickUnpushedCommits.tle=摘取
dlgSgClean.btn"Clean Working Tree"=清理工作区
dlgSgClean.chk"Remove only ignored files"=仅删除忽略的文件
dlgSgClean.chk"Remove untracked directories"=删除未跟踪的目录
dlgSgClean.hdl=删除未跟踪的文件
dlgSgClean.inf=选择应删除哪些未跟踪的文件。
dlgSgClean.tle=清理工作区
dlgSgClone.chk"Create upstream remote"=同时创建上游仓库的远程连接
dlgSgClone.chk"Fetch all Heads and Tags"=获取所有 HEAD 和标签
dlgSgClone.chk"Fetch all commits"=获取所有提交
dlgSgClone.chk"Include Submodules"=包括子模块
dlgSgClone.chk"Just initialize clone \(expert mode, not officially supported!\)"=\
 刚刚初始化克隆 \(专家模式，非官方支持！\)
dlgSgClone.chk"Map SVN trunk, tags and branches to Git"=\
 将 SVN 主干，标签和分支映射到 Git
dlgSgClone.chk"Skip large files \(\"partial clone\"\)"=跳过大文件 \(“部分克隆”\)
dlgSgClone.edt"Check Out Branch"=检出分支
dlgSgClone.edt"Fetch Only"=仅获取
dlgSgClone.edt"Fetch only the latest"=获取最新内容
dlgSgClone.edt"Local Directory"=本地目录
dlgSgClone.edt"Omit files larger than"=省略大于
dlgSgClone.edt"Path"=路径
dlgSgClone.edt"Repository URL"=仓库地址
dlgSgClone.err"Please select an empty, local directory for the new repository."=\
 请为新仓库选择一个空的本地目录。
dlgSgClone.err"Please specify the URL of the remote repository to be cloned."=\
 请指定要克隆的远程仓库的地址。
dlgSgClone.err"Please specify the root directory of a local repository."=\
 请指定本地仓库的根目录。
dlgSgClone.inf"Customize how and what to clone."=\
 自定义克隆的方式和内容。
dlgSgClone.inf"Specify the Git or SVN repository to clone."=\
 指定要克隆的 Git 或 SVN 仓库。
dlgSgClone.inf"Specify the Git, Mercurial or SVN repository to clone."=\
 指定要克隆的 Git，Mercurial 或 SVN 仓库。
dlgSgClone.inf"Specify the local directory for the new repository."=\
 指定新仓库的本地目录。
dlgSgClone.inf"Specify the repository to clone."=指定需要克隆的仓库.
dlgSgClone.lbl"Note: Pull or Fetch will not bring other refs, you will need to use Fetch More."=\
 Note: Pull or Fetch will not bring other refs, you will need to use Fetch More.
dlgSgClone.lbl"e.g. https://user@server:port/path/to/repository"=e.g. https://user@server:port/path/to/repository
dlgSgClone.mni"Add Hosting Provider"=添加主机提供商
dlgSgClone.rbt"Clone all revisions \(recommended\)"=克隆所有修订版 \(推荐\)
dlgSgClone.rbt"Clone from revision:"=从修订版中克隆:
dlgSgClone.rbt"Local Git or Mercurial repository"=本地 Git 或 Mercurial 仓库
dlgSgClone.rbt"Local Git repository"=本地 Git 仓库
dlgSgClone.rbt"Local repository"=本地仓库
dlgSgClone.rbt"Remote Git or SVN repository"=远程 Git 或 SVN 仓库
dlgSgClone.rbt"Remote Git, Mercurial or SVN repository"=\
 远程 Git，Mercurial 或 SVN 仓库
dlgSgClone.rbt"Remote repository"=远程仓库
dlgSgClone.tle=克隆
dlgSgCloneRepositoryType.btn"Git"=Git
dlgSgCloneRepositoryType.btn"Mercurial"=Mercurial
dlgSgCloneRepositoryType.btn"SVN"=SVN
dlgSgCloneRepositoryType.fur=指定的 URL 协议不明确，可能引用不同类型的仓库。
dlgSgCloneRepositoryType.hdl=选择要克隆的仓库类型。
dlgSgCloneRepositoryType.tle=克隆
dlgSgCloneSvnDetachedHeadSuccess.fur=SmartGit 现在继续在后台获取所有其他修订版。 您现在可以安全地开始使用仓库; 只有与记录相关的操作才会受到此中间状态的影响。\n\n一旦 SmartGit 完成了克隆的后台部分，它会在通知区域 \(状态栏\) 中通知您，您可以在那里完成克隆。
dlgSgCloneSvnDetachedHeadSuccess.hdl=已成功克隆 HEAD 修订版。
dlgSgCloneSvnDetachedHeadSuccess.tle=克隆
dlgSgCommit.btn"Commit && Push"=提交并推送
dlgSgCommit.btn"Commit"=提交
dlgSgCommit.btn"Select from Log"=从日志中选择
dlgSgCommit.btn"Select"=选择
dlgSgCommit.chk"Add 'Signed-off-by' signature"=添加 “签名”
dlgSgCommit.chk"Amend last commit instead of creating new one"=\
 修改最后一次提交而不是创建新的提交
dlgSgCommit.chk"Amend last commit"=修正最后一次提交
dlgSgCommit.chk"Bypass commit hook"=绕过提交钩子
dlgSgCommit.chk"More Options"=更多选项
dlgSgCommit.col"Directory"=目录
dlgSgCommit.col"Name"=名称
dlgSgCommit.edt"Commit Message"=提交信息
dlgSgCommit.edt"Create"=创建
dlgSgCommit.err"Enter a commit message describing \(the reason for\) the commit."=\
 输入一个提交消息
dlgSgCommit.hdl=提交本地或暂存的更改
dlgSgCommit.inf=选择要提交的文件并提供提交消息。
dlgSgCommit.mni"Deselect All"=取消全选
dlgSgCommit.mni"JIRA"=JIRA
dlgSgCommit.mni"Log"=日志
dlgSgCommit.mni"Select All"=全选
dlgSgCommit.mni"Select from Log"=从日志中选择
dlgSgCommit.mni"Show Changes"=显示修改
dlgSgCommit.mni"Toggle"=切换
dlgSgCommit.rbt"Local Changes"=本地修改
dlgSgCommit.rbt"Merge commit \(multiple parents\)"=合并提交 \(多个父系\)
dlgSgCommit.rbt"Simple commit \(one parent, \"squash\"\)"=简单提交 \(一个父系, “压缩”\)
dlgSgCommit.rbt"Staged Changes"=暂存的修改
dlgSgCommit.tle=提交
dlgSgCommit.wrn"All staged changes have been selected for commit, as this is necessary in 'Reverting' state."=\
 已选择所有暂存的更改进行提交，因为这在 “还原” 状态中是必需的。
dlgSgCommit.wrn"When modifying or splitting a commit, you first need to commit all local changes before being able to continue the rebase."=\
 当修改或拆分提交时，需要先提交所有本地更改，然后才能继续使用变基。
dlgSgCommitAmendAlreadyPushedCommit.btn"Amend"=修改
dlgSgCommitAmendAlreadyPushedCommit.fur=如果修改已推送的提交，你需要稍后强制推送它。这可能会覆盖其他用户的更改。
dlgSgCommitAmendAlreadyPushedCommit.hdl=你确定要修改已推送的提交吗？
dlgSgCommitAmendAlreadyPushedCommit.tle=提交
dlgSgCommitCantAmend.fur=Can't modify an already pushed commit. If you know what you are doing and want to enable it, select the option 'Allow modifying pushed commits' in the preferences.
dlgSgCommitCantAmend.hdl=Can't amend commit.
dlgSgCommitCantAmend.tle=Commit
dlgSgCommitContinueRebaseOrCreateAdditionalCommit.btn"Continue Rebase"=继续变基
dlgSgCommitContinueRebaseOrCreateAdditionalCommit.btn"Create Commit"=创建提交
dlgSgCommitContinueRebaseOrCreateAdditionalCommit.fur=仓库处于 “变基” 状态。 您通常只想继续使用变基，而不是在重新提交的提交中创建额外的提交。
dlgSgCommitContinueRebaseOrCreateAdditionalCommit.hdl=您想继续使用变基还是创建一个额外的提交？
dlgSgCommitContinueRebaseOrCreateAdditionalCommit.tle=变基
dlgSgCommitDirectlyTo.btn"Commit Anyway"=Commit Anyway
dlgSgCommitDirectlyTo.fur=You have Git-Flow configured and committing to the Git-Flow master branch should not happen directly but only with the help of the Git-Flow commands and merging.\n\nIf in doubt, please contact your administrator.
dlgSgCommitDirectlyTo.hdl=Do you want to commit directly to 'master'?
dlgSgCommitDirectlyTo.tle=Commit
dlgSgCommitIndexAllWorkingTreeChanges.btn"Commit All Working Tree Changes"=提交所有工作区更改
dlgSgCommitIndexAllWorkingTreeChanges.chk=不再显示
dlgSgCommitIndexAllWorkingTreeChanges.fur=至今没有文件被暂存。 要暂存个别更改，请单击 “取消”。 否则，所有工作区更改将被暂存和提交。
dlgSgCommitIndexAllWorkingTreeChanges.hdl=您想要提交所有工作区的更改吗？
dlgSgCommitIndexAllWorkingTreeChanges.tle=提交
dlgSgCommitIndexNoFilesFound.fur=找不到暂存文件或本地更改的文件。
dlgSgCommitIndexNoFilesFound.hdl=没有需要提交的。
dlgSgCommitIndexNoFilesFound.tle=提交
dlgSgCommitNoFilesFoundNotAllowEmpty.fur=找不到暂存或本地更改的文件。
dlgSgCommitNoFilesFoundNotAllowEmpty.hdl=没有东西需要提交
dlgSgCommitNoFilesFoundNotAllowEmpty.tle=提交
dlgSgCommitSelectMessageFromLog.btn"Branches"=分支
dlgSgCommitSelectMessageFromLog.btn"Select"=选择
dlgSgCommitSelectMessageFromLog.chk"Add 'fixup!' prefix for easier automatic squashing using Interactive Rebase"=\
 创建 “修复！” 前缀,以便使用交互式变基轻松自动压缩
dlgSgCommitSelectMessageFromLog.hdl=选择一个提交
dlgSgCommitSelectMessageFromLog.inf=选择应使用其消息的提交。
dlgSgCommitSelectMessageFromLog.mni"Author"=作者
dlgSgCommitSelectMessageFromLog.mni"Branches and Tags"=分支和标签
dlgSgCommitSelectMessageFromLog.mni"Committer"=修订者
dlgSgCommitSelectMessageFromLog.mni"Copy ID"=复制 ID
dlgSgCommitSelectMessageFromLog.mni"Copy Message"=复制消息
dlgSgCommitSelectMessageFromLog.mni"File Content \(very expensive\)"=文件内容 \(非常昂贵代价\)
dlgSgCommitSelectMessageFromLog.mni"File \(expensive\)"=文件 \(昂贵代价\)
dlgSgCommitSelectMessageFromLog.mni"Forget Pattern"=忘记模式
dlgSgCommitSelectMessageFromLog.mni"ID"=ID
dlgSgCommitSelectMessageFromLog.mni"Message"=消息
dlgSgCommitSelectMessageFromLog.mni"Refresh"=刷新
dlgSgCommitSelectMessageFromLog.mni"Regular Expressions"=常用表达式
dlgSgCommitSelectMessageFromLog.mni"Remember Pattern"=记住模式
dlgSgCommitSelectMessageFromLog.tle=选择提交消息
dlgSgCommitSingleOrAllWorkingTreeChanges.btn"Commit All Changes"=提交所有更改
dlgSgCommitSingleOrAllWorkingTreeChanges.btn"Commit File"=提交文件
dlgSgCommitSingleOrAllWorkingTreeChanges.fur=您可以提交单个选定文件，也可以提交所有已更改的文件。
dlgSgCommitSingleOrAllWorkingTreeChanges.hdl=您想提交什么？
dlgSgCommitSingleOrAllWorkingTreeChanges.tle=提交
dlgSgCommitToDetachedHead.btn"Commit Anyway"=总是提交
dlgSgCommitToDetachedHead.fur=仓库 HEAD 当前不指向分支，而是直接参考提交 \(SHA\)。提交时，新创建的提交只能通过其 SHA 访问，因此可能很容易丢失。\n\n现在，您应该首先为当前 HEAD 创建一个分支，然后再提交。
dlgSgCommitToDetachedHead.hdl=你想提交一个独立的 HEAD 吗？
dlgSgCommitToDetachedHead.tle=提交
dlgSgCompareTwoFiles.btn"Compare with Each Other"=相互比较
dlgSgCompareTwoFiles.btn"Compare with Repository"=与仓库比较
dlgSgCompareTwoFiles.fur=这些文件可以与它们的仓库内容或相互比较。
dlgSgCompareTwoFiles.hdl=所选的两个文件是否应相互比较？
dlgSgCompareTwoFiles.tle=比较
dlgSgConflictResolverExternalStarted.btn"Mark Resolved"=Mark Resolved
dlgSgConflictResolverExternalStarted.fur=The external conflict solver has been started. After you have resolved the conflict, you may now mark the file as resolved.
dlgSgConflictResolverExternalStarted.hdl=Do you want to mark the file as resolved?
dlgSgConflictResolverExternalStarted.tle=External Conflict Solver
dlgSgConflictSolverMarkResolved.btn"Leave Conflicted"=离开冲突
dlgSgConflictSolverMarkResolved.btn"Mark Resolved"=标记已解决
dlgSgConflictSolverMarkResolved.fur=要完成冲突解决，需要将文件标记为已解决 \(Git 阶段\)。在标记为已解决之前，文件将保持冲突状态，您可以尝试其他冲突解决方案。
dlgSgConflictSolverMarkResolved.hdl=您是否要将该文件标记为已解决？
dlgSgConflictSolverMarkResolved.tle=标记已解决
dlgSgConflictSolverStageForCommit.btn"Don't Stage"=放弃暂存
dlgSgConflictSolverStageForCommit.btn"Stage"=暂存
dlgSgConflictSolverStageForCommit.fur=暂存是解决文件冲突状态所必需的。
dlgSgConflictSolverStageForCommit.hdl=您想现在提交暂存文件吗？
dlgSgConflictSolverStageForCommit.tle=提交暂存
dlgSgCustomizeProjectUi.btn"Add"=创建
dlgSgCustomizeProjectUi.btn"Assign"=应用
dlgSgCustomizeProjectUi.btn"Clear"=清除
dlgSgCustomizeProjectUi.btn"Remove"=移除
dlgSgCustomizeProjectUi.btn"Reset"=重置
dlgSgCustomizeProjectUi.chk"Show text below icon"=在图标下方显示文字
dlgSgCustomizeProjectUi.col"Accelerator"=快捷键
dlgSgCustomizeProjectUi.col"Available"=可选的
dlgSgCustomizeProjectUi.col"Default"=默认
dlgSgCustomizeProjectUi.col"Menu Item"=菜单项
dlgSgCustomizeProjectUi.col"Selected"=已选择
dlgSgCustomizeProjectUi.edt"Accelerator"=快捷键
dlgSgCustomizeProjectUi.mni"Regular Expressions"=常用表达式
dlgSgCustomizeProjectUi.tab"Accelerators"=快捷键
dlgSgCustomizeProjectUi.tab"Toolbar"=工具栏
dlgSgCustomizeProjectUi.tle=自定义
dlgSgDeleteFileTrash.hdl%1=确定要删除 “$1” 吗？
dlgSgDeleteFilesTrash.hdl%1=您确定要删除所选的 $1 文件吗？
dlgSgDiscard.btn"Discard to Stash"=丢弃到回收站
dlgSgDiscard.btn"Discard"=丢弃
dlgSgDiscard.col"Directory"=目录
dlgSgDiscard.col"Name"=名称
dlgSgDiscard.edt"Revert to"=还原
dlgSgDiscard.hdl=丢弃本地或暂存的更改
dlgSgDiscard.inf=选择应丢弃更改的文件以及是否将其设置回 Index 或 HEAD 状态。
dlgSgDiscard.mni"Copy Selection in Column"=复制列中的所选内容
dlgSgDiscard.mni"Deselect All"=取消全选
dlgSgDiscard.mni"Directory"=目录
dlgSgDiscard.mni"Name"=名称
dlgSgDiscard.mni"Select All"=全选
dlgSgDiscard.mni"Show Changes"=显示更改
dlgSgDiscard.mni"Toggle"=切换
dlgSgDiscard.rbt"HEAD"=HEAD
dlgSgDiscard.rbt"Index"=Index
dlgSgDiscard.tle=丢弃
dlgSgDiscardNoFilesFound.fur=找不到暂存文件或本地更改的文件。
dlgSgDiscardNoFilesFound.hdl=没有什么可以丢弃的。
dlgSgDiscardNoFilesFound.tle=丢弃
dlgSgDiscardRevertToHead.hdl%1=您确定要将 $1 文件重置为 HEAD 状态吗？
dlgSgDiscardRevertToIndex.hdl%1=您确定要将 $1 文件重置为其 Index 状态吗？
dlgSgDiscardRevertTo(Head|Index).btn"Discard"=丢弃
dlgSgDiscardRevertTo(Head|Index).fur=内容可能很难还原！
dlgSgDiscardRevertTo(Head|Index).tle=丢弃
dlgSgErrorUtilsClientException.fur"Commit '$1' was not found in repository."=\
 未在仓库内找到提交 '$1'.
dlgSgErrorUtilsClientException.fur"Could not determine URL for submodule $1. Is it correctly initialized?"=\
 无法确定子模块 $1 的URL. 确定已经正常初始化?
dlgSgErrorUtilsClientException.fur"GIT_DIR for repository at '$1' does not exist."=\
 位于 '$1' 的仓库的 GIT_DIR 不存在。
dlgSgErrorUtilsClientException.fur"Repository '$1' is not valid."=仓库 “$1” 无效。
dlgSgErrorUtilsClientException.fur"svn: $1"=svn: $1
dlgSgErrorUtilsClientException.hdl=执行命令失败。
dlgSgErrorUtilsClientException.tle=命令失败
dlgSgExitConfirmation.btn"Exit Now"=立即退出
dlgSgExitConfirmation.chk=不再显示
dlgSgExitConfirmation.fur=关闭所有窗口后退出 SmartGit。
dlgSgExitConfirmation.hdl=你想立即退出 SmartGit 吗？
dlgSgExitConfirmation.tle=退出
dlgSgFileCompareNoChanges.btn"Open"=打开
dlgSgFileCompareNoChanges.chk=不再显示
dlgSgFileCompareNoChanges.fur=两个文件内容按字节顺序相等。\n要查看文件内容，请单击 “打开” 。
dlgSgFileCompareNoChanges.hdl=打开文件将显示比较尽管没有变化？
dlgSgFileCompareNoChanges.tle=文件比较
dlgSgFindObject.edt"Repository Path, Commit ID or Ref"=\
 仓库路径、提交 ID 或参考
dlgSgFindObject.tle=查找对象
dlgSgFlowBranchDivergedHandlerFastForward.btn"Fast-Forward"=快进
dlgSgFlowBranchDivergedHandlerFastForward.fur%3=本地分支 “$1” 位于其跟踪分支 “$2” 的后面。您可以现在快进，也可以稍后手动前进，例如签出分支 $3 。
dlgSgFlowBranchDivergedHandlerFastForward.hdl%2=分支 “$1” 是否应快速转发到 “$2”？
dlgSgFlowBranchDivergedHandlerFastForward.tle=开始 feature
dlgSgFlowBranchDivergedHandlerReplaceRemote.btn"Replace"=替换
dlgSgFlowBranchDivergedHandlerReplaceRemote.fur%2=本地分支 “$1” 似乎包含远程分支 “$2” 的更新但已重写的提交。\n\n如果您不确定本地分支是否实际比远程分支更新，则最好取消此操作并更详细地调查本地和远程更改。
dlgSgFlowBranchDivergedHandlerReplaceRemote.hdl%2=分支 “$1” 是否应替换远程分支 “$2”？
dlgSgFlowBranchDivergedHandlerReplaceRemote.tle=完成 feature
dlgSgFlowBranchDivergedHandlerResetToRemote.btn"Reset"=重置
dlgSgFlowBranchDivergedHandlerResetToRemote.fur%2=远程分支 '$1' 似乎包含更近期但被重写的本地分支 '$2' 的提交。\r\n如果您不确定远程分支是否实际上比本地分支更新，您应该取消此操作并进行调查本地和远程更改更详细。
dlgSgFlowBranchDivergedHandlerResetToRemote.hdl%2=分支 '$1' 是否应重置为远程分支 '$2' ？
dlgSgFlowBranchDivergedHandlerResetToRemote.tle=完成 Feature
dlgSgFlowConfigure.btn"Reset to Defaults"=重置为默认
dlgSgFlowConfigure.edt"Develop Branch"=Develop 分支
dlgSgFlowConfigure.edt"Feature Branches"=Feature 分支
dlgSgFlowConfigure.edt"Git-Flow Type"=Git 工作流类型
dlgSgFlowConfigure.edt"Hot-Fix Branches"=Hot-Fix 分支
dlgSgFlowConfigure.edt"Main Development Branch"=主 Development 分支
dlgSgFlowConfigure.edt"Master Branch"=Master 分支
dlgSgFlowConfigure.edt"Prefix for Feature Branches"=Feature 分支的前缀
dlgSgFlowConfigure.edt"Release Branches"=Release 分支
dlgSgFlowConfigure.edt"Remote"=远程
dlgSgFlowConfigure.edt"Support Branches"=Support 分支
dlgSgFlowConfigure.edt"Version Tags"=版本标签
dlgSgFlowConfigure.hdl=配置分支命名方案
dlgSgFlowConfigure.inf=配置应如何命名 feature、release 和 hotfix 分支。
dlgSgFlowConfigure.rbt"Full \(feature, release, hotfix, support branches\)"=\
 所有 \(feature, release, hotfix, support 分支\)
dlgSgFlowConfigure.rbt"Light \(just feature branches\)"=轻量 \(只是 feature 分支\)
dlgSgFlowConfigure.tle=配置 Git 工作流
dlgSgFlowConfigureChangeOrSwitchOff.btn"Change Configuration"=更改配置
dlgSgFlowConfigureChangeOrSwitchOff.btn"Switch-Off Git-Flow"=关闭 Git 工作流
dlgSgFlowConfigureChangeOrSwitchOff.fur=已经为此仓库配置了 Git 工作流。您可以更改 Git 工作流配置或关闭 Git 工作流功能。在这两种情况下，文件 ~/.git/config 都将被相应地修改。
dlgSgFlowConfigureChangeOrSwitchOff.hdl=您想更改或关闭 Git 工作流配置吗？
dlgSgFlowConfigureChangeOrSwitchOff.tle=配置 Git 工作流
dlgSgFlowFeatureFinish.btn"Finish"=完成
dlgSgFlowFeatureFinish.btn"Select from Log"=从日志中选择
dlgSgFlowFeatureFinish.btn"Select"=选择
dlgSgFlowFeatureFinish.chk"Delete feature branch"=删除 feature 分支
dlgSgFlowFeatureFinish.chk"Fetch latest commits and remove remote feature branch"=\
 获取最新提交并删除远程 feature 分支
dlgSgFlowFeatureFinish.edt"Commit Message"=提交消息
dlgSgFlowFeatureFinish.hdl=完成当前 feature
dlgSgFlowFeatureFinish.inf"Choose how to finish the current feature. This operation will integrate the feature into the '$1' branch."=\
 选择如何完成当前 feature。此操作将该 feature 集成到 $1 分支中。
dlgSgFlowFeatureFinish.inf"Choose how to finish the feature branch '$1'. This operation will integrate the feature into the '$2' branch."=\
 选择如何完成 feature 分支 “$1”。此操作将 feature 集成到 “$2” 分支中。
dlgSgFlowFeatureFinish.mni"JIRA"=JIRA
dlgSgFlowFeatureFinish.mni"Log"=日志
dlgSgFlowFeatureFinish.rbt"Create merge commit"=创建合并提交
dlgSgFlowFeatureFinish.rbt"Create simple commit \(squash\)"=创建简单提交 \(压缩\)
dlgSgFlowFeatureFinish.rbt"Rebase onto '$1'"=变基到 “$1”
dlgSgFlowFeatureFinish.tle=完成 Feature
dlgSgFlowFeatureStart.btn"Start"=开始
dlgSgFlowFeatureStart.edt"Base"=根基
dlgSgFlowFeatureStart.edt"Feature Name"=Feature 名称
dlgSgFlowFeatureStart.err"A feature with this name already exists. Choose a different name."=\
 已存在相同名称的 feature。选择其他名称。
dlgSgFlowFeatureStart.err"Invalid feature name: The name must not end with a slash or dot."=\
 无效的 feature 名称：名称不能以斜线或点结尾。
dlgSgFlowFeatureStart.hdl=开始一个新的 feature
dlgSgFlowFeatureStart.inf%1=输入新 feature 分支的名称。此操作将从 $1 分支派生一个新分支。
dlgSgFlowFeatureStart.lbl"Resulting Branch: $1"=结果分支：$1
dlgSgFlowFeatureStart.tle=开始 Feature
dlgSgFlowHotfixFinish.btn"Finish"=完成
dlgSgFlowHotfixFinish.btn"Select from Log"=从日志中选择
dlgSgFlowHotfixFinish.chk"Create version tag"=创建版本标签
dlgSgFlowHotfixFinish.chk"Create version tag:"=创建版本标签：
dlgSgFlowHotfixFinish.chk"Delete hotfix branch"=删除 hotfix 分支
dlgSgFlowHotfixFinish.chk"Fetch latest '$1' commits"=获取最新的 “$1” 提交
dlgSgFlowHotfixFinish.chk"Merge to develop"=合并到开发
dlgSgFlowHotfixFinish.chk"Push results and remove remote hotfix branch"=\
 推送结果并删除远程 hotfix 分支
dlgSgFlowHotfixFinish.edt"Commit Message"=提交消息
dlgSgFlowHotfixFinish.edt"Commit/Tag Message"=Commit/Tag Message
dlgSgFlowHotfixFinish.hdl=完成 hotfix
dlgSgFlowHotfixFinish.inf"Choose how to finish the current hotfix. This operation will merge the hotfix into the '$1' and '$2' branches."=\
 选择如何完成当前的修补程序。 此操作将修补程序合并到 “$1” 和 “$2” 分支中。
dlgSgFlowHotfixFinish.inf"Choose how to finish the hotfix branch '$1'. This operation will merge the hotfix into the '$2' and '$3' branches."=\
 选择如何完成 hotfix 分支 “$1”。此操作将 hotfix 合并到 “$2” 和 “$3” 分支中。
dlgSgFlowHotfixFinish.inf"Choose how to finish the hotfix branch '$1'."=\
 选择如何完成 hotfix 分支 “$1”。
dlgSgFlowHotfixFinish.tle=完成 Hotfix
dlgSgFlowHotfixStart.btn"Start"=开始
dlgSgFlowHotfixStart.chk"Fetch from '$1' branch"=从 '$1' 分支获取
dlgSgFlowHotfixStart.chk"Fetch from base branch"=从根基分支获取
dlgSgFlowHotfixStart.edt"Base"=根基
dlgSgFlowHotfixStart.edt"Hotfix Name"=修补程序名称
dlgSgFlowHotfixStart.hdl=启动一个新的修补程序
dlgSgFlowHotfixStart.inf%1=输入新修补程序分支的名称。 此操作将从 '$1' 分支中分叉一个新分支。
dlgSgFlowHotfixStart.lbl"Resulting Branch: $1"=结果分支：$1
dlgSgFlowHotfixStart.tle=启动修补程序
dlgSgFlowIntegrateDevelop.btn"Integrate"=整合
dlgSgFlowIntegrateDevelop.chk"Fetch latest '$1' commits from remote repository"=\
 从远程仓库获取最新的 “$1” 提交
dlgSgFlowIntegrateDevelop.hdl%1=整合来自 “$1” 的提交
dlgSgFlowIntegrateDevelop.inf"Merge or rebase commits from the base branch to the current feature."=\
 Merge or rebase commits from the base branch to the current feature.
dlgSgFlowIntegrateDevelop.inf"Merge or rebase commits from the main development line to the current feature."=\
 把主开发线合并或变基提交到当前 feature 分支。
dlgSgFlowIntegrateDevelop.inf"Merge or rebase commits from the main development line to the feature branch '$1'."=\
 把主开发线合并或变基提交到 “$1” feature 分支。
dlgSgFlowIntegrateDevelop.rbt"Merge from '$1'"=合并 “$1”
dlgSgFlowIntegrateDevelop.rbt"Rebase current feature onto '$1'"=将当前 feature 变基为 “$1”
dlgSgFlowIntegrateDevelop.tle=整合开发
dlgSgFlowReleaseFinish.btn"Finish"=完成
dlgSgFlowReleaseFinish.btn"Select from Log"=从日志中选择
dlgSgFlowReleaseFinish.chk"Create version tag"=创建版本标签
dlgSgFlowReleaseFinish.chk"Create version tag:"=创建版本标签：
dlgSgFlowReleaseFinish.chk"Delete release branch"=删除 release 分支
dlgSgFlowReleaseFinish.chk"Fetch latest '$1' and '$2' commits"=\
 获取最新的 “$1” 和 “$2” 提交
dlgSgFlowReleaseFinish.chk"Push results and remove remote release branch"=\
 推送结果并删除远程 release 分支
dlgSgFlowReleaseFinish.edt"Commit Message"=提交消息
dlgSgFlowReleaseFinish.hdl=完成 release
dlgSgFlowReleaseFinish.inf"Choose how to finish the release branch '$1'. This operation will merge the current release into the '$2' and '$3' branches."=\
 选择如何完成 release 分支 “$1”。此操作将当前版本合并到 “$2” 和 “$3” 分支中。
dlgSgFlowReleaseFinish.inf"Choose how to finish the release branch '$1'."=\
 选择如何完成 release 分支 “$1”。
dlgSgFlowReleaseFinish.tle=完成 release
dlgSgFlowReleaseStart.btn"Start"=开始
dlgSgFlowReleaseStart.chk"Fetch from base branch"=从根基分支获取
dlgSgFlowReleaseStart.edt"Base"=根基
dlgSgFlowReleaseStart.edt"Release Name"=发布分支名称
dlgSgFlowReleaseStart.hdl=开始新版本
dlgSgFlowReleaseStart.inf%1=输入新发布分支的名称。 此操作将从 '$1' 分支中分叉一个新分支。
dlgSgFlowReleaseStart.lbl"Resulting Branch: $1"=结果分支：$1
dlgSgFlowReleaseStart.tle=开始发布
dlgSgFlowSupportStart.btn"Start"=Start
dlgSgFlowSupportStart.chk"Fetch from '$1' branch"=Fetch from '$1' branch
dlgSgFlowSupportStart.edt"Support Name"=Support Name
dlgSgFlowSupportStart.hdl=Start a new support
dlgSgFlowSupportStart.inf%1=Enter the name of the new support branch. This operation will fork a new branch from the '$1' branch.
dlgSgFlowSupportStart.lbl"Resulting Branch: $1"=Resulting Branch: $1
dlgSgFlowSupportStart.tle=Start Support
dlgSgGarbageCollector.btn"Run Garbage Collector"=运行垃圾回收器
dlgSgGarbageCollector.chk"Also prune recently created objects"=同时删除最近创建的对象
dlgSgGarbageCollector.chk"Expire reflog now \(will also delete stashes!\)"=\
 立即过期操作记录 \(也会删除贮藏\)
dlgSgGarbageCollector.chk"Optimize repository more aggressively \(may take a while\)"=\
 更积极地优化仓库 \(可能需要一段时间\)
dlgSgGarbageCollector.hdl=运行垃圾回收器
dlgSgGarbageCollector.inf=运行 Git 垃圾回收器将删除不可访问的对象并优化本地仓库，以减少磁盘空间并提高性能。
dlgSgGarbageCollector.tle=运行垃圾回收器
dlgSgGarbageCollectorDeleteAllStashes.btn"Delete Stashes"=Delete Stashes
dlgSgGarbageCollectorDeleteAllStashes.fur=Expiring the reflog now will also delete all stashes.
dlgSgGarbageCollectorDeleteAllStashes.hdl=Do you want to also delete all stashes?
dlgSgGarbageCollectorDeleteAllStashes.tle=Run Garbage Collector
dlgSgGitHubGenerateToken.btn"Authenticate"=认证
dlgSgGitHubGenerateToken.edt"Account"=账号
dlgSgGitHubGenerateToken.edt"Code"=代码
dlgSgGitHubGenerateToken.edt"Link"=链接
dlgSgGitHubGenerateToken.edt"Password"=密码
dlgSgGitHubGenerateToken.hdl=为 GitHub 生成新的 API 令牌
dlgSgGitHubGenerateToken.inf=使用 OAuth 或提供凭据在 GitHub 进行身份验证。
dlgSgGitHubGenerateToken.lbl"Your browser should have opened automatically, let you authenticate with your preferred account at GitHub and grant access to SmartGit. If this didn't happen, manually open following link:"=\
 您的浏览器应该已自动打开，让您通过 GitHub 上的首选账户进行身份验证并授予对 SmartGit 的访问权限。 如果没有发生这种情况，请手动打开以下链接：
dlgSgGitHubGenerateToken.rbt"Authenticate using OAuth \(recommended\)"=使用 OAuth 进行身份验证 \(推荐\)
dlgSgGitHubGenerateToken.rbt"Authenticate with your GitHub account and password"=\
 使用您的 GitHub 账户和密码进行身份验证
dlgSgGitHubGenerateToken.tle=生成 API 令牌
dlgSgGitHubPullRequestCreate.btn"Create"=创建
dlgSgGitHubPullRequestCreate.chk"Draft \(don\'t notify code owners yet\)"=\
 草稿 \(尚未通知代码所有者\)
dlgSgGitHubPullRequestCreate.edt"$1 \u21d2"=$1 \u21d2
dlgSgGitHubPullRequestCreate.edt"Title and Description"=标题和描述
dlgSgGitHubPullRequestCreate.hdl=创建一个拉取请求
dlgSgGitHubPullRequestCreate.inf=将拉取请求发送到另一个仓库或分支。
dlgSgGitHubPullRequestCreate.tle=创建拉取请求
dlgSgGitHubPullRequestMerge.btn"Merge"=合并
dlgSgGitHubPullRequestMerge.btn"Select from Log"=从日志中选择
dlgSgGitHubPullRequestMerge.edt"Commit Message"=提交消息
dlgSgGitHubPullRequestMerge.hdl=合并请求
dlgSgGitHubPullRequestMerge.inf=选择如何合并选定的请求。
dlgSgGitHubPullRequestMerge.lbl"If you have integrated the Pull Request manually, choose this option to close the Pull Request on the server."=\
 如果手动集成了拉取请求，请选择此选项以关闭服务器上的拉取请求。
dlgSgGitHubPullRequestMerge.lbl"If your are fine with the Pull Request changes, choose this option to perform the merge directly on the GitHub server."=\
 如果您对拉取请求变更没有问题，请选择此选项直接在 GitHub 服务器上执行合并。
dlgSgGitHubPullRequestMerge.lbl"To locally check how a Pull Request integrates with the latest commits, choose this option."=\
 要在本地检查拉取请求与最新提交的集成情况，请选择此选项。
dlgSgGitHubPullRequestMerge.rbt"Mark as merged on GitHub Server"=\
 在 GitHub 服务器上标记为已合并
dlgSgGitHubPullRequestMerge.rbt"Merge on GitHub Server"=在 GitHub 服务器上合并
dlgSgGitHubPullRequestMerge.rbt"Merge to Local Repository"=合并到本地仓库
dlgSgGitHubPullRequestMerge.tle=合并拉取请求
dlgSgGitLabGenerateToken.edt"Code"=Code
dlgSgGitLabGenerateToken.edt"Link"=链接
dlgSgGitLabGenerateToken.edt"Token"=令牌
dlgSgGitLabGenerateToken.hdl=输入生成的令牌
dlgSgGitLabGenerateToken.inf=在 Gitlab 验证并输入生成的令牌。
dlgSgGitLabGenerateToken.lbl"Your browser should have opened automatically, let you authenticate with your preferred account at GitLab and grant access to SmartGit. If this didn't happen, manually open following link:"=\
 您的浏览器应该已自动打开，允许您使用您在 Gitlab 的首选账户进行身份验证，并授予对 SmartGit 的访问权限。如果没有发生这种情况，请手动打开以下链接：
dlgSgGitLabGenerateToken.tle=请求访问令牌
dlgSgGitLabMergeRequestCreate.btn"Create"=创建
dlgSgGitLabMergeRequestCreate.edt"$1 \u21d2"=$1 \u21d2
dlgSgGitLabMergeRequestCreate.edt"Title and Description"=标题和描述
dlgSgGitLabMergeRequestCreate.hdl=创建合并请求
dlgSgGitLabMergeRequestCreate.inf=将合并请求发送到另一个仓库或分支。
dlgSgGitLabMergeRequestCreate.tle=创建合并请求
dlgSgGitLabSettingsInvalidToken.fur=使用您的 Gitlab 账户中的个人访问令牌。
dlgSgGitLabSettingsInvalidToken.hdl=请为您的 Gitlab 账户输入个人访问令牌。
dlgSgGitLabSettingsInvalidToken.tle=输入验证
dlgSgHeadMessageListenerReplaceMessage.btn"Don't Replace"=不替换
dlgSgHeadMessageListenerReplaceMessage.btn"Replace This Time"=这次更换
dlgSgHeadMessageListenerReplaceMessage.chk=如果已输入消息，请勿更换
dlgSgHeadMessageListenerReplaceMessage.fur=如果提交消息输入字段为空，则将自动重用 HEAD 提交的消息。
dlgSgHeadMessageListenerReplaceMessage.hdl=用 HEAD 提交的消息替换输入的提交消息？
dlgSgHeadMessageListenerReplaceMessage.tle=提交
dlgSgHistoryEditAuthor.btn"Set Author"=设置作者
dlgSgHistoryEditAuthor.edt"Email"=电子邮箱
dlgSgHistoryEditAuthor.edt"User Name"=用户名
dlgSgHistoryEditAuthor.hdl=编辑提交作者
dlgSgHistoryEditAuthor.inf=输入新的提交作者及其电子邮件地址。
dlgSgHistoryEditAuthor.tle=编辑作者
dlgSgHistoryEditMessage.btn"JIRA"=JIRA
dlgSgHistoryEditMessage.btn"Select from Log"=从日志中选择
dlgSgHistoryEditMessage.btn"Select"=选择
dlgSgHistoryEditMessage.btn"Set Message"=设置消息
dlgSgHistoryEditMessage.edt"Commit Message"=提交消息
dlgSgHistoryEditMessage.hdl=修改提交消息
dlgSgHistoryEditMessage.inf=输入一个新的提交消息。
dlgSgHistoryEditMessage.mni"JIRA"=JIRA
dlgSgHistoryEditMessage.mni"Log"=日志
dlgSgHistoryEditMessage.tle=修改提交消息
dlgSgHistoryModifySplitConfirm.btn"Modify"=修改
dlgSgHistoryModifySplitConfirm.btn"Split"=拆分
dlgSgHistoryModifySplitConfirm.fur=提交后，修改将停止。\n\n 拆分 会将更改放入索引中。您可以放弃应该进入第二次提交的一些更改。\n\n完成更改后，通过继续变基处理剩余的提交。
dlgSgHistoryModifySplitConfirm.hdl%1=你想修改或拆分提交 $1 吗？
dlgSgHistoryModifySplitConfirm.tle=修改或拆分提交
dlgSgHistoryPushCommitsReplaceRemoteBranch.btn"Force Push"=强制推送
dlgSgHistoryPushCommitsReplaceRemoteBranch.fur=推送到远程分支不是快进，所以必须强制推送。远程分支中的提交将丢失。
dlgSgHistoryPushCommitsReplaceRemoteBranch.hdl%1=是否要用提交 $1 替换远程分支？
dlgSgHistoryPushCommitsReplaceRemoteBranch.tle=推送到
dlgSgHistoryPushCommitsUpToCommit.btn"Push"=推送
dlgSgHistoryPushCommitsUpToCommit.fur=对所选提交的所有提交都将被推送到远程仓库。
dlgSgHistoryPushCommitsUpToCommit.hdl%1=是否要将更改向上推送到提交 $1？
dlgSgHistoryPushCommitsUpToCommit.tle=推送到
dlgSgHistoryPushedCommitsModifyPushedCommits.btn"Modify Pushed Commits"=修改已推送的提交
dlgSgHistoryPushedCommitsModifyPushedCommits.fur=已推送的提交对于其他用户是已知的，并且可能已被他们用于构建他们的提交。修改此类提交时，这些用户可能会在以后遇到意外冲突。
dlgSgHistoryPushedCommitsModifyPushedCommits.hdl=你想修改已推送的提交吗？
dlgSgHistoryPushedCommitsModifyPushedCommits.tle=日志
dlgSgHistorySplitConfirm.btn"Split"=Split
dlgSgHistorySplitConfirm.chk=Don't show again
dlgSgHistorySplitConfirm.fur=This will put the commit's changes into the Index. Unstage those changes that should go into a second commit, then commit the staged changes. Commit the remaining changes in a second \(or third\) commit.\n\nAfter you are done, process the remaining commits by continuing the rebase.
dlgSgHistorySplitConfirm.hdl=Do you want to split the selected commit into multiple commits?
dlgSgHistorySplitConfirm.tle=Split Commit
dlgSgHistorySquash.btn"JIRA"=JIRA
dlgSgHistorySquash.btn"Select from Log"=从日志中选择
dlgSgHistorySquash.btn"Select"=选择
dlgSgHistorySquash.btn"Squash Commits"=压缩提交
dlgSgHistorySquash.edt"Authorship"=原创
dlgSgHistorySquash.edt"Commit Message"=提交消息
dlgSgHistorySquash.hdl=压缩多个提交
dlgSgHistorySquash.inf=所选提交将被一个压缩提交替换，该提交包含各个提交的所有更改。
dlgSgHistorySquash.mni"JIRA"=JIRA
dlgSgHistorySquash.mni"Log"=日志
dlgSgHistorySquash.tle=压缩提交
dlgSgHostingProviderAdd.btn"Add"=创建
dlgSgHostingProviderAdd.btn"Generate API Token"=生成 API 令牌
dlgSgHostingProviderAdd.btn"Generate Token"=生成令牌
dlgSgHostingProviderAdd.chk"Use OAuth token for repository authentication \(instead of password\)"=\
 使用 OAuth 令牌进行仓库验证 \(而不是密码\)
dlgSgHostingProviderAdd.chk"Use SSH instead of HTTPS to access repositories"=\
 使用 SSH 替代 HTTPS 来访问仓库
dlgSgHostingProviderAdd.chk"Use SSL client certificates \(usually not required\)"=\
 使用 SSL 客户端证书 \(通常不需要\)
dlgSgHostingProviderAdd.chk"Use a GitHub Enterprise instance"=使用 GitHub 企业实例
dlgSgHostingProviderAdd.chk"Use a custom Azure DevOps server"=\
 使用自定义 Azure DevOps 服务器
dlgSgHostingProviderAdd.chk"Use a custom GitLab server"=使用自定义 GitLab 服务器
dlgSgHostingProviderAdd.edt"Account"=账户
dlgSgHostingProviderAdd.edt"Certificate Password"=证书密码
dlgSgHostingProviderAdd.edt"Client Certificate"=客户端证书
dlgSgHostingProviderAdd.edt"Domain"=域名
dlgSgHostingProviderAdd.edt"Password"=密码
dlgSgHostingProviderAdd.edt"Server URL \(including collection\)"=服务器 URL \(包括集合\)
dlgSgHostingProviderAdd.edt"Server URL"=服务器地址
dlgSgHostingProviderAdd.edt"Token"=令牌
dlgSgHostingProviderAdd.edt"User Name"=用户名
dlgSgHostingProviderAdd.hdl=配置新的主机提供商账户
dlgSgHostingProviderAdd.inf=选择要为其配置新账户的托管服务提供商。
dlgSgHostingProviderAdd.lbl"For example: https://azure.devops.server/DefaultCollection"=例如: https://azure.devops.server/DefaultCollection
dlgSgHostingProviderAdd.lbl"The \(API\) token is a special auto-generated credential which SmartGit will use to authenticate at GitHub. It adds another layer of security, as you can easily revoke access by removing the token from the GitHub front-end."=\
 \(API\) 令牌是一种特殊的自动生成凭证，SmartGit 将使用该凭证在 GitHub 进行身份验证。它增加了另一层安全性，因为您可以通过在 GitHub 网站删除令牌来轻松撤销访问权限。
dlgSgHostingProviderAdd.lbl"The token may either be an autogenerated OAuth-token \(use 'Generate Token' below\) or a 'personal access token' which you can generate yourself in your Azure DevOps account settings."=\
 令牌可以是自动生成的 OAuth 令牌 \(使用下面的 “生成令牌”\) ，也可以是可以在 Azure DevOps 账户设置中自行生成 “个人访问令牌”。
dlgSgHostingProviderAdd.lbl"The token may either be an autogenerated OAuth-token \(use 'Generate Token' below\) or a 'personal access token' which you can generate yourself in your GitHub account settings."=\
 令牌可以是自动生成的 OAuth 令牌 \(使用下面的 “生成令牌”\) ，也可以是可以在 GitHub 账户设置中自行生成的 “个人访问令牌”。
dlgSgHostingProviderAdd.lbl"The token may either be an autogenerated OAuth-token \(use 'Generate Token' below\) or a 'personal access token' which you can generate yourself in your GitLab account settings."=\
 令牌生成方式有两种：1. 点击下面的 “生成令牌” 2. 以在 GitLab 账户设置中手动生成 “个人访问令牌” 。
dlgSgHostingProviderAdd.lbl"Use the same login information as for the assembla website."=\
 使用与 Assembla 网站相同的登录信息。
dlgSgHostingProviderAdd.lbl"Use the same login information as for the beanstalk website and make sure that for 'My Profile' - 'Account' - 'Account Settings' - 'Developer API' is enabled."=\
 使用与 Beanstalk 网站相同的登录信息，并确保在 “我的个人资料” - “账户” - “账户设置” - “开发人员 API” 中启用该功能。
dlgSgHostingProviderAdd.lbl"Use the same login information as for the codebasehq website."=\
 使用与 Codebasehq 网站相同的登录信息。
dlgSgHostingProviderAdd.lbl"Use the same login information as for the unfuddle website."=\
 使用与 Unfuddle 网站相同的登录信息。
dlgSgHostingProviderAdd.tle=添加主机提供商
dlgSgHostingProviderEdit.btn"Generate API Token"=生成 API 令牌
dlgSgHostingProviderEdit.btn"Generate Token"=生成令牌
dlgSgHostingProviderEdit.chk"Use OAuth token for repository authentication \(instead of password\)"=\
 使用 OAuth 令牌进行仓库验证 \(而不是密码\)
dlgSgHostingProviderEdit.chk"Use SSH instead of HTTPS to access repositories"=\
 使用 SSH 替代 HTTPS 来访问仓库
dlgSgHostingProviderEdit.chk"Use SSL client certificates \(usually not required\)"=\
 使用 SSL 客户端证书 \(通常不需要\)
dlgSgHostingProviderEdit.chk"Use a GitHub Enterprise instance"=使用 GitHub 企业实例
dlgSgHostingProviderEdit.chk"Use a custom GitLab server"=使用自定义 GitLab 服务器
dlgSgHostingProviderEdit.edt"Account"=账户
dlgSgHostingProviderEdit.edt"Certificate Password"=证书密码
dlgSgHostingProviderEdit.edt"Client Certificate"=客户端证书
dlgSgHostingProviderEdit.edt"Name"=用户名
dlgSgHostingProviderEdit.edt"Password"=密码
dlgSgHostingProviderEdit.edt"Server URL"=服务器地址
dlgSgHostingProviderEdit.edt"Token"=令牌
dlgSgHostingProviderEdit.err"Please enter a Personal Access Token for your GitLab account."=\
 请为您的 GitLab 账户输入个人访问令牌。
dlgSgHostingProviderEdit.err"Please enter an OAuth 'refresh' token."=\
 请输入 OAuth '刷新'令牌。
dlgSgHostingProviderEdit.err"Please enter the API token."=请输入 API 令牌。
dlgSgHostingProviderEdit.err"Please specify the private key file."=\
 请指定私钥文件。
dlgSgHostingProviderEdit.hdl%1=配置 $1 账户
dlgSgHostingProviderEdit.inf%1=请指定您的凭据以连接到 $1。
dlgSgHostingProviderEdit.lbl"The \(API\) token is a special auto-generated credential which SmartGit will use to authenticate at GitHub. It adds another layer of security, as you can easily revoke access by removing the token from the GitHub front-end."=\
 \(API\) 令牌是一种特殊的自动生成的凭证，SmartGit 将使用该凭证在 GitHub 上进行身份验证。 它增加了另一层安全性，因为您可以通过从 GitHub 前端删除令牌轻松撤消访问。
dlgSgHostingProviderEdit.lbl"The token may either be an autogenerated OAuth-token \(use 'Generate Token' below\) or a 'personal access token' which you can generate yourself in your GitHub account settings."=\
 令牌可以是自动生成的 OAuth 令牌 \(使用下面的 “生成令牌”\) ，也可以是可以在 GitHub 账户设置中自行生成的 “个人访问令牌”。
dlgSgHostingProviderEdit.lbl"The token may either be an autogenerated OAuth-token \(use 'Generate Token' below\) or a 'personal access token' which you can generate yourself in your GitLab account settings."=\
 令牌生成方式有两种：1. 点击下面的 “生成令牌” 2. 以在 GitLab 账户设置中手动生成 “个人访问令牌”。
dlgSgHostingProviderEdit.tle=GitLab
dlgSgHostingProviderEdit.wrn"Connection to '$1' failed: $2"=连接到 '$1' 失败：$2
dlgSgHostingProviderSelectRepository.btn"Select"=选择
dlgSgHostingProviderSelectRepository.col"Name"=名称
dlgSgHostingProviderSelectRepository.col"Namespace"=命名空间
dlgSgHostingProviderSelectRepository.col"Repository"=仓库
dlgSgHostingProviderSelectRepository.mni"Copy Selection in Column"=复制列中的所选内容
dlgSgHostingProviderSelectRepository.mni"Name"=名称
dlgSgHostingProviderSelectRepository.mni"Owner"=所有者
dlgSgHostingProviderSelectRepository.mni"Repository"=仓库
dlgSgHostingProviderSelectRepository.tle=GitHub 项目
dlgSgHttpPasswordAuthenticationFailedCause1.fur%3=无法请求 OAuth 访问令牌。很可能您的 $1 配置已更改且 SmartGit 存储的 OAuth 凭据无效。\n\n要解析，请在偏好设置中重新创建 $2 主机提供商。\n\n详细信息：\n\n $3
dlgSgHttpPasswordAuthenticationFailedCause1.hdl%1=$1 OAuth 身份验证失败
dlgSgHttpPasswordAuthenticationFailedCause1.tle=HTTP 身份验证
dlgSgHttpPasswordCredentials.btn"Login"=登录
dlgSgHttpPasswordCredentials.chk"Store password"=存储密码
dlgSgHttpPasswordCredentials.edt"Password"=密码
dlgSgHttpPasswordCredentials.edt"User Name"=用户名
dlgSgHttpPasswordCredentials.hdl%1=登录到 “$1”
dlgSgHttpPasswordCredentials.inf=提供用于对仓库进行身份验证的用户名和密码。
dlgSgHttpPasswordCredentials.tle=登录
dlgSgIgnoreChanged.btn"Discard Changes"=放弃更改
dlgSgIgnoreChanged.fur=继续操作时，更改将被丢弃！
dlgSgIgnoreChanged.hdl=您确定要删除已更改的文档？
dlgSgIgnoreChanged.tle=忽略
dlgSgIgnoreDirectoryConfirm.btn"Ignore"=忽略
dlgSgIgnoreDirectoryConfirm.edt"Ignore File"=忽略文件
dlgSgIgnoreDirectoryConfirm.fur=目录名称将添加到忽略文件中。如果忽略文件不存在，则将创建它。
dlgSgIgnoreDirectoryConfirm.hdl%1=你想忽略目录 “$1” 吗？
dlgSgIgnoreDirectoryConfirm.tle=忽略
dlgSgIgnoreEdit.btn"Edit"=修改
dlgSgIgnoreEdit.hdl=修改 Git 忽略文件
dlgSgIgnoreEdit.inf=选择要修改的 Git 忽略文件
dlgSgIgnoreEdit.mni"Copy Path"=复制路径
dlgSgIgnoreEdit.mni"Reveal"=显示
dlgSgIgnoreEdit.tle=修改忽略文件
dlgSgIgnoreFile.btn"Ignore"=忽略
dlgSgIgnoreFile.btn"Remove && Ignore"=删除并忽略
dlgSgIgnoreFile.edt"Ignore File"=忽略文件
dlgSgIgnoreFile.err"The pattern must match all selected file names. For instance, '$1' is not matched."=\
 模式必须匹配所有选定的文件名。例如，“$1” 不匹配。
dlgSgIgnoreFile.hdl=标记要忽略的文件
dlgSgIgnoreFile.inf=选择是仅忽略所选文件还是忽略与指定模式匹配的所有文件。跟踪的文件将被删除 \(停止跟踪\)。
dlgSgIgnoreFile.lbl"Use ? to match a single or \* to match multiple arbitrary characters. The pattern will be saved in the .gitignore file of the same directory."=\
 使用 ? 匹配单个或 \* 以匹配多个任意字符。该模式将保存在同一目录的 .gitignore 文件中。
dlgSgIgnoreFile.rbt"Ignore as pattern \(e.g. '\*.obj'\):"=正则忽略 \(例如 \*.obj \)：
dlgSgIgnoreFile.rbt"Ignore explicitly \(e.g. 'Makefile'\)"=明确忽略 \(例如 Makefile \)：
dlgSgIgnoreFile.tle=忽略
dlgSgIndexEditorSaveOrDiscard.btn"Discard"=丢弃
dlgSgIndexEditorSaveOrDiscard.btn"Save"=保存
dlgSgIndexEditorSaveOrDiscard.fur=如果您现在不保存更改，则更改将丢失。
dlgSgIndexEditorSaveOrDiscard.hdl=要保存更改吗？
dlgSgIndexEditorSaveOrDiscard.tle=关闭
dlgSgJournalDoubleClick.btn"Check Out '$1'"=Check Out '$1'
dlgSgJournalDoubleClick.btn"Open Log"=Open Log
dlgSgJournalDoubleClick.fur%1=Select either to check out '$1' or to open the Log for the selected commit.
dlgSgJournalDoubleClick.hdl%1=Do you want to check out '$1'?
dlgSgJournalDoubleClick.tle=Journal
dlgSgJournalFormCommitCantBeModified.fur=不是您 HEAD 主要父系历史的一部分
dlgSgJournalFormCommitCantBeModified.hdl=至少有一个选定的提交无法修改。
dlgSgJournalFormCommitCantBeModified.tle=编辑作者
dlgSgLfsInstallConfirm.btn"Install"=安装
dlgSgLfsInstallConfirm.fur=这将配置 LFS 所需的挂钩和过滤器。
dlgSgLfsInstallConfirm.hdl=是否要为大文件支持 \(LFS\) 初始化此仓库？
dlgSgLfsInstallConfirm.tle=LFS 安装
dlgSgLfsTrack.edt"Pattern"=模式
dlgSgLfsTrack.err"File '$1' does not match the specified pattern."=\
 文件 “$1” 不匹配指定的模式。
dlgSgLfsTrack.hdl=将文件或模式标记为已跟踪
dlgSgLfsTrack.inf=指定应该由大文件支持 \(LFS\) 处理的文件名模式。
dlgSgLfsTrack.tle=LFS 跟踪
dlgSgLocalChangesFormTakeBlockListenerRevertWorkingTreeFile.btn"Revert"=还原
dlgSgLocalChangesFormTakeBlockListenerRevertWorkingTreeFile.fur%1=您将要将索引中的行应用到工作区文件 “$1”。修改将立即保存。
dlgSgLocalChangesFormTakeBlockListenerRevertWorkingTreeFile.hdl=您真的想要还原工作区中文件的更改吗？
dlgSgLocalChangesFormTakeBlockListenerRevertWorkingTreeFile.tle=还原工作区文件
dlgSgLocalCommandRepositoryEmpty.fur=It's not possible to perform the requested operation on an empty repository.
dlgSgLocalCommandRepositoryEmpty.hdl=The repository is empty.
dlgSgLocalCommandRepositoryEmpty.tle=Save Stash
dlgSgLogCheckoutFileAs.btn"Save After"=保存之后
dlgSgLogCheckoutFileAs.btn"Save Before"=保存之前
dlgSgLogCheckoutFileAs.edt"Target File"=目标文件
dlgSgLogCheckoutFileAs.hdl=保存仓库文件
dlgSgLogCheckoutFileAs.inf"Select the local file to saved to."=\
 选择要保存到的本地文件。
dlgSgLogCheckoutFileAs.inf"Select whether to save the file state Before or After the selected commit."=\
 选择是在所选提交之前还是之后保存文件状态。
dlgSgLogCheckoutFileAs.tle=文件另存为
dlgSgLogCommentDeleteConfirm.hdl%1=您真的想删除 “$1” 注释吗？
dlgSgLogComment(|s)DeleteConfirm.btn"Delete Comment"=删除注释
dlgSgLogComment(|s)DeleteConfirm.fur=注释被删除后无法还原.
dlgSgLogComment(|s)DeleteConfirm.tle=删除注释
dlgSgLogCommentsDeleteConfirm.hdl%1=您真的想删除 $1 注释吗？
dlgSgLogCompareSelectedFilesAgainstEachOther.btn"Compare Separately"=单独比较
dlgSgLogCompareSelectedFilesAgainstEachOther.btn"Compare With Each Other"=相互比较
dlgSgLogCompareSelectedFilesAgainstEachOther.fur=您可以将所选文件相互比较，或者为每个文件打开单独与其之前的状态比较。
dlgSgLogCompareSelectedFilesAgainstEachOther.hdl=您想要将所选文件相互比较吗？
dlgSgLogCompareSelectedFilesAgainstEachOther.tle=比较
dlgSgLogCompareWithWorkingTree.btn"Compare After"=比较之后
dlgSgLogCompareWithWorkingTree.btn"Compare Before"=比较之前
dlgSgLogCompareWithWorkingTree.edt"Working Tree File"=工作区文件
dlgSgLogCompareWithWorkingTree.hdl=将仓库文件与本地文件进行比较
dlgSgLogCompareWithWorkingTree.inf=选择是与选定提交之前还是之后的仓库文件进行比较。
dlgSgLogCompareWithWorkingTree.tle=与工作区比较
dlgSgLogGraphRootSwitch.chk"Include tracked remote branches"=包括跟踪的远程分支
dlgSgLogGraphRootSwitch.hdl=选择显示的分支
dlgSgLogGraphRootSwitch.inf=选择要在图表中显示提交的分支。
dlgSgLogGraphRootSwitch.mni"Toggle"=切换
dlgSgLogGraphRootSwitch.tle=选择分支
dlgSgLogOpenFailedRepository.fur=仓库是否仍然有效？
dlgSgLogOpenFailedRepository.hdl=仓库无法打开。
dlgSgLogOpenFailedRepository.tle=日志
dlgSgLogOpenFailedSubmodule.fur=仓库是否仍然有效？
dlgSgLogOpenFailedSubmodule.hdl=子模块无法打开。
dlgSgLogOpenFailedSubmodule.tle=日志
dlgSgLogOpenNewWindow.btn"Existing Window"=现有窗口
dlgSgLogOpenNewWindow.btn"New Window"=新建窗口
dlgSgLogOpenNewWindow.fur=已经存在一个可以显示的日志窗口。
dlgSgLogOpenNewWindow.hdl=是否要打开新的日志窗口？
dlgSgLogOpenNewWindow.tle=日志
dlgSgLogOpenSubmoduleLinkOrRepository.btn"History of Updates"=更新历史
dlgSgLogOpenSubmoduleLinkOrRepository.btn"Submodule Log"=子模块日志
dlgSgLogOpenSubmoduleLinkOrRepository.fur=子模块更新的历史日志将显示从父仓库的角度对子模块链接 \('GITLINK'\) 的更改。 子模块仓库的日志将显示子模块仓库本身中发生的所有提交。
dlgSgLogOpenSubmoduleLinkOrRepository.hdl=是否要显示子模块更新的历史日志或子模块仓库的日志？
dlgSgLogOpenSubmoduleLinkOrRepository.tle=打开日志
dlgSgLogRefActionsDeleteConfirm.btn"Delete Branch"=删除分支
dlgSgLogRefActionsDeleteConfirm.fur=您可能会丢失未推送的更改，或还原分支可能会很复杂 \(es\)！
dlgSgLogRefActionsDeleteConfirm.hdl%1=你真的想删除本地分支 “$1” 吗？
dlgSgLogRefActionsDeleteConfirm.tle=删除本地分支
dlgSgLogRefreshRepositoryInvalid.btn"Close Repository"=关闭仓库
dlgSgLogRefreshRepositoryInvalid.btn"Remove Repository"=移除仓库
dlgSgLogRefreshRepositoryInvalid.fur%1=这可能意味着在\n\n $1 的仓库被删除或在 SmartGit 外部重命名。
dlgSgLogRefreshRepositoryInvalid.hdl%1=打开的仓库 “$1” 变为无效。
dlgSgLogRefreshRepositoryInvalid.tle=刷新
dlgSgMerge.btn"Branches"=分支
dlgSgMerge.btn"Create Merge-Commit"=创建合并提交
dlgSgMerge.btn"Merge to Working Tree"=合并到工作区
dlgSgMerge.btn"Squash-Merge"=Squash-Merge
dlgSgMerge.hdl=合并
dlgSgMerge.inf=选择要合并的分支或提交以及如何将它们合并到工作区中。
dlgSgMerge.mni"Copy ID"=Copy ID
dlgSgMerge.mni"Copy Message"=Copy Message
dlgSgMerge.mni"Refresh"=刷新
dlgSgMerge.tle=合并
dlgSgMergeConfirmNoCommit.btn"Merge"=合并
dlgSgMergeConfirmNoCommit.fur=The selected revisions\(s\) will be merged to the working tree.\n\nNote that merging directly to the GitFlow-master branch is not recommended. Instead, you should start a hotfix.
dlgSgMergeConfirmNoCommit.hdl=Do you want to perform the merge?
dlgSgMergeConfirmNoCommit.tle=Merge
dlgSgMergeHowToMerge.btn"Create Merge-Commit"=创建合并提交
dlgSgMergeHowToMerge.btn"Fast-Forward"=快进
dlgSgMergeHowToMerge.btn"Merge to Working Tree"=合并到工作区
dlgSgMergeHowToMerge.btn"Squash-Merge"=压缩合并
dlgSgMergeHowToMerge.fur=快进合并意味着只将当前分支 \(HEAD\) 向前移动到选定的提交。作为替代方法，您可以创建合并提交或合并到工作区。 在后一种情况下，您可以查看更改，然后稍后创建合并或普通 \(压缩\) 提交。
dlgSgMergeHowToMerge.hdl"How to merge from branch '$1'?"=\
 如何从分支 “$1” 合并？
dlgSgMergeHowToMerge.hdl"How to merge from tag '$1'?"=\
 How to merge from tag '$1'?
dlgSgMergeHowToMerge.tle=合并
dlgSgMergeNoop.fur=Merging a commit's own history into itself is technically allowed by Git but it's a no-op and will not give a new commit nor any other meaningful changes.
dlgSgMergeNoop.hdl=There is nothing to merge.
dlgSgMergeNoop.tle=Merge
dlgSgOpenRepository.edt"Repository"=仓库
dlgSgOpenRepository.err"Please specify the root directory of a Git or Mercurial repository."=\
 请指定 Git 或 Mercurial 仓库的根目录。
dlgSgOpenRepository.err"Please specify the root directory of a Git repository."=\
 请指定 Git 仓库的根目录。
dlgSgOpenRepository.hdl=添加现有或创建新仓库
dlgSgOpenRepository.inf=指定要打开的本地 Git 或 Mercurial 仓库。要创建新仓库，请指定一个空目录。
dlgSgOpenRepository.tle=添加或创建仓库
dlgSgOpenRepositoryInitializeChooseVcs.btn"Git"=Git
dlgSgOpenRepositoryInitializeChooseVcs.btn"Mercurial"=Mercurial
dlgSgOpenRepositoryInitializeChooseVcs.fur=指定的目录似乎不是有效的 Git 或 Mercurial 仓库。
dlgSgOpenRepositoryInitializeChooseVcs.hdl=什么 VCS 应该用于初始化 “swt”？
dlgSgOpenRepositoryInitializeChooseVcs.tle=添加或创建仓库
dlgSgOpenRepositoryInitializeGit.btn"Initialize"=初始化
dlgSgOpenRepositoryInitializeGit.fur=指定的目录似乎不是有效的 Git 仓库。
dlgSgOpenRepositoryInitializeGit.hdl%1=是否应该将 '$1' 初始化为新的 Git 仓库？
dlgSgOpenRepositoryInitializeGit.tle=添加或创建仓库
dlgSgOpenRepositorySvnWorkingCopy.fur%1=You are trying to open an existing SVN working copy which is not possible with SmartGit. Instead, please use $1 to create a Git clone of your SVN repository \(i.e. a working copy based on Git instead of SVN\).
dlgSgOpenRepositorySvnWorkingCopy.hdl=Can't open SVN working copy, please re-clone with SmartGit.
dlgSgOpenRepositorySvnWorkingCopy.tle=Add or Create Repository
dlgSgOutput.chk"Don't show again for these $1 warnings"=\
 不要再显示这些 $1 警告
dlgSgOutput.chk"Don't show again for this warning"=\
 不要再显示此警告
dlgSgOutput.chk"Show automatically for failed command"=自动显示失败的命令
dlgSgOutput.lbl"Branches need merging first."=需要先合并分支.
dlgSgOutput.lbl"Command Abort failed!"=Command Abort failed!
dlgSgOutput.lbl"Command Check Out Branch failed!"=Command Check Out Branch failed!
dlgSgOutput.lbl"Command Cherry-Pick produced warnings."=Command Cherry-Pick produced warnings.
dlgSgOutput.lbl"Command Commit failed!"=Command Commit failed!
dlgSgOutput.lbl"Command Discard failed!"=Command Discard failed!
dlgSgOutput.lbl"Command Pull \(Rebase\) failed!"=Command Pull \(Rebase\) failed!
dlgSgOutput.lbl"Command Reset failed!"=Command Reset failed!
dlgSgOutput.lbl"Command Start Support Branch failed!"=Command Start Support Branch failed!
dlgSgOutput.lbl"If in question, please ask your repository administrator."=\
 如果有问题，请咨询您的仓库管理员。
dlgSgOutput.lbl"Your local changes to the following files would be overwritten by checkout:\ncould not detach HEAD"=\
 Your local changes to the following files would be overwritten by checkout:\ncould not detach HEAD
dlgSgOutput.tle"Command Failed"=命令失败
dlgSgOutput.tle"Command Output"=命令输出
dlgSgOutput.tle"Command Succeeded"=命令成功
dlgSgOutput.tle"Output"=输出
dlgSgPingRepositoryFailed.fur%1=请检查仓库 URL。\n\n$1
dlgSgPingRepositoryFailed.hdl%1=无法连接到仓库 “$1”。
dlgSgPingRepositoryFailed.tle=克隆
dlgSgPreferences.btn"Add"=创建
dlgSgPreferences.btn"Assign"=分配
dlgSgPreferences.btn"Change Master Password"=更改主密码
dlgSgPreferences.btn"Clear Cache"=清除缓存
dlgSgPreferences.btn"Clear"=清除
dlgSgPreferences.btn"Copy"=复制
dlgSgPreferences.btn"Edit"=编辑
dlgSgPreferences.btn"Export"=导出
dlgSgPreferences.btn"I accept the risk!"=我接受风险！
dlgSgPreferences.btn"Import"=导入
dlgSgPreferences.btn"Move Down"=下移
dlgSgPreferences.btn"Move Up"=上移
dlgSgPreferences.btn"Re-Add Defaults"=重新添加默认值
dlgSgPreferences.btn"Remove All"=移除所有
dlgSgPreferences.btn"Remove"=移除
dlgSgPreferences.btn"Reset to Defaults"=重置为默认
dlgSgPreferences.btn"Reset"=重置
dlgSgPreferences.btn"Show Password"=显示密码
dlgSgPreferences.cdl"Authentication"=认证
dlgSgPreferences.cdl"Background Commands"=后台命令
dlgSgPreferences.cdl"Built-in Text Editors"=内置文本编辑器
dlgSgPreferences.cdl"Commands"=命令
dlgSgPreferences.cdl"Conflict Solvers"=冲突解决器
dlgSgPreferences.cdl"Diff Tools"=差异工具
dlgSgPreferences.cdl"Executables"=可执行文件
dlgSgPreferences.cdl"Git Config"=Git 配置
dlgSgPreferences.cdl"Git Executable"=Git 可执行文件
dlgSgPreferences.cdl"Hosting Providers"=托管服务提供商
dlgSgPreferences.cdl"Keyboard Shortcuts"=键盘快捷键
dlgSgPreferences.cdl"Log and Working Tree window"=日志和工作区窗口
dlgSgPreferences.cdl"Log"=日志
dlgSgPreferences.cdl"Low-level Properties"=低级属性
dlgSgPreferences.cdl"Privacy"=隐私
dlgSgPreferences.cdl"Proxy"=代理
dlgSgPreferences.cdl"Refresh"=刷新
dlgSgPreferences.cdl"SmartGit Updates"=SmartGit 更新
dlgSgPreferences.cdl"Spell Checker"=拼写检查
dlgSgPreferences.cdl"Standard Window"=标准窗口
dlgSgPreferences.cdl"Tools"=工具
dlgSgPreferences.cdl"User Interface"=用户界面
dlgSgPreferences.chk"Add untracked files"=添加未跟踪的文件
dlgSgPreferences.chk"Allow all commands on stash and pull request commits"=\
 允许所有关于贮藏和拉取请求提交的命令
dlgSgPreferences.chk"Allow modifying pushed commits \(e.g. forced-push\)"=\
 允许修改推送的提交 \(例如：强制推送\)
dlgSgPreferences.chk"Allow to open multiple Log windows for the same repository/file"=\
 允许为同一仓库/文件打开多个日志窗口
dlgSgPreferences.chk"Also detect renames for untracked and missing files"=\
 检测未跟踪和丢失的文件的重命名
dlgSgPreferences.chk"Always fetch new commits, tags and branches from submodule"=\
 始终从子模块中获取新的提交、标签和分支
dlgSgPreferences.chk"Ask for master password on startup"=\
 在启动时询问主密码
dlgSgPreferences.chk"Autoindent new lines"=自动缩进新行
dlgSgPreferences.chk"Automatically save stash on common commands, if they fail due to local changes"=\
 如果由于本地更改而导致失败，则自动将贮藏保存在常用命令上
dlgSgPreferences.chk"Automatically send 'crash footprints' after an internal error has occurred"=\
 发生内部错误后自动发送 “崩溃追踪”
dlgSgPreferences.chk"Automatically set up tracking for new branches \(requires push.default to be unset\)"=\
 自动设置新分支的跟踪 \(需要取消设置 push.default \)
dlgSgPreferences.chk"Automatically set up tracking for new branches"=\
 自动设置新分支的跟踪
dlgSgPreferences.chk"Begin of line: jump to first non-whitespace character"=\
 行首：跳转到第一个非空白字符
dlgSgPreferences.chk"Closed 'favorite' repositories"=“我的收藏” 已关闭的的仓库
dlgSgPreferences.chk"Compare with working tree, even if all changes are staged"=\
 与工作区比较，即使所有更改都已暂存
dlgSgPreferences.chk"Detect local changes in closed 'favorite' repositories"=\
 检测 “我的收藏” 中已关闭的仓库中的本地更改
dlgSgPreferences.chk"Detect remote changes"=检测远程更改
dlgSgPreferences.chk"Detect renames \(for added and removed files, as command line Git does\)"=\
 检测重命名 \(创建和删​​除文件，如 Git 命令行所做的那样\)
dlgSgPreferences.chk"Distinguish between content and EOL-only changes \(slightly more expensive\)"=\
 区分内容和 EOL-only 的更改 \(稍微昂贵的代价\)
dlgSgPreferences.chk"Enable integration for configured hosting providers \(pull requests, comments\)"=\
 为已配置的主机提供商启用集成 \(拉取请求，注释\)
dlgSgPreferences.chk"Focus next change after accepting change \(Take Left/Take Right\)"=\
 接受变更后，关注下一个变化 \(向左/向右\)
dlgSgPreferences.chk"For Preview versions, automatically download the latest build"=\
 对于预览版本，自动下载最新版本
dlgSgPreferences.chk"For ambiguous protocols like 'https', show dialog to choose between Git and SVN clone"=\
 对于像 "https" 这样含糊不清的协议，显示选择Git或SVN克隆的对话框
dlgSgPreferences.chk"Highlight current line in text content"=\
 突出显示文本内容中的当前行
dlgSgPreferences.chk"Home and end: operate on line, not the document"=\
 首页和结尾：在线操作，而不是文档
dlgSgPreferences.chk"Include untracked files"=包括未跟踪的文件
dlgSgPreferences.chk"Initialize new submodules"=初始化新的子模块
dlgSgPreferences.chk"Left and right cursor moves: limit to current line"=\
 左右光标移动：限制为当前行
dlgSgPreferences.chk"Open repositories when idle"=空闲时打开仓库
dlgSgPreferences.chk"Open the last used repositories"=打开最后使用的仓库
dlgSgPreferences.chk"Periodically invoke Git's garbage collection when idle"=\
 空闲时定期调用 Git 的垃圾回收
dlgSgPreferences.chk"Preselect 'Staged' if files are staged, even if a file without staged changes is selected"=\
 如果文件已暂存，则预选 “已暂存”，即使选择了没有暂存更改的文件也是如此
dlgSgPreferences.chk"Proxy requires authentication"=代理需要身份验证
dlgSgPreferences.chk"Prune obsolete remote tracked branches"=修剪废弃的远程跟踪分支
dlgSgPreferences.chk"Push all tags"=推送所有标签
dlgSgPreferences.chk"Refresh file system also while SmartGit is in background"=\
 SmartGit 在后台工作时也刷新文件系统
dlgSgPreferences.chk"Remember from last used single Log or Working Tree window"=\
 记住最后使用的日志或者工作区的窗口
dlgSgPreferences.chk"Remove leading and trailing whitespace from commit message"=\
 从提交消息中删除前导和尾随空格
dlgSgPreferences.chk"Remove missing files"=删除丢失的文件
dlgSgPreferences.chk"Restore all confirmation dialogs"=还原所有确认对话框
dlgSgPreferences.chk"Send 'crash footprints' after an internal error has occurred"=\
 发生内部错误后发送 “崩溃跟踪”
dlgSgPreferences.chk"Send usage statistics"=发送使用量统计
dlgSgPreferences.chk"Show also the resolve dialog for external conflict solvers"=\
 也显示外部冲突解决器的解决对话框
dlgSgPreferences.chk"Show chooser dialog if multiple entries match"=\
 如果匹配多个条目，显示选择器对话框
dlgSgPreferences.chk"Show line length guides \(only useful for monospaced-font\)"=\
 显示行长参考线 \(仅适用于单空格字体\)
dlgSgPreferences.chk"Show verbose date for last days, e.g. Yesterday"=\
 显示最后几天的详细日期，例如：昨天
dlgSgPreferences.chk"Show welcome dialog if no repository has been reopened"=\
 如果没有重新打开仓库，则显示欢迎对话框
dlgSgPreferences.chk"Sign all commits"=对所有提交进行签名
dlgSgPreferences.chk"Swap 'ours' and 'theirs' on Rebase conflicts for easier understanding"=\
 在变基冲突上使用 “我们的” 和 “他们的” 显示以便于理解
dlgSgPreferences.chk"Tab enters and Backspace deletes multiple leading spaces"=\
 制表符 \(Tab\) 输入和退格键 \(Backspace\)删除多个前导空格
dlgSgPreferences.chk"Trim whitespace"=删除空格
dlgSgPreferences.chk"Update registered submodules"=更新已注册的子模块
dlgSgPreferences.chk"Use gravatar.com to show images for the users"=\
 使用 gravatar.com 为用户显示图像
dlgSgPreferences.chk"Use indentation from previous non-empty line"=\
 使用前一个非空行的缩进
dlgSgPreferences.chk"Use pre-installed \(\"system\"\) Git-Flow\*"=使用预装 \(系统\) Git 工作流\*
dlgSgPreferences.chk"Warn for slow rename detection"=重命名检测缓慢时发出警告
dlgSgPreferences.col"Accelerator"=加速器
dlgSgPreferences.col"Account"=账号
dlgSgPreferences.col"Applies To"=适用于
dlgSgPreferences.col"Arguments"=参数
dlgSgPreferences.col"Command + Arguments"=命令和参数
dlgSgPreferences.col"Command"=命令
dlgSgPreferences.col"Default"=默认
dlgSgPreferences.col"Details"=详情
dlgSgPreferences.col"Dictionary File"=字典文件
dlgSgPreferences.col"File Pattern"=文件模式
dlgSgPreferences.col"Key"=键
dlgSgPreferences.col"Language"=语言
dlgSgPreferences.col"Name"=名称
dlgSgPreferences.col"Patterns"=模式
dlgSgPreferences.col"Repository"=仓库
dlgSgPreferences.col"Shortcut"=快捷键
dlgSgPreferences.col"Value"=值
dlgSgPreferences.edt"Date Format\*"=日期格式\*
dlgSgPreferences.edt"Email"=电子邮箱
dlgSgPreferences.edt"Example"=例如
dlgSgPreferences.edt"Fetch"=获取
dlgSgPreferences.edt"File Double-Click"=File Double-Click
dlgSgPreferences.edt"File Name Matches\*"=文件名匹配\*
dlgSgPreferences.edt"Font Family"=字体系列
dlgSgPreferences.edt"Font Size"=字体大小
dlgSgPreferences.edt"Functionality\*"=功能\*
dlgSgPreferences.edt"GPG Program"=GPG 程序
dlgSgPreferences.edt"Git Executable"=Git 可执行文件
dlgSgPreferences.edt"Hg Executable"=Hg 可执行文件
dlgSgPreferences.edt"Host"=服务器
dlgSgPreferences.edt"Known credentials"=已知凭据
dlgSgPreferences.edt"Language\*"=语言\*
dlgSgPreferences.edt"Name"=Name
dlgSgPreferences.edt"On startup"=在启动时
dlgSgPreferences.edt"Password"=密码
dlgSgPreferences.edt"Port"=端口
dlgSgPreferences.edt"Prefer"=喜欢
dlgSgPreferences.edt"Preview"=预览
dlgSgPreferences.edt"Shortcut"=快捷键
dlgSgPreferences.edt"Signing Key"=签名密钥
dlgSgPreferences.edt"Startup Window"=标准窗口
dlgSgPreferences.edt"Submodule handling\*"=子模块处理\*
dlgSgPreferences.edt"Suggest to"=建议
dlgSgPreferences.edt"Text File Encoding"=文本文件编码
dlgSgPreferences.edt"Theme"=主题
dlgSgPreferences.edt"Theme\*"=主题\*
dlgSgPreferences.edt"Time Format\*"=时间格式\*
dlgSgPreferences.edt"Username"=用户名
dlgSgPreferences.hnt"Search"=搜索
dlgSgPreferences.lbl"Application can be updated manually in the About dialog"=\
 Application can be updated manually in the About dialog
dlgSgPreferences.lbl"Changing these low-level properties can be harmful to the stability or performance of SmartGit. You should only continue if you are sure of what you are doing. Changed properties with a trailing \* need a restart to be applied."=\
 更改这些低级别属性可能会损害 SmartGit 的稳定性或性能。只有在确定自己在做什么的情况下才能继续。结尾含 \* 的属性更改之后需要重新启动才能生效。
dlgSgPreferences.lbl"Define external tools which will show up in the Tools menu. Those marked with a leading \* in front of the name can be used by the Open command."=\
 定义将显示在 “工具” 菜单中的外部工具。“打开” 命令可以使用在名称前面标有前导 \* 的那些。
dlgSgPreferences.lbl"Here you can edit your account's 'gitconfig' which contains the defaults for all repositories."=\
 在这里，您可以编辑帐户的 'gitconfig' ，其中包含所有仓库的默认值。
dlgSgPreferences.lbl"Here you can view your account's 'gitconfig'. Because it contains 'include'-sections you need to edit it manually."=\
 在这里，您可以查看您帐户的 'gitconfig' 。由于它包含“包含”部分，因此您需要手动编辑它。
dlgSgPreferences.lbl"If you are using SSH to connect to other Git repositories, select what SSH client to use."=\
 如果您使用 SSH 连接到其他 Git 仓库，请选择要使用的 SSH 客户端。
dlgSgPreferences.lbl"In order to use all SmartGit functionality, you need to have command line Git installed on your system. Provide here the full path to the installed 'git' executable."=\
 要使用所有 SmartGit 功能，您需要在系统上安装 Git 命令行。在这里提供已安装的 “git” 可执行文件的完整路径。
dlgSgPreferences.lbl"In order to use all SmartGit functionality, you need to have command line Git or Mercurial installed on your system. Provide here the full path to the installed 'git' or 'hg' executable."=\
 要使用所有 SmartGit 功能，您需要在系统上安装 Git 命令行或 Mercurial。在这里提供已安装的 “git” 或 “hg” 可执行文件的完整路径。
dlgSgPreferences.lbl"Note: The password will be stored in plain text in SmartGit's configuration area!"=\
 注意：密码将以纯文本形式存储在 SmartGit 的配置区域中！
dlgSgPreferences.lbl"Please help to improve SmartGit's quality by automatically sending 'crash footprints' which do not contain any sensitive information. You can change this option later in the preferences.\n\nA 'crash footprint' contains details about your machine \(e.g. version of operating system\), SmartGit's version/build number, the JVM state and where the internal error occurred.\n\nIt contains NO POTENTIALLY SENSITIVE INFORMATION like user names, email addresses, file contents, file paths or server names."=\
 请通过自动发送不包含任何敏感信息的 “崩溃踪迹” 来帮助提高 SmartGit 的质量。您可以稍后在偏好设置中更改此选项。\n\n崩溃踪迹包含有关您的计算机\的详细信息 \(例如，操作系统的版本\)，SmartGit 的版本/内部版本号，JVM 状态以及发生内部错误的位置。\n\n它不包含任何潜在的敏感信息，如用户名，电子邮件地址，文件内容，文件路径或服务器名称。
dlgSgPreferences.lbl"The proxy is primarily used for the Check for New Version. It will also be used for Git HTTP\(s\) connections if no reasonable system proxy configuration seems to be present already \(see documentation for details\)."=\
 代理主要用于检查新版本。如果似乎没有合理的系统代理配置，它也将用于 Git HTTP\(s\)连接 \(请参阅文档了解详细信息\)。
dlgSgPreferences.lbl"This file will be sent as is: $1"=\
 This file will be sent as is: $1
dlgSgPreferences.lbl"When comparing files, this list is searched from top to bottom to find a matching diff tool. If none is found, the built-in file compare is used for text files."=\
 比较文件时，将从上到下搜索此列表以查找匹配的差异工具。如果未找到，则内置文件比较用于文本文件。
dlgSgPreferences.lbl"When invoking the Conflict Solver feature, this list is searched from top to bottom to find a matching entry. If none is found, the built-in Conflict Solver is used for text files."=\
 调用冲突解算器功能时，将从上到下搜索此列表以查找匹配的条目。如果未找到，则内置的冲突解算器用于文本文件。
dlgSgPreferences.lbl"You may configure hosting provider accounts to simplify accessing your hosted repositories or to enable the GitHub pull request and comment features."=\
 您可以配置主机提供商账户以简化对托管仓库的访问或启用 GitHub 拉取请求和注释功能。
dlgSgPreferences.lbl"\* if repository commit references non-pushed submodule commit"=\
 \* if repository commit references non-pushed submodule commit
dlgSgPreferences.lbl"\*\) these options require an application restart to be applied"=\
 \*\) 这些选项需要重新启动应用程序
dlgSgPreferences.lbl"\*\) this option requires an application restart to be applied"=\
 \*\) 这些选项需要重新启动应用程序
dlgSgPreferences.lbl"easy to set up and use, supports public key and password authentication"=\
 easy to set up and use, supports public key and password authentication
dlgSgPreferences.lbl"may be harder to configure and use for new users, but is more flexible"=\
 may be harder to configure and use for new users, but is more flexible
dlgSgPreferences.mni"Accelerator"=Accelerator
dlgSgPreferences.mni"Account"=Account
dlgSgPreferences.mni"Applies To"=Applies To
dlgSgPreferences.mni"Arguments"=Arguments
dlgSgPreferences.mni"Command + Arguments"=Command + Arguments
dlgSgPreferences.mni"Command"=Command
dlgSgPreferences.mni"Copy Key"=复制键
dlgSgPreferences.mni"Copy Selection in Column"=Copy Selection in Column
dlgSgPreferences.mni"Default"=Default
dlgSgPreferences.mni"Details"=Details
dlgSgPreferences.mni"Dictionary File"=Dictionary File
dlgSgPreferences.mni"Edit"=编辑
dlgSgPreferences.mni"File Pattern"=File Pattern
dlgSgPreferences.mni"Name"=Name
dlgSgPreferences.mni"Repository"=Repository
dlgSgPreferences.mni"Reset to Default"=重置为默认值
dlgSgPreferences.mni"Reset"=重置
dlgSgPreferences.mni"Select"=选择
dlgSgPreferences.mni"Shortcut"=Shortcut
dlgSgPreferences.mni"Swap"=交换
dlgSgPreferences.rbt"Advanced \(merge, rebase, ignore, stashes, tags, history modifications\)"=\
 高级 \(合并、变基、忽略、隐藏、标签、历史记录修改\)
dlgSgPreferences.rbt"Auto-detect the system proxy"=自动检测系统代理
dlgSgPreferences.rbt"Automatically download and install updates"=自动下载并安装更新
dlgSgPreferences.rbt"Basic \(for simple workflows\)"=基础 \(用于简单工作流\)
dlgSgPreferences.rbt"Check and report new updates"=检查更新并提醒
dlgSgPreferences.rbt"Dark"=深色
dlgSgPreferences.rbt"Do not check for new updates"=\
 不检查更新
dlgSgPreferences.rbt"Don't use a proxy"=不使用代理
dlgSgPreferences.rbt"Exact case \('Foo' will match 'Foo', but not 'foo'\)"=\
 精确匹配 \(“Foo” 会匹配 “Foo”, 但不会匹配 “foo”\)
dlgSgPreferences.rbt"Ignore case \('Foo' will match 'Foo' and 'foo'\)"=\
 忽略大小写 \(“Foo” 会匹配 “Foo” 和 “foo”\)
dlgSgPreferences.rbt"Light"=轻量
dlgSgPreferences.rbt"Log Graph"=日志图
dlgSgPreferences.rbt"Log graph \(commit oriented\)"=日志图 \(面向提交\)
dlgSgPreferences.rbt"Prefer light-weight updates stored in home directory"=\
 首选存储在主目录中的轻量级更新
dlgSgPreferences.rbt"Show changes or open"=Show changes or open
dlgSgPreferences.rbt"Smart upper case \('FoB' will match 'FooBar', but neither 'foobar' nor 'Fob'\)"=\
 智能大写 \(“FoB” 将匹配 “FooBar”，但既不 “foobar” 也不 “Fob”\)
dlgSgPreferences.rbt"Stage or unstage"=Stage or unstage
dlgSgPreferences.rbt"Standard \(workflow oriented\)"=标准 \(面向工作流\)
dlgSgPreferences.rbt"Update SmartGit application in-place \(may require administrator permissions\)"=\
 就地更新 SmartGit 应用程序 \(可能需要管理员权限\)
dlgSgPreferences.rbt"Use SmartGit as SSH client"=使用 Smart Git 作为 SSH 客户端
dlgSgPreferences.rbt"Use following proxy"=使用以下代理
dlgSgPreferences.rbt"Use system SSH client"=使用系统 SSH 客户端
dlgSgPreferences.rbt"Working Tree"=工作区
dlgSgPreferences.rbt"Working tree \(file oriented\)"=工作区 \(面向文档\)
dlgSgPreferences.tab"Behavior"=行为
dlgSgPreferences.tab"Colors"=颜色
dlgSgPreferences.tab"Encoding"=编码
dlgSgPreferences.tab"Font"=字体
dlgSgPreferences.tab"Languages"=语言
dlgSgPreferences.tab"Pull"=拉取
dlgSgPreferences.tab"Push"=推送
dlgSgPreferences.tab"Signing"=签名
dlgSgPreferences.tab"User"=用户
dlgSgPreferences.tle=偏好设置
dlgSgProcessKiller.btn"Kill Process"=Kill Process
dlgSgProcessKiller.btn"Wait"=等待
dlgSgProcessKiller.lbl"If you think the process is hanging, click the 'Kill Process' button, otherwise 'Wait'."=\
 If you think the process is hanging, click the 'Kill Process' button, otherwise 'Wait'.
dlgSgProcessKiller.tle=进程无响应
dlgSgProviderPullRequestCreateNoTargetRepositories.fur=该仓库不是 GitHub 复刻仓库，也没有复刻了此仓库的其它远程仓库。
dlgSgProviderPullRequestCreateNoTargetRepositories.hdl=找不到目标仓库。
dlgSgProviderPullRequestCreateNoTargetRepositories.tle=创建拉取请求
dlgSgProviderPullRequestDropConfirmMr.btn"Drop"=终止
dlgSgProviderPullRequestDropConfirmMr.fur=拉取请求本身不会在服务器上删除。
dlgSgProviderPullRequestDropConfirmMr.hdl%1=是否确实要删除请求 $1 的本地提交？
dlgSgProviderPullRequestDropConfirmMr.tle=终止拉取请求
dlgSgProviderPullRequestDropConfirmPr.btn"Drop"=终止
dlgSgProviderPullRequestDropConfirmPr.fur=拉取请求本身不会在服务器上删除。
dlgSgProviderPullRequestDropConfirmPr.hdl%1=是否确实要删除请求 $1 的本地提交？
dlgSgProviderPullRequestDropConfirmPr.tle=终止拉取请求
dlgSgProviderPullRequestRetractMr.btn"Retract"=撤消
dlgSgProviderPullRequestRetractMr.edt"Comment"=注释
dlgSgProviderPullRequestRetractMr.hdl=撤消合并请求
dlgSgProviderPullRequestRetractMr.inf=输入将使用已关闭的合并请求记录的注释。
dlgSgProviderPullRequestRetractMr.tle=撤消合并请求
dlgSgProviderPullRequestRetractPr.btn"Retract"=撤消
dlgSgProviderPullRequestRetractPr.edt"Comment"=注释
dlgSgProviderPullRequestRetractPr.hdl=撤消合并请求
dlgSgProviderPullRequestRetractPr.inf=输入将使用已关闭的合并请求记录的注释。
dlgSgProviderPullRequestRetractPr.tle=撤消合并请求
dlgSgPull.btn"Fetch Only"=获取
dlgSgPull.btn"Pull"=拉取
dlgSgPull.chk"Fetch from all remotes"=从全部远端获取更新
dlgSgPull.chk"More Options"=更多选项
dlgSgPull.chk"Remember as default for repository"=记住作为仓库的默认值
dlgSgPull.chk"Update existing and fetch new tags"=\
 更新现有标签并获取新标签
dlgSgPull.edt"Fetch From"=获取
dlgSgPull.hdl=从远程仓库中拉取提交
dlgSgPull.inf"In contrast to Fetch Only, Pull will also incorporate the fetched changes \(expand the options below to configure\)."=\
 与 “仅获取” 相比,拉取还将包含获取的更改 \(展开下面的选项进行配置\)。
dlgSgPull.inf"Select the remote repository to pull. In contrast to Fetch Only, Pull will also incorporate the fetched changes \(expand the options below to configure\)."=\
 选择要获取的远程仓库。与 “仅获取” 相比,拉取还将包含获取的更改 \(展开下面的选项进行配置\)。
dlgSgPull.tle=拉取
dlgSgPullConfiguration.btn"Configure"=配置
dlgSgPullConfiguration.chk"Remember as default for other repositories"=\
 记住作为其他仓库的默认选项
dlgSgPullConfiguration.hdl=配置如何拉取
dlgSgPullConfiguration.inf=指定是否在当前仓库的拉取上进行合并或变基。
dlgSgPullConfiguration.lbl"Merging produces additional 'merge'-commits and is not recommended. It might however be a convention of your repository \(ask the maintainer to find out\)."=\
 合并会产生额外的 “合并” 提交，一般不建议使用. 然而，它可能是您的仓库的惯例 \(要求维护者找出\)。
dlgSgPullConfiguration.lbl"Rebasing gives a clean linear history and is recommended in general."=\
 变基提供了清晰的线性历史记录，一般建议使用。
dlgSgPullConfiguration.rbt"Merge"=合并
dlgSgPullConfiguration.rbt"Rebase"=变基
dlgSgPullConfiguration.tle=配置拉取
dlgSgPullMergeInsteadOfRebase.btn"Merge"=合并
dlgSgPullMergeInsteadOfRebase.btn"Rebase"=变基
dlgSgPullMergeInsteadOfRebase.fur%1=在变基的变化中有合并提交 $1。 变基合并提交很容易造成麻烦。
dlgSgPullMergeInsteadOfRebase.hdl=您想合并本地更改而不是变基吗？
dlgSgPullMergeInsteadOfRebase.tle=拉取
dlgSgPullNoRemoteRepository.btn"Add Remote"=创建远程
dlgSgPullNoRemoteRepository.fur=您首先需要创建一个远程仓库来拉取。
dlgSgPullNoRemoteRepository.hdl=没有找到远程仓库。
dlgSgPullNoRemoteRepository.tle=拉取
dlgSgPullOrJustFetch.btn"Fetch"=获取
dlgSgPullOrJustFetch.btn"Pull"=拉取
dlgSgPullOrJustFetch.chk"Fetch from all remotes"=从所有远程获取
dlgSgPullOrJustFetch.chk"Update existing and fetch new tags"=\
 更新现有标签并获取新标签
dlgSgPullOrJustFetch.fur=您可以在仓库设置中更改拉取行为。
dlgSgPullOrJustFetch.hdl%1=你想拉取或只是获取 $1 的仓库？
dlgSgPullOrJustFetch.tle=拉取
dlgSgPushConfirmSingleBranch.btn"Push"=推送
dlgSgPushConfirmSingleBranch.chk=不再显示
dlgSgPushConfirmSingleBranch.fur%1=分支将被推至 “$1” 。
dlgSgPushConfirmSingleBranch.hdl%1=你想要推送分支 “$1” 吗？
dlgSgPushConfirmSingleBranch.tle=推送
dlgSgPushForced.btn"Force Push"=强制推送
dlgSgPushForced.fur=推送到远程分支不是快进的，因此必须强制推送。远程分支中的提交将丢失。
dlgSgPushForced.hdl=你想强制推送 \(替换\) 远程分支吗？
dlgSgPushForced.tle=推送
dlgSgPushForcedSvn.btn"Force Push"=强制推送
dlgSgPushForcedSvn.fur=您即将更换远程分支。该分支的修订可能不再是 \(容易\) 可访问的。
dlgSgPushForcedSvn.hdl=是否要强制推送 \(替换\) 远程分支吗？
dlgSgPushForcedSvn.tle=推送
dlgSgPushOverwriteRemoteBranchConfirm.btn"Push"=推送
dlgSgPushOverwriteRemoteBranchConfirm.chk=覆盖远程更改
dlgSgPushOverwriteRemoteBranchConfirm.fur=您即将更换远程分支，其中包含您根本没有看到的提交。也许你想在之前合并/改造远程变更？
dlgSgPushOverwriteRemoteBranchConfirm.hdl=你真的想要覆盖远程分支吗？
dlgSgPushOverwriteRemoteBranchConfirm.tle=推送
dlgSgPushToNoTagsOrLocalBranches.fur=您只能推送标签或本地分支。
dlgSgPushToNoTagsOrLocalBranches.hdl=没有标签或本地分支推送。
dlgSgPushToNoTagsOrLocalBranches.tle=推送到
dlgSgPushToRef.btn"Push"=推送
dlgSgPushToRef.chk"Force pushing \(even if it's not fast-forward\)"=\
 强制推送 \(即使非快进方式\)
dlgSgPushToRef.edt"Push To"=推送到
dlgSgPushToRef.edt"Target Repository"=目标仓库
dlgSgPushToRef.err"Enter the remote location to which the commits of the current branch should be pushed to."=\
 输入当前分支提交应推送到的远程位置。
dlgSgPushToRef.err"Please specify a valid Git ref."=\
 请指定有效的 Git 引用。
dlgSgPushToRef.hdl"Push '$1' to a remote repository"=\
 将 “$1” 推送到远程仓库
dlgSgPushToRef.hdl"Push '$1' to remote '$2'"=将 “$1” 推送到远程 “$2”
dlgSgPushToRef.inf=选择目标仓库，在其中推送参考。
dlgSgPushToRef.rbt"Custom Ref:"=自定义参考：
dlgSgPushToRef.rbt"Tracked or matching branch"=跟踪或匹配分支
dlgSgPushToRef.tle=推送到
dlgSgPushToRemote.btn"Push"=推送
dlgSgPushToRemote.chk"Force pushing \(even if it's not fast-forward\)"=\
 强制推送 \(即使非快进方式\)
dlgSgPushToRemote.chk"Remove remote branches which don't have a local counterpart"=\
 删除没有本地对应的远程分支
dlgSgPushToRemote.edt"Target Repository"=目标仓库
dlgSgPushToRemote.hdl%1=将 '$1' 分支推送到另一个远程
dlgSgPushToRemote.inf%1='$1' 的所有分支（在本地由相应的远程分支代表）将被推送到目标仓库.
dlgSgPushToRemote.tle=推送到
dlgSgPushToRemoteRemoveTargetBranches.btn"Remove"=删除
dlgSgPushToRemoteRemoveTargetBranches.fur=删除之后会丢失的目标远程中的分支和它们的提交.
dlgSgPushToRemoteRemoveTargetBranches.hdl=确定要删除远程分支么?
dlgSgPushToRemoteRemoveTargetBranches.tle=推送到
dlgSgPushToRemoteResetTargetBranches.btn"Force Push"=强制推送
dlgSgPushToRemoteResetTargetBranches.chk=不再显示
dlgSgPushToRemoteResetTargetBranches.fur=强制推送将覆盖目标远程中的分支及其提交，这些分支及其提交随后将丢失。
dlgSgPushToRemoteResetTargetBranches.hdl=是否确实要重置目标远程分支？
dlgSgPushToRemoteResetTargetBranches.tle=推送到
dlgSgPushTrackingConfigureSingle.btn"Configure"=配置
dlgSgPushTrackingConfigureSingle.btn"Skip"=跳过
dlgSgPushTrackingConfigureSingle.fur=对于当前分支跟踪 \(其对应的远程分支\) 尚未配置。配置跟踪将使本地分支与远程分支保持同步。
dlgSgPushTrackingConfigureSingle.hdl%1=是否要为 “$1” 分支配置跟踪？
dlgSgPushTrackingConfigureSingle.tle=推送
dlgSgRebase.btn"Branches"=分支
dlgSgRebase.btn"Rebase HEAD to"=将 HEAD 变基到
dlgSgRebase.hdl=将 HEAD 变基到
dlgSgRebase.inf=选择应变基 HEAD 提交的提交。
dlgSgRebase.tle=变基
dlgSgRebaseConfirmUnreachable.btn"Rebase"=变基
dlgSgRebaseConfirmUnreachable.fur=You only might be able to access this commit using the 'Recyclable Commits' option of the Branches view.
dlgSgRebaseConfirmUnreachable.hdl%1=The Commit $1 would become unreachable by refs.
dlgSgRebaseConfirmUnreachable.tle=Rebase
dlgSgRebaseContinueAfterSplittingCommit.btn"Continue"=继续
dlgSgRebaseContinueAfterSplittingCommit.fur%1=提交 $1 的拆分仍在进行中，并且已应用此提交的所有更改。
dlgSgRebaseContinueAfterSplittingCommit.hdl=拆分提交后是否继续？
dlgSgRebaseContinueAfterSplittingCommit.tle=变基
dlgSgRebaseContinueConfirm.btn"Continue Rebase"=继续变基
dlgSgRebaseContinueConfirm.fur=在解决了所有冲突后继续执行变基操作。
dlgSgRebaseContinueConfirm.hdl=您想继续变基吗？
dlgSgRebaseContinueConfirm.tle=变基
dlgSgRebaseContinueNothingToCommitContinue.btn"Continue Rebase"=继续变基
dlgSgRebaseContinueNothingToCommitContinue.fur=仓库处于变基状态，但没有提交任何内容，因此您可以继续使用变基。
dlgSgRebaseContinueNothingToCommitContinue.hdl=您想继续变基吗？
dlgSgRebaseContinueNothingToCommitContinue.tle=变基
dlgSgRebaseContinueNothingToCommitSkip.btn"Skip Commit"=跳过提交
dlgSgRebaseContinueNothingToCommitSkip.fur=仓库处于变基状态，但没有提交任何内容，因此您可以跳过此重新提交的提交。
dlgSgRebaseContinueNothingToCommitSkip.hdl=您想跳过这个变基提交吗？
dlgSgRebaseContinueNothingToCommitSkip.tle=变基
dlgSgRebaseContinuePreserveUntrackedFiles.btn"Commit"=提交
dlgSgRebaseContinuePreserveUntrackedFiles.btn"Preserve"=保留
dlgSgRebaseContinuePreserveUntrackedFiles.fur=您的工作区包含未跟踪的文件。 您可以选择在工作区中保留它们，也可以将它们包含在已重新提交的提交中。
dlgSgRebaseContinuePreserveUntrackedFiles.hdl=是否要保留工作区中未跟踪的文件？
dlgSgRebaseContinuePreserveUntrackedFiles.tle=变基
dlgSgRebaseContinueWithoutApplyingAllChanges.btn"Continue Anyway"=总是继续
dlgSgRebaseContinueWithoutApplyingAllChanges.btn"Put Changes into Index"=将更改放入索引
dlgSgRebaseContinueWithoutApplyingAllChanges.fur%1=提交 $1 的拆分仍在进行中，但并未应用此提交的所有更改。\n\n如果这是故意的，您可以继续。否则，您应单击 “将更改置于索引中” 并查看更改。
dlgSgRebaseContinueWithoutApplyingAllChanges.hdl=是否继续拆分提交而不应用所有更改？
dlgSgRebaseContinueWithoutApplyingAllChanges.tle=变基
dlgSgRebaseHeadToCommitConfirmBc.fur%1=这将把工作区分支 “$1” \(HEAD\) 的所有提交应用到所选提交。
dlgSgRebaseHeadToCommitConfirmBc.hdl%1=是否要将 “$1” 变基到所选提交？
dlgSgRebaseHeadToCommitConfirmBr.fur%2=这将应用从工作区分支 “$1” \(HEAD\) 到 “$2” 的所有提交。
dlgSgRebaseHeadToCommitConfirmBr.hdl%2=是否要将 “$1” 变基为 “$2”？
dlgSgRebaseHeadToCommitConfirm(Br|Bc|Hr|Hc).btn"Rebase HEAD to"=将 HEAD 变基到
dlgSgRebaseHeadToCommitConfirm(Br|Bc|Hr|Hc).btn"Rebase Interactively"=以交互方式变基
dlgSgRebaseHeadToCommitConfirm(Br|Bc|Hr|Hc).tle=将 HEAD 变基到选定的提交
dlgSgRebaseInteractive.btn"Auto-Squash"=自动压缩
dlgSgRebaseInteractive.btn"Edit Message"=编辑消息
dlgSgRebaseInteractive.btn"Edit"=编辑
dlgSgRebaseInteractive.btn"Move Down"=下移
dlgSgRebaseInteractive.btn"Move Up"=上移
dlgSgRebaseInteractive.btn"Rebase"=变基
dlgSgRebaseInteractive.btn"Remove"=移除
dlgSgRebaseInteractive.btn"Squash"=压缩
dlgSgRebaseInteractive.col"IDs"=IDs
dlgSgRebaseInteractive.col"Message"=消息
dlgSgRebaseInteractive.hdl=重写历史
dlgSgRebaseInteractive.inf=您可以根据需要重新排序或取消提交。
dlgSgRebaseInteractive.mni"Neighboring Commits"=相邻提交
dlgSgRebaseInteractive.mni"To Bottom Commit"=转到底部提交
dlgSgRebaseInteractive.mni"To Top Commit"=转到顶部提交
dlgSgRebaseInteractive.tle=交互式变基
dlgSgRebaseInteractiveInitialCommitNotSupported.fur=You need to select the first commit in the current branch's history that should be modified. All commits between this commit and HEAD must have exactly one parent.
dlgSgRebaseInteractiveInitialCommitNotSupported.hdl=Changing the initial commit is not supported by the interactive rebase.
dlgSgRebaseInteractiveInitialCommitNotSupported.tle=Rebase Interactive
dlgSgRebaseInteractiveMessage.edt"Commit Message"=提交消息
dlgSgRebaseInteractiveMessage.hdl=编辑提交消息
dlgSgRebaseInteractiveMessage.inf=提供新的提交消息.
dlgSgRebaseInteractiveMessage.tle=编辑消息
dlgSgRebaseInteractiveRemoveCommit.btn"Remove"=删除
dlgSgRebaseInteractiveRemoveCommit.fur=再次恢复提交可能变得困难或不可能。
dlgSgRebaseInteractiveRemoveCommit.hdl%1=您确定要删除所选的提交 $1 吗？
dlgSgRebaseInteractiveRemoveCommit.tle=删除提交
dlgSgRebaseTagCommit.btn"Add Tag"=创建标签
dlgSgRebaseTagCommit.btn"Skip Tag"=跳过标签
dlgSgRebaseTagCommit.fur=在变基之后，剩余的提交将不再可用。
dlgSgRebaseTagCommit.hdl%1=应该标记提交 $1 吗？
dlgSgRebaseTagCommit.tle=变基
dlgSgRebasingAbortConfirm.btn"Abort Rebase"=中止变基
dlgSgRebasingAbortConfirm.fur=您的工作区处于变基状态。你可以放弃变基; 如果您只想跳过当前的补丁，请使用 Branch \| Rebase \| Rebase HEAD 改为。\n\n中止将清除任何本地修改 \(通过调用 “git reset --hard”\)！
dlgSgRebasingAbortConfirm.hdl=你想要中止变基吗?
dlgSgRebasingAbortConfirm.tle=变基
dlgSgRecursiveStage.btn"Stage"=暂存
dlgSgRecursiveStage.chk"Don't show again"=不再显示
dlgSgRecursiveStage.hdl=保存索引中的工作区更改以供以后提交
dlgSgRecursiveStage.inf=将选中的文件暂存到索引
dlgSgRecursiveStage.mni"Deselect All"=取消全选
dlgSgRecursiveStage.mni"Select All"=全选
dlgSgRecursiveStage.mni"Toggle"=切换
dlgSgRecursiveStage.tle=暂存
dlgSgRecursiveUnstage.btn"Unstage"=取消暂存
dlgSgRecursiveUnstage.chk"Don't show again"=Don't show again
dlgSgRecursiveUnstage.hdl=将暂存更改从索引还原到工作区
dlgSgRecursiveUnstage.inf=从索引中选择要取消暂存的文件。
dlgSgRecursiveUnstage.tle=取消暂存
dlgSgRecursive(Stage|Unstage).col"Directory"=目录
dlgSgRecursive(Stage|Unstage).col"Name"=名称
dlgSgRemoteDeleteConfirm.btn"Delete"=删除
dlgSgRemoteDeleteConfirm.fur=这只会删除到远程仓库的链接。
dlgSgRemoteDeleteConfirm.hdl%1=是否要删除远程仓库 “$1”？
dlgSgRemoteDeleteConfirm.tle=删除远程仓库
dlgSgRemoteFetchMore.btn"Fetch"=获取
dlgSgRemoteFetchMore.col"Branch"=分支
dlgSgRemoteFetchMore.hdl=获取远程分支
dlgSgRemoteFetchMore.inf=选择要从远程仓库获取的分支。
dlgSgRemoteFetchMore.tle=获取更多
dlgSgRemoteFetchMoreNoMoreBranches.fur=远程仓库中存在的所有分支也都已在本地存在。
dlgSgRemoteFetchMoreNoMoreBranches.hdl=没有更多的远程分支来获取。
dlgSgRemoteFetchMoreNoMoreBranches.tle=获取更多
dlgSgRemoteProperties.chk"Perform background Poll or Fetch"=执行后台轮询或获取
dlgSgRemoteProperties.edt"URL or Path"=URL 或路径
dlgSgRemoteProperties.hdl=配置远程属性
dlgSgRemoteProperties.inf=更改远程服务器的 URL 和其他属性。
dlgSgRemoteProperties.tle=远程属性
dlgSgRemoteSelect.edt"Remote"=远程
dlgSgRemoteSelect.hdl=初始化远程审阅数据库
dlgSgRemoteSelect.inf=选择要初始化审阅数据库的远程仓库。
dlgSgRemoteSelect.tle=初始化远程
dlgSgRemoteSetDepth.btn"Set Depth"=设置深度
dlgSgRemoteSetDepth.edt"Depth"=深度
dlgSgRemoteSetDepth.hdl=设置仓库深度
dlgSgRemoteSetDepth.inf=使用大数 \(例如 100000\) 来设置无限深度。
dlgSgRemoteSetDepth.tle=设置深度
dlgSgRemotesAdd.btn"Add"=添加
dlgSgRemotesAdd.chk"Verify repository connection"=验证仓库连接
dlgSgRemotesAdd.edt"Name"=名称
dlgSgRemotesAdd.edt"URL or Path"=URL 或路径
dlgSgRemotesAdd.hdl=添加远程仓库
dlgSgRemotesAdd.inf=输入远程仓库的 URL 和短名称。
dlgSgRemotesAdd.mni"Add Hosting Provider"=添加主机提供商
dlgSgRemotesAdd.mni"Select Local Repository"=选择本地仓库
dlgSgRemotesAdd.tle=添加远程仓库
dlgSgRemotesNoRemoteDetected.fur%1=To perform the operation the repository configuration for $1 must contain one uniquely determined remote.
dlgSgRemotesNoRemoteDetected.hdl=No remote detected.
dlgSgRemotesNoRemoteDetected.tle=Push Up To
dlgSgRemove.btn"Remove"=移除
dlgSgRemove.chk"Delete local files"=删除本地文件
dlgSgRemove.col"Directory"=目录
dlgSgRemove.col"Name"=名称
dlgSgRemove.hdl=从仓库中删除文件
dlgSgRemove.inf=选择要从仓库或工作区中删除的文件 \(停止\跟踪\)。
dlgSgRemove.tle=移除
dlgSgRenameBranch.btn"Rename"=重命名
dlgSgRenameBranch.edt"Name"=名称
dlgSgRenameBranch.hdl=重命名分支
dlgSgRenameBranch.inf%1=输入分支 “$1” 的新名称。
dlgSgRenameBranch.tle=重命名
dlgSgRenameFile.btn"Rename"=重命名
dlgSgRenameFile.edt"Path"=路径
dlgSgRenameFile.hdl=重命名文件
dlgSgRenameFile.inf=输入文件的新路径和名称。
dlgSgRenameFile.tle=重命名
dlgSgRenameRemote.btn"Rename"=重命名
dlgSgRenameRemote.edt"Name"=名称
dlgSgRenameRemote.hdl=远程仓库重命名
dlgSgRenameRemote.inf=为选择的远程提供新的名称
dlgSgRenameRemote.tle=远程仓库重命名
dlgSgRenameRepository.btn"Rename"=重命名
dlgSgRenameRepository.edt"Name"=名称
dlgSgRenameRepository.hdl=重命名仓库
dlgSgRenameRepository.inf=为仓库提供新的名称。仓库的目录不会被重命名。
dlgSgRenameRepository.tle=重命名
dlgSgRepositoriesSearch.btn"Start Search"=开始搜索
dlgSgRepositoriesSearch.col"Path"=路径
dlgSgRepositoriesSearch.edt"Found repository \(selected ones will be remembered\)"=\
 找到仓库 \(将记住选定的仓库\)
dlgSgRepositoriesSearch.edt"Search In"=搜索中
dlgSgRepositoriesSearch.hdl=搜索现有本地仓库
dlgSgRepositoriesSearch.inf=选择应开始搜索的根目录，然后单击 “开始搜索” 。
dlgSgRepositoriesSearch.mni"Deselect All"=取消全选
dlgSgRepositoriesSearch.mni"Path"=路径
dlgSgRepositoriesSearch.mni"Select All"=全选
dlgSgRepositoriesSearch.mni"Toggle"=切换
dlgSgRepositoriesSearch.tle=搜索仓库
dlgSgRepositoryAddGroup.btn"Add"=创建
dlgSgRepositoryAddGroup.edt"Group Name"=分组名字
dlgSgRepositoryAddGroup.hdl=输入分组名称
dlgSgRepositoryAddGroup.inf=创建组后，您可以在其中移动仓库。
dlgSgRepositoryAddGroup.tle=创建分组
dlgSgRepositoryClose.btn"Force Close"=强制关闭
dlgSgRepositoryClose.fur=请注意，当前运行的 Git 进程可能不会被中断。
dlgSgRepositoryClose.hdl=你真的想现在关闭吗？
dlgSgRepositoryClose.tle=关闭
dlgSgRepositoryFrameCloseWithoutPush.btn"Close Now"=现在关闭
dlgSgRepositoryFrameCloseWithoutPush.chk=不再显示
dlgSgRepositoryFrameCloseWithoutPush.fur=你有可推送的提交。也许你想在关闭这个窗口之前推它们。
dlgSgRepositoryFrameCloseWithoutPush.hdl=你确定在没有推送提交的情况下关闭吗？
dlgSgRepositoryFrameCloseWithoutPush.tle=关闭
dlgSgRepositoryOpen.btn"Remove"=删除
dlgSgRepositoryOpen.fur=如果重新定位，请将其删除并添加其新位置。
dlgSgRepositoryOpen.hdl%1=你想删除丢失的仓库 '$1' 吗？
dlgSgRepositoryOpen.tle=仓库打开
dlgSgRepositoryRemoveMultiGroup.fur=已删除组中的仓库将从该组中移出。
dlgSgRepositoryRemoveMultiGroup.hdl%1=您确定要删除 $1 组吗？
dlgSgRepositoryRemoveMultiRepo.fur=这会将仓库保留在磁盘上，但只是让 SmartGit 忘记它们。
dlgSgRepositoryRemoveMultiRepo.hdl%1=您确定要删除 $1 仓库吗？
dlgSgRepositoryRemoveMultiRepoMultiGroup.fur=这会将仓库保留在磁盘上，但只是让 SmartGit 忘记它们。已删除组中的仓库将移出组。
dlgSgRepositoryRemoveMultiRepoMultiGroup.hdl%2=您确定要删除 $1 仓库和 $2 组吗？
dlgSgRepositoryRemoveMultiRepoSingleGroup.fur=这会将仓库保留在磁盘上，但只是让 SmartGit 忘记它们。已删除组中的仓库将移出组。
dlgSgRepositoryRemoveMultiRepoSingleGroup.hdl%2=您确定要删除 $1 仓库和组 “$2” 吗？
dlgSgRepositoryRemoveSingleGroup.fur=已删除组中的仓库将移出组。
dlgSgRepositoryRemoveSingleGroup.hdl%1=您确定要删除 “$1” 组吗？
dlgSgRepositoryRemoveSingleRepo.fur=这会将仓库保留在磁盘上，但只是让 SmartGit 忘记它们。
dlgSgRepositoryRemoveSingleRepo.hdl%1=您确定要删除 $1 的仓库吗？
dlgSgRepositoryRemoveSingleRepoMultiGroup.fur=这会将仓库保留在磁盘上，但只是让 SmartGit 忘记它们。已删除组中的仓库将移出组。
dlgSgRepositoryRemoveSingleRepoMultiGroup.hdl%2=您确定要删除仓库 “$1” 和 $2 组吗？
dlgSgRepositoryRemoveSingleRepoSingleGroup.fur=这会将仓库保留在磁盘上，但只是让 SmartGit 忘记它们。已删除组中的仓库将移出组。
dlgSgRepositoryRemoveSingleRepoSingleGroup.hdl%2=您确定要删除仓库 “$1” 和组 “$2” 吗？
dlgSgRepositorySettings.chk"Always fetch new commits, tags and branches from submodule"=\
 始终从子模块中获取新的提交，标签和分支
dlgSgRepositorySettings.chk"Initialize new submodules"=初始化新的子模块
dlgSgRepositorySettings.chk"Prune obsolete remote tracked branches"=删除过时的远程跟踪分支
dlgSgRepositorySettings.chk"Remember as default"=记住默认
dlgSgRepositorySettings.chk"Sign all commits"=签名所有提交
dlgSgRepositorySettings.chk"Update registered submodules"=更新已注册的子模块
dlgSgRepositorySettings.edt"Email"=电子邮箱
dlgSgRepositorySettings.edt"GPG Program"=GPG 程序
dlgSgRepositorySettings.edt"Name"=用户名
dlgSgRepositorySettings.edt"Signing Key"=签名密钥
dlgSgRepositorySettings.edt"Submodule handling\*"=子模块处理\*
dlgSgRepositorySettings.edt"Text File Encoding"=文本编码
dlgSgRepositorySettings.err"Please enter a valid, comma-separated list of regular expressions."=\
 请输入有效的、以逗号分隔的正则表达式列表。
dlgSgRepositorySettings.hdl=编辑有效的仓库设置
dlgSgRepositorySettings.inf=在这里，您可以查看和编辑用户配置文件和仓库的有效 Git 设置。要将选项保存为用户设置，请选择 “记住默认” 。
dlgSgRepositorySettings.lbl"\* if repository commit references non-pushed submodule commit"=\
 \* if repository commit references non-pushed submodule commit
dlgSgRepositorySettings.tab"Encoding"=编码
dlgSgRepositorySettings.tab"Pull"=拉取
dlgSgRepositorySettings.tab"Push"=推送
dlgSgRepositorySettings.tab"Signing"=签名
dlgSgRepositorySettings.tab"User & Encoding"=用户和编码
dlgSgRepositorySettings.tab"User"=用户
dlgSgRepositorySettings.tle=仓库设置
dlgSgRepositorySettings.wrn"The entered email address does not look like a valid one."=\
 The entered email address does not look like a valid one.
dlgSgRepositorySettings.wrn"The name should not contain an email address."=\
 该名称不应包含电子邮件地址。
dlgSgRepositorySettings.wrn"Without setting your name, you won't be able to commit."=\
 Without setting your name, you won't be able to commit.
dlgSgResetAdv.btn"Reset"=重置
dlgSgResetAdv.chk"Thoroughly fix line endings according to .gitattributes"=\
 根据 .gitattributes 彻底修复行尾
dlgSgResetAdv.chk"Thoroughly fix line-endings according to .gitattributes"=\
 根据 .gitattributes 彻底修复行尾
dlgSgResetAdv.hdl%1=重置提交 $1
dlgSgResetAdv.inf=将当前分支 HEAD 重置为所选提交，并可选择更新索引和工作区。
dlgSgResetAdv.lbl"Current staged and local changes will be lost!"=\
 Current staged and local changes will be lost!
dlgSgResetAdv.lbl"Current staged changes will be lost!"=\
 Current staged changes will be lost!
dlgSgResetAdv.lbl"Similar to 'hard'. If a file to be replaced has working tree changes, the reset is aborted."=\
 Similar to 'hard'. If a file to be replaced has working tree changes, the reset is aborted.
dlgSgResetAdv.lbl"Similar to 'hard'. If a file to be replaced has working tree or Index changes, the reset is aborted."=\
 Similar to 'hard'. If a file to be replaced has working tree or Index changes, the reset is aborted.
dlgSgResetAdv.lbl"The Index will show all changes between the previous HEAD and the selected commit."=\
 The Index will show all changes between the previous HEAD and the selected commit.
dlgSgResetAdv.rbt"Don't touch the Index nor the working tree - 'soft'"=\
 不要变更索引或工作区 - “--soft”
dlgSgResetAdv.rbt"Reset the Index and the working tree - 'hard'"=\
 重置索引和工作区 - “--hard”
dlgSgResetAdv.rbt"Reset the Index and the working tree, skipping modified files - 'keep'"=\
 重置索引和工作区，跳过修改过的文件 - “--keep”
dlgSgResetAdv.rbt"Reset the Index and the working tree, skipping working tree modified files - 'merge'"=\
 重置索引和工作区，跳过工作区修改的文件 - “--merge”
dlgSgResetAdv.rbt"Reset the Index but not the working tree - 'mixed'"=\
 重置索引，但不重置工作区 - “--mixed”
dlgSgResetAdv.tle=重置
dlgSgResetConfirm.btn"Reset"=重置
dlgSgResetConfirm.fur=当前暂存和本地更改将丢失！
dlgSgResetConfirm.hdl%1=您确定要将 HEAD 重置为提交 $1 吗？
dlgSgResetConfirm.tle=重置
dlgSgResolve.btn"Resolve"=解决
dlgSgResolve.chk"Stage file \(reset conflict state\)"=暂存文件 \(重置冲突状态\)
dlgSgResolve.edt"Content"=内容
dlgSgResolve.hdl=解决冲突
dlgSgResolve.inf=选择要用于已解决的文件的内容。
dlgSgResolve.rbt"Leave as is"=保持不变
dlgSgResolve.rbt"Open Conflict Solver"=打开冲突解决器
dlgSgResolve.rbt"Set to $1 \(\"ours\", $2\)"=设置为 $1 \(“我们的”，$2 \)
dlgSgResolve.rbt"Set to $1 \(\"theirs\", $2\)"=设置为 $1 \(“他们的”，$2 \)
dlgSgResolve.rbt"Set to rebase target \(\"theirs\", $1\)"=\
 设置为变基目标 \(“他们的”，$1\)
dlgSgResolve.rbt"Set to rebased branch '$1' \(\"ours\", $2\)"=\
 设置为变基分支 “$1” \(“我们的”，$2\)
dlgSgResolve.tle=解决
dlgSgResolveManuallyModifiedSingle.btn"Overwrite"=覆盖
dlgSgResolveManuallyModifiedSingle.fur%1=$1 似乎包含手动冲突解决方案。如果继续，它们将会丢失。
dlgSgResolveManuallyModifiedSingle.hdl=您确定要覆盖手动冲突解决？
dlgSgResolveManuallyModifiedSingle.tle=解决
dlgSgResolveSubmodule.btn"Resolve"=解决
dlgSgResolveSubmodule.hdl=解决冲突
dlgSgResolveSubmodule.inf=选择要解决的子模块提交。
dlgSgResolveSubmodule.rbt"Check out and set submodule pointer to 'theirs' version"=\
 检出并将子模块指针设置为 “他们的” 版本
dlgSgResolveSubmodule.rbt"Leave submodule pointer as is"=保持子模块指针不变
dlgSgResolveSubmodule.tle=解决
dlgSgRevealCommitLocalOrTracked.btn"Reveal Local"=显示本地
dlgSgRevealCommitLocalOrTracked.btn"Reveal Tracked"=显示跟踪
dlgSgRevealCommitLocalOrTracked.chk=始终显示当地分支
dlgSgRevealCommitLocalOrTracked.fur%2=选择是否显示 “$1” 或 “$2” 。
dlgSgRevealCommitLocalOrTracked.hdl=是否要显示本地分支或跟踪分支？
dlgSgRevealCommitLocalOrTracked.tle=显示提交
dlgSgRevertAndCommitConfirmSingle.btn"Revert && Commit"=还原并提交
dlgSgRevertAndCommitConfirmSingle.btn"Revert"=还原
dlgSgRevertAndCommitConfirmSingle.fur=这将撤消所选提交引入的更改。
dlgSgRevertAndCommitConfirmSingle.hdl=是否要还原所选提交？
dlgSgRevertAndCommitConfirmSingle.tle=还原
dlgSgRevertConfigurationFile.btn"Revert"=还原
dlgSgRevertConfigurationFile.fur=只有这些文件的更改才会被还原 \(不提交\)。
dlgSgRevertConfigurationFile.hdl"Do you want to revert changes of '$1'?"=\
 您确定要还原 '$1' 的更改？
dlgSgRevertConfigurationFile.tle=还原
dlgSgRevertInProgress.fur=您必须先完成还原，然后才能继续。 要完成 “还原” 使用 “提交”，要中止使用 “丢弃”。
dlgSgRevertInProgress.hdl=目前有一个还原正在进行中。
dlgSgRevertInProgress.tle=还原
dlgSgRevertNotAllConflictsResolved.chk=不再显示
dlgSgRevertNotAllConflictsResolved.fur=您可能需要在继续之前解决冲突。
dlgSgRevertNotAllConflictsResolved.hdl=由于冲突而还原失败。
dlgSgRevertNotAllConflictsResolved.tle=还原
dlgSgReviewCommentAdd.btn"Add"=创建
dlgSgReviewCommentAdd.hdl=创建注释
dlgSgReviewCommentAdd.tle=创建注释
dlgSgReviewCommentEdit.btn"Edit"=编辑
dlgSgReviewCommentEdit.hdl=编辑注释
dlgSgReviewCommentEdit.tle=编辑注释
dlgSgReviewCommentReply.btn"Reply"=回复
dlgSgReviewCommentReply.hdl=回复所选注释
dlgSgReviewCommentReply.tle=回复注释
dlgSgReviewComment(Add|Edit|Reply).edt"Text"=文本
dlgSgReviewComment(Add|Edit|Reply).inf=输入注释的文本。
dlgSgReviewConfigureDisposeDatabase.btn"Dispose"=配置
dlgSgReviewConfigureDisposeDatabase.fur=这将禁用审阅系统，并且未推送的本地数据将丢失。
dlgSgReviewConfigureDisposeDatabase.hdl=您真的想要处理所有本地注释数据吗？
dlgSgReviewConfigureDisposeDatabase.tle=配置数据库
dlgSgReviewConfigureForGitHub.btn"Continue"=继续
dlgSgReviewConfigureForGitHub.fur=此仓库连接到 GitHub 服务器。GitHub 有自己的审查概念，比如提交审阅和拉取请求。因此，除了 GitHub 的现有功能之外，您可能不希望拥有 SmartGit 的审阅数据库。
dlgSgReviewConfigureForGitHub.hdl=您真的想为您的 GitHub 仓库配置 SmartGit 的审阅数据库吗？
dlgSgReviewConfigureForGitHub.tle=配置审阅系统
dlgSgReviewConfigureIntializeNew.btn"Initialize"=初始化
dlgSgReviewConfigureIntializeNew.fur=这将在当前仓库中创建一个新的审阅数据库，稍后可能会将其推送到其他远程位置。
dlgSgReviewConfigureIntializeNew.hdl=是否要初始化新的审阅数据库？
dlgSgReviewConfigureIntializeNew.tle=配置审阅系统
dlgSgReviewConfigureWhat.btn"Dispose Database"=配置数据库
dlgSgReviewConfigureWhat.btn"Edit Users"=编辑用户
dlgSgReviewConfigureWhat.btn"Initialize a Remote"=初始化远程
dlgSgReviewConfigureWhat.fur=用户数据库允许定义别名 \(例如 @mike\)，使得在审阅注释中更容易解决队友问题。
dlgSgReviewConfigureWhat.hdl=选择要配置的内容。
dlgSgReviewConfigureWhat.tle=配置审核数据库
dlgSgReviewPullRequestClose.edt"Comment"=注释
dlgSgReviewPullRequestClose.hdl=关闭拉取请求
dlgSgReviewPullRequestClose.inf=输入关闭拉取请求时将记录的注释。
dlgSgReviewPullRequestClose.tle=关闭拉取请求
dlgSgReviewPullRequestCreate.btn"Create"=创建
dlgSgReviewPullRequestCreate.edt"Assignees"=申请人
dlgSgReviewPullRequestCreate.edt"Message"=消息
dlgSgReviewPullRequestCreate.err"Unknown user '$1'."=未知用户 “$1”。
dlgSgReviewPullRequestCreate.hdl=创建拉取请求
dlgSgReviewPullRequestCreate.inf=拉取请求建议将一个分支集成到另一个分支中。
dlgSgReviewPullRequestCreate.lbl"The message will be displayed for the pull request node and will be the default commit message when integrating the pull request."=\
 将为拉取请求节点显示该消息，并且在集成拉取请求时将是默认提交消息。
dlgSgReviewPullRequestCreate.lbl"The pull request will be highlighted to those users which are listed as assignees."=\
 拉取请求将高亮显示给列为申请人的用户。
dlgSgReviewPullRequestCreate.tle=创建拉取请求
dlgSgReviewPullRequestState.btn"Assign"=分配
dlgSgReviewPullRequestState.edt"Assignees"=申请人
dlgSgReviewPullRequestState.edt"Comment"=注释
dlgSgReviewPullRequestState.err"Unknown user '$1'."=未知用户 “$1”。
dlgSgReviewPullRequestState.hdl=分配拉取请求
dlgSgReviewPullRequestState.inf=输入应将拉取请求分配给的用户 \(s\)。
dlgSgReviewPullRequestState.tle=分配
dlgSgReviewUserAddEdit.edt"Aliases"=别名
dlgSgReviewUserAddEdit.edt"Contact URI"=联系 URI
dlgSgReviewUserAddEdit.edt"Email"=电子邮箱
dlgSgReviewUserAddEdit.edt"Name"=用户名
dlgSgReviewUserAddEdit.err"Email address is not valid."=电子邮件地址无效。
dlgSgReviewUserAddEdit.err"Enter at least one alias."=输入至少一个别名。
dlgSgReviewUserAddEdit.hdl=编辑用户
dlgSgReviewUserAddEdit.inf=输入用户的姓名和电子邮件地址 \(用于 Git\)，一个或多个空格或逗号分隔的别名和可选的联系人详细信息。
dlgSgReviewUserAddEdit.lbl"Aliases have to be alphanumeric and can be used in comments, like '@bob please check'."=\
 别名必须是字母数字，并且可以在注释中使用，例如 “@bob 请检查”。
dlgSgReviewUserAddEdit.lbl"Contact URIs are the primary way to contact users through SmartGit, e.g. 'mailto:bob@office.com' or 'skype:bob?chat'."=\
 联系 URI 是通过 SmartGit 与用户联系的主要方式，例如 “mailto:bob@office.com” 或 “skype:bob?chat”。
dlgSgReviewUserAddEdit.tle=编辑
dlgSgReviewUsersEdit.btn"Add"=创建
dlgSgReviewUsersEdit.btn"Edit"=编辑
dlgSgReviewUsersEdit.btn"Import"=导入
dlgSgReviewUsersEdit.btn"Remove"=删除
dlgSgReviewUsersEdit.col"Aliases"=别名
dlgSgReviewUsersEdit.col"Email"=电子邮箱
dlgSgReviewUsersEdit.col"Name"=名称
dlgSgReviewUsersEdit.hdl=配置审阅数据库用户
dlgSgReviewUsersEdit.inf=用户可以在注释文本中使用别名，并且可以选择联系人详细信息。
dlgSgReviewUsersEdit.tle=配置用户
dlgSgSelectBranch.edt"Auxiliary Branch"=辅助分支
dlgSgSelectBranch.edt"Tracked Branch"=跟踪分支
dlgSgSelectBranch.hdl"Select tracked branch"=选择跟踪分支
dlgSgSelectBranch.inf"Select the branch which should be tracked by '$1'."=\
 选择应由 “$1” 跟踪的分支。
dlgSgSelectBranch.inf"Select which auxiliary branch should be shown in addition to the current branch."=\
 选择除当前分支外还应显示的辅助分支。
dlgSgSelectBranch.tle=设置跟踪分支
dlgSgSetup.btn"Configure Proxy"=设置代理
dlgSgSetup.btn"Exit"=退出
dlgSgSetup.chk"Automatically send 'crash footprints' after an internal error has occurred"=\
 发生内部错误后自动发送 “崩溃追踪”
dlgSgSetup.chk"I understand and agree to all terms and conditions of the"=\
 我理解并同意所有条款和条件
dlgSgSetup.chk"Register existing license"=注册现有许可证
dlgSgSetup.chk"Send 'crash footprints' after an internal error has occurred"=\
 发生内部错误后自动发送 “崩溃追踪”
dlgSgSetup.chk"Send usage statistics"=发送使用量统计
dlgSgSetup.chk"Use gravatar.com to show images for the users"=\
 使用 gravatar.com 为用户显示图像
dlgSgSetup.edt"Email"=电子邮箱
dlgSgSetup.edt"Git Executable"=Git 可执行文件
dlgSgSetup.edt"Hg Executable"=Hg 可执行文件
dlgSgSetup.edt"License File"=许可证文件
dlgSgSetup.edt"Repository search"=仓库搜索
dlgSgSetup.edt"User Name"=用户名
dlgSgSetup.inf"Decide what SmartGit window you prefer. You can change this option later in the preferences."=\
 决定您喜欢的 SmartGit 窗口。您可以稍后在偏好设置中更改此选项。
dlgSgSetup.inf"If you are using SSH to connect to other Git repositories, select what SSH client to use. You can change it later in the Preferences."=\
 如果您使用 SSH 连接到其他 Git 仓库，请选择要使用的 SSH 客户端。 您可以稍后在偏好设置中更改它。
dlgSgSetup.inf"Please review the following privacy options. You can change them later in the preferences."=\
 请查看以下隐私选项。您可以稍后在偏好设置中更改它们。
dlgSgSetup.inf"Please wait a few moments while searching for a Git installation."=\
 在搜索 Git 或 Hg 安装时，请稍等片刻。
dlgSgSetup.inf"SmartGit requires compatible Git installations on your system. Please specify the paths to your 'git' executable."=\
 SmartGit 要求在您的系统上安装兼容的 Git。请指定 'git' 可执行文档的路径。
dlgSgSetup.inf"User name and email will be stored as part of your commits. Here you can configure the default values which are stored in .gitconfig."=\
 用户名和电子邮件将作为提交的一部分存储。 您可以在此处配置并存储在 .gitconfig。
dlgSgSetup.inf"Welcome to SmartGit! Please confirm that you are accepting the license agreement."=\
 欢迎来到 SmartGit！请确认您正在接受许可协议。
dlgSgSetup.lbl"Please help to improve SmartGit's quality by automatically sending 'crash footprints' which do not contain any sensitive information. You can change this option later in the preferences.\n\nA 'crash footprint' contains details about your machine \(e.g. version of operating system\), SmartGit's version/build number, the JVM state and where the internal error occurred.\n\nIt contains NO POTENTIALLY SENSITIVE INFORMATION like user names, email addresses, file contents, file paths or server names."=\
 请通过自动发送不包含任何敏感信息的 “崩溃追踪” 来帮助提高 SmartGit 的质量。 您可以稍后在偏好设置中更改此选项。\n\n崩溃追踪包含有关您的计算机的详细信息 \(例如，操作系统的版本\)，SmartGit 的版本/内部版本号，JVM 状态以及发生内部错误的位置。 \n\n它不包含任何潜在的敏感信息，如用户名，电子邮件地址，文件内容，文件路径或服务器名称。
dlgSgSetup.lbl"You confirm that you will use SmartGit solely for non-commercial purposes."=\
 您确认将 SmartGit 仅用于非商业目的。
dlgSgSetup.lbl"You have purchased a SmartGit license and are eligible to use SmartGit for both commercial and non-commercial purposes."=\
 您已购买 SmartGit 许可证，并且有资格将 SmartGit 用于商业和非商业用途。
dlgSgSetup.lbl"You may try SmartGit free of charge for 30 days."=\
 您可以免费试用 SmartGit 30天。
dlgSgSetup.rbt"Commits \(Log History\)"=日志历史
dlgSgSetup.rbt"Free SmartGit evaluation for commercial use"=\
 免费的 SmartGit 评估用于商业用途
dlgSgSetup.rbt"Log Graph \(commit oriented\)"=日志图 \(面向提交\)
dlgSgSetup.rbt"Non-commercial use only \(most features, no support\)"=\
 仅限非商业用途 \(大多数功能, 无技术支持\)
dlgSgSetup.rbt"Registered user, commercial use \(all features, support\)"=\
 注册用户，商业用途 \(所有功能, 技术支持\)
dlgSgSetup.rbt"Standard \(workflow oriented\)"=标准 \(面向工作流\)
dlgSgSetup.rbt"Undecided"=待定
dlgSgSetup.rbt"Use SmartGit as SSH client"=使用 SmartGit 作为 SSH 客户端
dlgSgSetup.rbt"Use system SSH client"=使用系统 SSH 客户端
dlgSgSetup.rbt"Working tree \(file oriented\)"=工作区 \(file oriented\)
dlgSgSetup.tle=设置 SmartGit
dlgSgShowLocalChanges.btn"Compare"=比较
dlgSgShowLocalChanges.hdl%1=在索引和工作区中修改了文件 $1
dlgSgShowLocalChanges.inf=选择要比较的文件状态。
dlgSgShowLocalChanges.rbt"HEAD vs. Index"=HEAD 与索引
dlgSgShowLocalChanges.rbt"HEAD vs. Working Tree"=HEAD 与工作区
dlgSgShowLocalChanges.rbt"Index vs. Working Tree"=索引与工作区
dlgSgShowLocalChanges.tle=显示更改
dlgSgSplitOffFiles.btn"JIRA"=JIRA
dlgSgSplitOffFiles.btn"Split Off"=拆分
dlgSgSplitOffFiles.edt"Commit Message"=提交信息
dlgSgSplitOffFiles.hdl=将文件移动到第二次提交
dlgSgSplitOffFiles.inf=为第二个提交提供消息，该消息应包含所选文档中的更改。
dlgSgSplitOffFiles.tle=拆分文件
dlgSgSplitOffFilesEmptyCommit.fur=By splitting off all files, the resulting commit would become empty.
dlgSgSplitOffFilesEmptyCommit.hdl=You can't split off all files from a commit
dlgSgSplitOffFilesEmptyCommit.tle=Commit
dlgSgSshCredentials.btn"Login"=登录
dlgSgSshCredentials.chk"Store passphrase"=存储密码
dlgSgSshCredentials.chk"Store password"=存储密码
dlgSgSshCredentials.edt"Authentication Type"=验证类型
dlgSgSshCredentials.edt"Passphrase"=密码
dlgSgSshCredentials.edt"Password"=密码
dlgSgSshCredentials.edt"Private Key File"=私钥文件
dlgSgSshCredentials.hdl=SSH 凭据
dlgSgSshCredentials.inf=提供用于以 “root” 身份向 SSH 服务器 “git” 进行身份验证的凭据。
dlgSgSshCredentials.rbt"Password"=密码
dlgSgSshCredentials.rbt"Private Key"=私钥
dlgSgSshCredentials.tle=SSH 身份验证
dlgSgSshCredentials.wrn"$1"=$1
dlgSgStageConflict.btn"Stage Anyway"=总是暂存
dlgSgStageConflict.fur=该文件包含冲突标记，这些标记指示您尚未解决所有冲突。
dlgSgStageConflict.hdl%1=$1 真的应该暂存吗？
dlgSgStageConflict.tle=暂存
dlgSgStageNoFilesFound.fur=找不到包含已修改工作区，未跟踪或丢失文件的文件。
dlgSgStageNoFilesFound.hdl=找不到可以暂存的文件。
dlgSgStageNoFilesFound.tle=暂存
dlgSgStartupExpired.btn"&Continue \($1\)"=&Continue \($1\)
dlgSgStartupExpired.btn"Continue \($1\)"=Continue \($1\)
dlgSgStartupExpired.btn"Download New Version"=Download New Version
dlgSgStartupExpired.btn"Exit"=Exit
dlgSgStartupExpired.fur=Please download and install a new one or a release version.
dlgSgStartupExpired.hdl=This beta version expired.
dlgSgStartupExpired.tle=Beta Version Expired
dlgSgStashAll.btn"+ Keep Index"=+ 保持索引
dlgSgStashAll.btn"+ Keep Working Tree"=+ 保持工作区
dlgSgStashAll.btn"Stash All"=贮藏全部
dlgSgStashAll.btn"Stash Selection"=贮藏选择
dlgSgStashAll.edt"Message"=消息
dlgSgStashAll.hdl=存储索引和工作区更改
dlgSgStashAll.inf=保存的存储可以在以后应用。默认情况下，清理索引和工作区，但您可以保留索引或两者。
dlgSgStashAll.tle=贮藏
dlgSgStashApply.btn"Apply && Drop"=应用并删除
dlgSgStashApply.btn"Apply"=应用
dlgSgStashApply.chk"Restore Index"=还原索引
dlgSgStashApply.hdl"Apply a previously saved stash"=应用以前保存的存储
dlgSgStashApply.hdl"Apply the latest saved stash"=应用最新保存的存储
dlgSgStashApply.inf=确定如何将存储应用于索引或工作区。
dlgSgStashApply.tle=应用贮藏
dlgSgStashApplyWithoutRestoringIndex.btn"Try Without Restoring Index"=尝试不还原索引
dlgSgStashApplyWithoutRestoringIndex.fur=应用修补程序时还原索引失败。
dlgSgStashApplyWithoutRestoringIndex.hdl=是否应用存储而不还原索引？
dlgSgStashApplyWithoutRestoringIndex.tle=应用贮藏
dlgSgStashOnDemandConfirmation.btn"Discard"=丢弃
dlgSgStashOnDemandConfirmation.btn"Save Stash"=贮藏
dlgSgStashOnDemandConfirmation.chk=自动贮藏
dlgSgStashOnDemandConfirmation.fur=请选择将它们保存为存储，以便以后手动重新应用或丢弃它们。
dlgSgStashOnDemandConfirmation.hdl=如何处理工作区或索引更改？
dlgSgStashOnDemandConfirmation.tle=重置
dlgSgStashOnDemandLocalChangesCantBeReapplied.fur=一旦完成拉取操作，您应该手动应用最新的存储，以将本地更改还原到工作区中。
dlgSgStashOnDemandLocalChangesCantBeReapplied.hdl=您的本地更改已被贮藏，但无法重新应用。
dlgSgStashOnDemandLocalChangesCantBeReapplied.tle=拉取
dlgSgStashOnDemandProceedWithoutStashing.btn"Proceed"=Proceed
dlgSgStashOnDemandProceedWithoutStashing.fur=Auto-stashing changes is not possible due to technical reasons. Changes will be discarded!
dlgSgStashOnDemandProceedWithoutStashing.hdl=Do you want to proceed without stashing changes?
dlgSgStashOnDemandProceedWithoutStashing.tle=Reset
dlgSgStashRename.btn"Rename"=重命名
dlgSgStashRename.edt"Message"=消息
dlgSgStashRename.hdl=重命名贮藏
dlgSgStashRename.inf=输入贮藏的新消息
dlgSgStashRename.tle=重命名
dlgSgStashesDropConfirm.btn"Drop Stash"=丢弃贮藏
dlgSgStashesDropConfirm.btn"Drop Stashes"=丢弃贮藏
dlgSgStashesDropConfirm.fur=贮藏的变化将会丢失。
dlgSgStashesDropConfirm.hdl=你想丢弃选定的贮藏吗？
dlgSgStashesDropConfirm.tle=丢弃贮藏
dlgSgSubmoduleAdd.chk"Map SVN trunk, tags and branches to Git"=\
 将 SVN 主干，标签和分支映射到 Git
dlgSgSubmoduleAdd.edt"Branch"=分支
dlgSgSubmoduleAdd.edt"Local Directory"=本地目录
dlgSgSubmoduleAdd.edt"Local Path"=本地路径
dlgSgSubmoduleAdd.edt"Repository URL"=仓库 URL
dlgSgSubmoduleAdd.edt"URL"=URL
dlgSgSubmoduleAdd.inf"Provide the path where the submodule should be added relative to the outer repository root directory."=\
 提供要添加的子模块相对于外部版本库根目录的相对路径.
dlgSgSubmoduleAdd.inf"Specify the repository to clone as submodule."=\
 指定要克隆为子模块的的版本仓库.
dlgSgSubmoduleAdd.lbl"e.g. https://user@server:port/path/to/repository"=e.g. https://user@server:port/path/to/repository
dlgSgSubmoduleAdd.mni"Add Hosting Provider"=Add Hosting Provider
dlgSgSubmoduleAdd.rbt"Local repository"=本地仓库
dlgSgSubmoduleAdd.rbt"Remote repository"=远程仓库
dlgSgSubmoduleAdd.tle=添加子模块
dlgSgSubmoduleDeinitConfirm.btn"Deinit"=删除
dlgSgSubmoduleDeinitConfirm.fur=子模块将从工作区中跳过。 要摆脱 \(远程\) 仓库，您必须使用取消注册。
dlgSgSubmoduleDeinitConfirm.hdl%1=你想要删除子模块 '$1' 吗？
dlgSgSubmoduleDeinitConfirm.tle=删除子模块
dlgSgSubmoduleResetConfirm.btn"Reset"=重置
dlgSgSubmoduleResetConfirm.fur=将检出相应的提交，因此子模块内容将匹配已注册提交的内容。
dlgSgSubmoduleResetConfirm.hdl%1=是否要将子模块 $1 重置为仓库中注册的提交？
dlgSgSubmoduleResetConfirm.tle=重置子模块
dlgSgSubmoduleSync.btn"Synchronize"=Synchronize
dlgSgSubmoduleSync.chk"Pull submodule repositories"=Pull submodule repositories
dlgSgSubmoduleSync.hdl=Synchronize all submodules
dlgSgSubmoduleSync.inf=Submodule entries will be updated in .git/config. You may customize the URLs afterwards or pull immediately.
dlgSgSubmoduleSync.tle=Synchronize Submodules
dlgSgSubtreeAdd.chk"Create local branch \(for advanced operations\)"=\
 Create local branch \(for advanced operations\)
dlgSgSubtreeAdd.chk"Squash subtree into single commit"=Squash subtree into single commit
dlgSgSubtreeAdd.edt"Branch"=分支
dlgSgSubtreeAdd.edt"Local Directory"=Local Directory
dlgSgSubtreeAdd.edt"Local Path"=Local Path
dlgSgSubtreeAdd.edt"Remote"=Remote
dlgSgSubtreeAdd.edt"Repository URL"=Repository URL
dlgSgSubtreeAdd.inf"Provide the path where the subtree should be added relative to the outer repository root directory."=\
 Provide the path where the subtree should be added relative to the outer repository root directory.
dlgSgSubtreeAdd.inf"Specify the repository to clone as subtree."=\
 Specify the repository to clone as subtree.
dlgSgSubtreeAdd.lbl"Local branches for subtrees will only be useful if you plan to use Subtree-Split and Subtree-Reset operations."=\
 Local branches for subtrees will only be useful if you plan to use Subtree-Split and Subtree-Reset operations.
dlgSgSubtreeAdd.lbl"e.g. https://user@server:port/path/to/repository"=e.g. https://user@server:port/path/to/repository
dlgSgSubtreeAdd.rbt"Local repository"=Local repository
dlgSgSubtreeAdd.rbt"Remote repository"=Remote repository
dlgSgSubtreeAdd.tle=Add Subtree
dlgSgSvnClientCertificate.btn"Login"=登录
dlgSgSvnClientCertificate.chk"Store passphrase"=存储密码
dlgSgSvnClientCertificate.edt"Certificate"=证书
dlgSgSvnClientCertificate.edt"Passphrase"=密码
dlgSgSvnClientCertificate.hdl=客户端证书
dlgSgSvnClientCertificate.inf%1=为 SVN 仓库 “$1” 提供身份验证的客户端证书。
dlgSgSvnClientCertificate.tle=SVN 认证
dlgSgSvnClientCertificate.wrn"Authentication to the SVN repository '$1' failed with error: $2"=\
 对 SVN 仓库 “$1” 的身份验证失败，错误：$2
dlgSgSvnSslFingerprintChanged.btn"Accept"=同意
dlgSgSvnSslFingerprintChanged.btn"Reject"=拒绝
dlgSgSvnSslFingerprintChanged.edt"MD5 fingerprint"=MD5 指纹
dlgSgSvnSslFingerprintChanged.edt"SHA fingerprint"=SHA 指纹
dlgSgSvnSslFingerprintChanged.edt"Server"=服务器
dlgSgSvnSslFingerprintChanged.lbl"The server fingerprint has changed! Is the change correct?"=\
 服务器指纹已更改！更改是否正确？
dlgSgSvnSslFingerprintChanged.lbl"This might indicate a security problem! When in doubt, contact your server administrator."=\
 这可能表明存在安全问题！如果有疑问，请与服务器管理员联系。
dlgSgSvnSslFingerprintChanged.tle=SVN 身份验证
dlgSgSyncConfirm.btn"Synchronize"=同步
dlgSgSyncConfirm.chk=不再显示
dlgSgSyncConfirm.fur=首先，将推送本地更改，然后可能会拉取远程更改。比普通推送的优势在于，如果由于远程更改而推送失败，它们将被自动拉取。
dlgSgSyncConfirm.hdl=你确定要继续同步吗？
dlgSgSyncConfirm.tle=同步
dlgSgTagAdd.btn"Add Tag && Push"=创建标签并推送
dlgSgTagAdd.btn"Add Tag"=创建标签
dlgSgTagAdd.chk"GPG-sign tag"=GPG-sign tag
dlgSgTagAdd.edt"Annotated Tag Message"=带注释的标签消息
dlgSgTagAdd.edt"Tag"=标签
dlgSgTagAdd.err"The name must not end with a slash or dot."=\
 名称不得以斜杠或点结尾。
dlgSgTagAdd.hdl=在当前 HEAD 提交创建标签
dlgSgTagAdd.inf=输入要创建的标签名称。如果输入消息，则会创建带注释的标签。
dlgSgTagAdd.tle=创建标签
dlgSgTagAddOverwrite.btn"Overwrite"=覆盖
dlgSgTagAddOverwrite.fur=单击 “取消” 以选择其他标签名称。
dlgSgTagAddOverwrite.hdl%1=标签 '$1' 已经存在。 你想覆盖它吗？
dlgSgTagAddOverwrite.tle=创建标签
dlgSgTagDeleteConfirmSingle.btn"Delete"=删除
dlgSgTagDeleteConfirmSingle.chk%1=从远程 “$1” 删除
dlgSgTagDeleteConfirmSingle.fur=你将无法恢复它。
dlgSgTagDeleteConfirmSingle.hdl%1=您确定要删除 “$1” 标签吗？
dlgSgTagDeleteConfirmSingle.tle=删除
dlgSgToolAdd.edt"Keyboard Shortcut"=键盘快捷键
dlgSgToolAdd.err"Please enter a confirmation message."=Please enter a confirmation message.
dlgSgToolAdd.err"Please enter the name for this command."=\
 Please enter the name for this command.
dlgSgToolAdd.err"Select the command which should be invoked."=\
 Select the command which should be invoked.
dlgSgToolAdd.err"The options 'Can be used by the Open command' and 'Show output and wait until finished' cannot both be set."=\
 The options 'Can be used by the Open command' and 'Show output and wait until finished' cannot both be set.
dlgSgToolAdd.hdl=添加外部工具
dlgSgToolAdd.tle=添加
dlgSgToolEdit.edt"Keyboard Shortcut"=键盘快捷键
dlgSgToolEdit.err"Please enter the name for this command."=\
 请输入此命令的名称。
dlgSgToolEdit.hdl=编辑外部工具
dlgSgToolEdit.tle=编辑
dlgSgTool(Add|Edit).btn"Clear"=清除
dlgSgTool(Add|Edit).chk"Can be used by the Open command"=\
 可以由 “打开” 命令使用
dlgSgTool(Add|Edit).chk"Request confirmation before invoking:"=在调用之前请求确认：
dlgSgTool(Add|Edit).chk"Show output and wait until finished"=\
 显示输出并等待完成
dlgSgTool(Add|Edit).edt"Accelerator"=加速器
dlgSgTool(Add|Edit).edt"Applies To"=适用于
dlgSgTool(Add|Edit).edt"Arguments"=参数
dlgSgTool(Add|Edit).edt"Command"=命令
dlgSgTool(Add|Edit).edt"Handles"=控制
dlgSgTool(Add|Edit).edt"Menu Item Name"=菜单项名称
dlgSgTool(Add|Edit).inf=定义工具菜单项的名称，应执行的命令并配置其参数。使用的变量定义了可以使用工具的选择。
dlgSgTool(Add|Edit).lbl"Valid wildcards are ?\u00a0\(one arbitrary character\) and \*\u00a0\(any number of arbitrary characters\). Separate multiple patterns by comma. Example:\u00a0\*.txt,\u00a0\*.html"=\
 有效的通配符是 ?\u00a0\(一个任意字符\)和 \*\u00a0\(任意数量的任意字符\)。用逗号分隔多个模式。例如：\u00a0\*.txt，\u00a0\* .html。
dlgSgTool(Add|Edit).mni"2nd Commit ID or Ref \(optional\)"=\
 第二个提交 ID 或参考 \(可选\)
dlgSgTool(Add|Edit).mni"2nd Commit ID or Ref"=第 2 个提交 ID 或引用
dlgSgTool(Add|Edit).mni"Commit ID or Ref"=提交 ID 或参考
dlgSgTool(Add|Edit).mni"Configured Text File Encoding"=配置的文本文件编码
dlgSgTool(Add|Edit).mni"File or Directory Name"=文件或目录名称
dlgSgTool(Add|Edit).mni"File or Directory Path"=文件或目录路径
dlgSgTool(Add|Edit).mni"File or Directory URI"=文件或目录地址
dlgSgTool(Add|Edit).mni"Git Executable"=Git 可执行文件
dlgSgTool(Add|Edit).mni"Git Installation"=Git 安装程序
dlgSgTool(Add|Edit).mni"Hg Executable"=Hg 可执行文件
dlgSgTool(Add|Edit).mni"Hg Installation"=Hg 安装程序
dlgSgTool(Add|Edit).mni"Remote \(Push\) URL"=远程 \(推送\) 网址
dlgSgTool(Add|Edit).mni"Repository Root Path"=仓库根路径
dlgSgTool(Add|Edit).mni"Selection File"=选择文件
dlgSgTool(Add|Edit).mni"Show Directory Selection Dialog"=显示目录选择对话框
dlgSgTool(Add|Edit).mni"Show Open File Dialog"=显示打开文件对话框
dlgSgTool(Add|Edit).mni"Show Save File Dialog"=显示保存文件对话框
dlgSgTool(Add|Edit).mni"SmartGit Installation"=SmartGit 安装程序
dlgSgTool(Add|Edit).rbt"Both"=都
dlgSgTool(Add|Edit).rbt"Commits"=Commits
dlgSgTool(Add|Edit).rbt"Directories"=目录
dlgSgTool(Add|Edit).rbt"Files"=文件
dlgSgTool(Add|Edit).rbt"Refs"=参考
dlgSgUndoLastCommitConfirm.btn"Undo"=撤销
dlgSgUndoLastCommitConfirm.fur"Message: $1"=消息：$1
dlgSgUndoLastCommitConfirm.fur"Undoing an already pushed commit might cause serious problems!\n\nMessage: $1"=\
 撤消已推送的提交可能会导致严重问题！\n\n详情：$1
dlgSgUndoLastCommitConfirm.hdl=您确定要撤消上一次本地提交吗？
dlgSgUndoLastCommitConfirm.tle=撤消上次提交
dlgSgUnstageNoFilesFound.fur=找不到具有暂存更改的文件。
dlgSgUnstageNoFilesFound.hdl=找不到可能取消暂存的文件。
dlgSgUnstageNoFilesFound.tle=取消暂存
dlgSgWelcome.chk"Show this dialog if no repository was opened"=\
 如果没有打开仓库，则显示此对话框
dlgSgWelcome.hdl=你想做什么?
dlgSgWelcome.inf=选择是否打开新的本地仓库，克隆 \(远程\) 仓库或打开现有仓库。
dlgSgWelcome.rbt"Add an existing local or create a new repository"=\
 创建现有本地或创建新仓库
dlgSgWelcome.rbt"Clone existing repository"=克隆现有的仓库
dlgSgWelcome.rbt"Reopen previously used repository:"=重新打开以前使用的仓库：
dlgSgWelcome.tle=欢迎使用 SmartGit
dlgSgWorktreeAdd.edt"Branch"=分支
dlgSgWorktreeAdd.edt"Directory"=目录
dlgSgWorktreeAdd.hdl=从此仓库创建另一个工作区
dlgSgWorktreeAdd.inf=选择要用于新工作区的分支和目录。
dlgSgWorktreeAdd.tle=创建工作区
dlgSgWorktreeAddNoMoreLocalBranches.fur=只能为尚无关联工作区的现有本地分支创建工作区。
dlgSgWorktreeAddNoMoreLocalBranches.hdl=没有可用的 \(更多\) 本地分支。
dlgSgWorktreeAddNoMoreLocalBranches.tle=添加工作区
dlgSgWorktreePruneNoWorktree.fur=您的所有工作区仍然可用。
dlgSgWorktreePruneNoWorktree.hdl=没有要删除的工作区。
dlgSgWorktreePruneNoWorktree.tle=删除废弃的工作区
dlgSg(Preferences|Pull|RepositorySettings).rbt"Merge fetched remote changes"=合并获取的远程更改
dlgSg(Preferences|Pull|RepositorySettings).rbt"Rebase local branch onto fetched changes"=\
 将本地分支变基为获取的更改
dlgShPushTrackingLocalSvnBranches.btn"Push as New"=推送到新的
dlgShPushTrackingLocalSvnBranches.btn"Push onto Existing"=推到现有的
dlgShPushTrackingLocalSvnBranches.fur=您将把本地分支推送回 SVN 仓库。 这些分支可能作为新分支推送到现有的 SVN 对应部分 \(在大多数情况下推荐使用\)。
dlgShPushTrackingLocalSvnBranches.hdl=你想推动本地分支作为新的 SVN 分支吗？
dlgShPushTrackingLocalSvnBranches.tle=推送
dlgTxtEditor.fileModified.btn"Keep Content"=Keep Content
dlgTxtEditor.fileModified.btn"Reload"=Reload
dlgTxtEditor.fileModified.fur=Unless you want to see the old file state, it is recommended to reload.
dlgTxtEditor.fileModified.hdl=The file config was changed. Reload it?
dlgTxtEditor.fileModified.tle=Editor
dlg(DgRefMapperGroupConfig|SgPreferences|SgRepositorySettings).edt"Group Patterns"=分组模式
dlg(DgRefMapperGroupConfig|SgPreferences|SgRepositorySettings).edt"Single Patterns"=单一模式
dlg(DgRefMapperGroupConfig|SgPreferences|SgRepositorySettings).lbl"Tags, branches and other refs matched by this configuration will be grouped in the File Log and show up in the Commit details. It will also be used for grouping the 'Tags'-category of the Branches view."=\
 与此配置匹配的标签、分支和其他引用将在文件日志中分组，并显示在提交详细信息中。它还将用于对 “分支” 视图的 “标签” 类别进行分组。
dlg(DgRefMapperGroupConfig|SgPreferences|SgRepositorySettings).tab"Tag-Grouping"=标签分组
dlg(ScConflictSolverAdd|ScConflictSolverEdit|ScFileComparatorAdd|ScFileComparatorEdit).err"Please enter a file pattern \(e.g. \*.txt, \*.java\)."=\
 Please enter a file pattern \(e.g. \*.txt, \*.java\).
dlg(ScConflictSolverAdd|ScConflictSolverEdit|ScFileComparatorAdd|ScFileComparatorEdit).err"Select the command which should be invoked."=\
 Select the command which should be invoked.
dlg(ScConflictSolverAdd|ScConflictSolverEdit|ScFileComparatorAdd|ScFileComparatorEdit).err"Specify the necessary arguments for the command, especially the required variable."=\
 Specify the necessary arguments for the command, especially the required variable.
dlg(ScConflictSolverAdd|ScConflictSolverEdit|ScFileComparatorAdd|ScFileComparatorEdit).err"Specify the necessary arguments for the command, especially the required variables."=\
 Specify the necessary arguments for the command, especially the required variables.
dlg(ScConflictSolverAdd|ScConflictSolverEdit|ScFileComparatorAdd|ScFileComparatorEdit).err"The Arguments require the variable \$\{file\}."=\
 The Arguments require the variable \$\{file\}.
dlg(ScConflictSolverAdd|ScConflictSolverEdit|ScFileComparatorAdd|ScFileComparatorEdit).err"The Arguments require the variables \$\{leftFile\} and \$\{rightFile\}."=\
 The Arguments require the variables \$\{leftFile\} and \$\{rightFile\}.
dlg(ScConflictSolverAdd|ScConflictSolverEdit|ScFileComparatorAdd|ScFileComparatorEdit).err"The Arguments require the variables \$\{leftFile\}, \$\{rightFile\} and \$\{mergedFile\}."=\
 The Arguments require the variables \$\{leftFile\}, \$\{rightFile\} and \$\{mergedFile\}.
dlg(ScConflictSolverAdd|ScConflictSolverEdit|ScFileComparatorAdd|ScFileComparatorEdit).lbl"You must use the variable \$\{file\}."=\
 You must use the variable \$\{file\}.
dlg(ScConflictSolverAdd|ScConflictSolverEdit|ScFileComparatorAdd|ScFileComparatorEdit).lbl"You must use the variables \$\{leftFile\} and \$\{rightFile\}."=\
 You must use the variables \$\{leftFile\} and \$\{rightFile\}.
dlg(SgDeleteFileTrash|SgDeleteFilesTrash).btn"Delete"=删除
dlg(SgDeleteFileTrash|SgDeleteFilesTrash).btn"Move to Trash"=移动到回收站
dlg(SgDeleteFileTrash|SgDeleteFilesTrash).fur=如果单击 “删除”，则可能需要文件还原工具来还原已删除的文件！
dlg(SgDeleteFileTrash|SgDeleteFilesTrash).tle=删除
dlg(SgRepositoryRemoveMultiGroup|SgRepositoryRemoveMultiRepo|SgRepositoryRemoveMultiRepoMultiGroup|SgRepositoryRemoveMultiRepoSingleGroup|SgRepositoryRemoveSingleGroup|SgRepositoryRemoveSingleRepo|SgRepositoryRemoveSingleRepoMultiGroup|SgRepositoryRemoveSingleRepoSingleGroup).btn"Remove"=删除
dlg(SgRepositoryRemoveMultiGroup|SgRepositoryRemoveMultiRepo|SgRepositoryRemoveMultiRepoMultiGroup|SgRepositoryRemoveMultiRepoSingleGroup|SgRepositoryRemoveSingleGroup|SgRepositoryRemoveSingleRepo|SgRepositoryRemoveSingleRepoMultiGroup|SgRepositoryRemoveSingleRepoSingleGroup).chk=不再显示
dlg(SgRepositoryRemoveMultiGroup|SgRepositoryRemoveMultiRepo|SgRepositoryRemoveMultiRepoMultiGroup|SgRepositoryRemoveMultiRepoSingleGroup|SgRepositoryRemoveSingleGroup|SgRepositoryRemoveSingleRepo|SgRepositoryRemoveSingleRepoMultiGroup|SgRepositoryRemoveSingleRepoSingleGroup).tle=删除
edt"Search For"=搜索
ntmCredentialHelper"In case you are encountering strange errors or unexpected dialog popups, try to disable this configuration and let SmartGit handle the authentication itself."=\
 In case you are encountering strange errors or unexpected dialog popups, try to disable this configuration and let SmartGit handle the authentication itself.
ntmCredentialHelper"In general this should be fine and is the recommended configuration when working with multiple Git clients."=\
 In general this should be fine and is the recommended configuration when working with multiple Git clients.
ntmCredentialHelper"SmartGit has detected that <b>credential.helper</b> is configured in config file $1."=\
 SmartGit has detected that <b>credential.helper</b> is configured in config file $1.
ntmCredentialHelper"To disable this configuration, open the above config file, locate the <b>\[credential\]</b>-section and comment out the <b>helper\=</b> line using <b>#</b>"=\
 To disable this configuration, open the above config file, locate the <b>\[credential\]</b>-section and comment out the <b>helper\=</b> line using <b>#</b>
ntmFollowUsOnTwitter"It's a great way to help shaping future versions of SmartGit!"=\
 It's a great way to help shaping future versions of SmartGit!
ntmFollowUsOnTwitter"We are using Twitter to:"=We are using Twitter to:
ntmFollowUsOnTwitter"announce new versions, including previews"=announce new versions, including previews
ntmFollowUsOnTwitter"inform about new features"=inform about new features
ntmFollowUsOnTwitter"poll for opinions on how to implement new or change existing features"=\
 poll for opinions on how to implement new or change existing features
ntmHighMemoryUsage"If you are working with huge repositories, this may be OK. In this case, edit $1, increase the value of the -Xmx option, for example to -Xmx1024m \(or add it if not yet existing\) for better performance."=\
 If you are working with huge repositories, this may be OK. In this case, edit $1, increase the value of the -Xmx option, for example to -Xmx1024m \(or add it if not yet existing\) for better performance.
ntmHighMemoryUsage"If you think that the configured memory limit is already quite high or you are not working with huge repositories, this may indicate a problem. Please let us know about it."=\
 If you think that the configured memory limit is already quite high or you are not working with huge repositories, this may indicate a problem. Please let us know about it.
ntmHighMemoryUsage"SmartGit is close to the configured memory limit."=\
 SmartGit is close to the configured memory limit.
ntmHostingProviderIntegrationNotYetConfigured"SmartGit provides special support for $1. The integration can be configured in the Preferences."=\
 SmartGit provides special support for $1. The integration can be configured in the Preferences.
ntmMarkRepositoriesAsFavorite"Git repositories marked as 'favorites' will be refreshed and fetched automatically in the background."=\
 Git repositories marked as 'favorites' will be refreshed and fetched automatically in the background.
ntmMarkRepositoriesAsFavorite"To mark a repository as 'favorite', right-click on it in the 'Repositories' view and select 'Mark as Favorite'."=\
 To mark a repository as 'favorite', right-click on it in the 'Repositories' view and select 'Mark as Favorite'.
ntmPreferencesChangesRestartRequired"Some preferences options have been changed which will only be applied after restarting SmartGit."=\
 Some preferences options have been changed which will only be applied after restarting SmartGit.
ntmProblematicGcConfiguration"Git's garbage collection is \(by default\) configured to run in background \(gc.autoDetach\) in your .gitconfig. This configuration is appropriate for command line client, but may cause troubles in combinations with GUI clients like SmartGit."=\
 Git's garbage collection is \(by default\) configured to run in background \(gc.autoDetach\) in your .gitconfig. This configuration is appropriate for command line client, but may cause troubles in combinations with GUI clients like SmartGit.
ntmSupportExpired"To extend your support, please purchase an update license and upgrade to the latest SmartGit version."=\
 To extend your support, please purchase an update license and upgrade to the latest SmartGit version.
ntmSupportExpired"You may continue to use SmartGit, just your support period expired."=\
 You may continue to use SmartGit, just your support period expired.
ntmUpdateCheckFetchVersionStart"After the new version has been downloaded successfully, you will be notified again."=\
 After the new version has been downloaded successfully, you will be notified again.
ntmUpdateCheckFetchVersionSuccess"Your SmartGit installation needs to be upgraded now."=\
 Your SmartGit installation needs to be upgraded now.
ntmVoteForUs"Let us and other users know why you prefer SmartGit over other Git clients or what parts of SmartGit still need work!"=\
 Let us and other users know why you prefer SmartGit over other Git clients or what parts of SmartGit still need work!
ntmVoteForUs"share the pros and cons at <link1>slant.co</link1>"=\
 share the pros and cons at <link1>slant.co</link1>
ntmVoteForUs"vote at <link1>alternativeto.net</link1>"=vote at <link1>alternativeto.net</link1>
nttCredentialHelper"External Credentials Helper detected"=External Credentials Helper detected
nttFollowUsOnTwitter"Follow SmartGit on Twitter!"=Follow SmartGit on Twitter!
nttFollowUsOnTwitter"Follow on Twitter"=Follow on Twitter
nttGeneral"Don't show again"=Don't show again
nttGeneral"Remind me later"=Remind me later
nttHighMemoryUsage"Contact Support"=Contact Support
nttHighMemoryUsage"High memory usage"=High memory usage
nttHostingProviderIntegrationNotYetConfigured"$1-integration is not yet configured."=$1-integration is not yet configured.
nttHostingProviderIntegrationNotYetConfigured"Configure Now"=Configure Now
nttMarkRepositoriesAsFavorite"Mark repositories as 'favorite' for automatic background refresh."=\
 Mark repositories as 'favorite' for automatic background refresh.
nttPreferencesChangesRestartRequired"Exit SmartGit"=Exit SmartGit
nttPreferencesChangesRestartRequired"Restart Required"=Restart Required
nttProblematicGcConfiguration"Disable Background GC"=Disable Background GC
nttProblematicGcConfiguration"Possibly problematic Git GC configuration"=Possibly problematic Git GC configuration
nttSupportExpired"Purchase Update"=Purchase Update
nttSupportExpired"Your support period has expired on $1."=\
 Your support period has expired on $1.
nttUpdateCheckFetchVersionStart"Started downloading version $1 \($2\)."=Started downloading version $1 \($2\).
nttUpdateCheckFetchVersionSuccess"Show Changelog"=Show Changelog
nttUpdateCheckFetchVersionSuccess"Successfully downloaded version $1 \($2\)."=Successfully downloaded version $1 \($2\).
nttUpdateCheckFetchVersionSuccess"Upgrade SmartGit"=Upgrade SmartGit
nttVoteForUs"What do you like in SmartGit?"=\
 What do you like in SmartGit?
pop"$1 succeeded."=$1 成功。
pop"Command $1 has been aborted."=命令 $1 已中止。
pop"Modify the previous commit and commit."=\
 修改先前的提交和提交。
pop"No more change."=No more change.
pop"No more changes."=没有差异。
pop"Please review the files to commit."=\
 Please review the files to commit.
pop"Select the branch for which to stop tracking."=\
 Select the branch for which to stop tracking.
pop"Select the remote to fetch from."=\
 选择要从中获取的远程仓库。
pop"Select the remote to rename."=选择要重命名的远程。
pop"Select the stash to drop."=Select the stash to drop.
pop"Select the stash to rename."=选择要重命名的存储。
pop"There are no obsolete repositories."=没有过时的仓库。
pop"There is no action available for this drop operation."=\
 此删除操作没有可用的操作。
pop"Unstage unwanted changes for the 1st commit, and commit."=\
 取消暂存第一次提交和提交的不需要的更改。
ttpClonePartialWarning"<b>Warning!</b>\n\nThis functionality depends on the capabilities of your server.\nOnce the clone has finished, check the Output view for possible warnings."=\
 <b>Warning!</b>\n\nThis functionality depends on the capabilities of your server.\nOnce the clone has finished, check the Output view for possible warnings.
ttpTagGroupingGroupPatterns"Refs will be categorized into groups: when traversing the repository root log, refs will first be assigned to matching groups. Every group will store only the most recently encountered ref, i.e. if a new ref is encountered, it will replace all existing refs in the current group.\n\nNext, the refs remaining in the group will be passed on from child to parent commit. Now, once again they will be assigned to matching groups, possibly replacing other refs or possibly becoming replaced by more recent refs.\n\nPatterns will be matched against the full ref-name, including the <tt>refs</tt>-prefix. For a matching ref, its name will be shortened to the last path-segment \('\\/'\). For example, <tt>refs/tags/build-.\*</tt> will match a tag <tt>refs/tags/build-123</tt> and its name will be shortened to <tt>build-123</tt>. You may add a <i>named regex capturing group</i> called <tt>name</tt> to further customize the name extraction. For example, <tt>refs/tags/build-\(?&lt;name&gt;.\*\)</tt> will match <tt>refs/tags/build-123</tt> and its name will be shortened to <tt>123</tt>.\n\nYou can assign a title to a pattern by prefixing it by <tt>title:</tt>; the title may only contain letters, digits and '_'.\n\nYou can specify multiple groups patterns, separated by comma \(<tt>,</tt>\), which will be processed in the specified order: if you define two groups which both match a set of refs, such refs will be assigned to the first group.\n\nExample: <tt>build:refs/tags/build\(?&lt;name&gt;.\*\),version:refs/tags/\\d+\\.\\d+\\..\*</tt>"=\
 Refs will be categorized into groups: when traversing the repository root log, refs will first be assigned to matching groups. Every group will store only the most recently encountered ref, i.e. if a new ref is encountered, it will replace all existing refs in the current group.\n\nNext, the refs remaining in the group will be passed on from child to parent commit. Now, once again they will be assigned to matching groups, possibly replacing other refs or possibly becoming replaced by more recent refs.\n\nPatterns will be matched against the full ref-name, including the <tt>refs</tt>-prefix. For a matching ref, its name will be shortened to the last path-segment \('\\/'\). For example, <tt>refs/tags/build-.\*</tt> will match a tag <tt>refs/tags/build-123</tt> and its name will be shortened to <tt>build-123</tt>. You may add a <i>named regex capturing group</i> called <tt>name</tt> to further customize the name extraction. For example, <tt>refs/tags/build-\(?&lt;name&gt;.\*\)</tt> will match <tt>refs/tags/build-123</tt> and its name will be shortened to <tt>123</tt>.\n\nYou can assign a title to a pattern by prefixing it by <tt>title:</tt>; the title may only contain letters, digits and '_'.\n\nYou can specify multiple groups patterns, separated by comma \(<tt>,</tt>\), which will be processed in the specified order: if you define two groups which both match a set of refs, such refs will be assigned to the first group.\n\nExample: <tt>build:refs/tags/build\(?&lt;name&gt;.\*\),version:refs/tags/\\d+\\.\\d+\\..\*</tt>
ttpTagGroupingSinglePattern"In addition to the grouping logic, a ref matching the <b>Single Patterns</b> will be assigned to a group on its own. This is a shortcut for enumerating each of these refs as explicit pattern in <b>Group Patterns</b>.\n\nFor example, you want to make sure that each of your release branches is considered as group on its own and thus show up in the log graph or will be treated separately by the 'on-refs' calculation.\n\nExample: <tt>refs\\/remotes\\/origin\\/release-.\\\*</tt>"=\
 In addition to the grouping logic, a ref matching the <b>Single Patterns</b> will be assigned to a group on its own. This is a shortcut for enumerating each of these refs as explicit pattern in <b>Group Patterns</b>.\n\nFor example, you want to make sure that each of your release branches is considered as group on its own and thus show up in the log graph or will be treated separately by the 'on-refs' calculation.\n\nExample: <tt>refs\\/remotes\\/origin\\/release-.\\\*</tt>
wndAnnotate.edt"By"=By
wndAnnotate.edt"Commit"=提交
wndAnnotate.edt"Highlight"=高亮
wndAnnotate.edt"View Commit"=查看提交
wndAnnotate.mni"Copy Details"=Copy Details
wndAnnotate.mni"Copy ID"=Copy ID
wndAnnotate.mni"Copy Selection"=Copy Selection
wndAnnotate.mni"Open Log"=Open Log
wndAnnotate.mni"Show Changes"=Show Changes
wndAnnotate.mniCommit-first=转到第一次提交
wndAnnotate.mniCommit-last=转到最后一次提交
wndAnnotate.mniCommit-next=转到下一个提交
wndAnnotate.mniCommit-preceding-line=转到前一个提交
wndAnnotate.mniCommit-previous=转到上一个提交
wndAnnotate.mniCompare=显示更改
wndAnnotate.mniCustomize=自定义
wndAnnotate.mniEdit-copy=复制
wndAnnotate.mniFile-close=关闭
wndAnnotate.mniGoto-line=转到行
wndAnnotate.mniLog=打开日志
wndAnnotate.mniSearch-find=查找
wndAnnotate.mniSearch-next=查找下一个
wndAnnotate.mniSearch-previous=查找上一个
wndAnnotate.mniSet-syntax=语法语言
wndAnnotate.mniShowChanges=显示修改
wndAnnotate.mniUndo-goto=撤消转到
wndAnnotate.mniView-settings=设置
wndAnnotate.mniWindowHideView=隐藏视图
wndAnnotate.mniWindowLineHistory=行历史记录
wndAnnotate.mnu"Edit"=编辑
wndAnnotate.mnu"File"=文件
wndAnnotate.mnu"Go To"=转到
wndAnnotate.mnu"View"=视图
wndAnnotate.rbt"Commit Index"=提交索引
wndAnnotate.rbt"Time"=时间
wndAnnotate.tab"Document"=文档
wndAnnotate.tab"History of current line"=当前行的历史记录
wndCompare.mniRefresh=重新加载
wndCompare.mniView-layout-left-beside-right=左边右边
wndCompare.mniView-layout-left-over-right=左上方
wndCompare.tbtGoto-next-diff=下一处差异。
wndConflictSolver.mni"Apply Inner-line Difference to Working Tree"=\
 Apply Inner-line Difference to Working Tree
wndConflictSolver.mni"Apply Line to Working Tree"=Apply Line to Working Tree
wndConflictSolver.mni"Apply Selection to Working Tree"=Apply Selection to Working Tree
wndConflictSolver.mniView-layout-all=所有
wndConflictSolver.mniView-layout-left-merge=左合并
wndConflictSolver.mniView-layout-left-right-above-merge=左右合并
wndConflictSolver.mniView-layout-right-merge=右合并
wndConflictSolver.tbr"All"=全部
wndConflictSolver.tbr"Base + Right"=Base + Right
wndConflictSolver.tbr"Base Below"=Base Below
wndConflictSolver.tbr"Base Changes"=基本更改
wndConflictSolver.tbr"Left + Base"=Left + Base
wndConflictSolver.tbr"Left + Merge"=左边 + 合并
wndConflictSolver.tbr"Merge + Right"=合并 + 右边
wndConflictSolver.tbr"Merge Below"=下方合并
wndConflictSolver.tbr"Next Conflict"=下一处冲突
wndConflictSolver.tbr"Prev. Conflict"=上一处冲突
wndConflictSolver.tbr"Take Left, Right"=使用左边文件块, 使用右边文件块
wndConflictSolver.tbr"Take Right, Left"=使用右边文件块, 使用左边文件块
wndConflictSolver.tbtEdit-take-left=Take the left block to the merge result. Depending on the left block, this will insert, replace or delete at the merge result.
wndConflictSolver.tbtEdit-take-left-right=Take the left block, then the right one.
wndConflictSolver.tbtEdit-take-right=Take the right block to the merge result. Depending on the right block, this will insert, replace or delete at the merge result.
wndConflictSolver.tbtEdit-take-right-left=Take the right block, then the left one.
wndConflictSolver.tbtFile-open-base=从通用基础文档中打开左右更改。
wndConflictSolver.tbtFile-save=保存文件修改。
wndConflictSolver.tbtGoto-next-conflict=下一处冲突。
wndConflictSolver.tbtGoto-next-diff=下一处冲突更改。
wndConflictSolver.tbtGoto-previous-conflict=Go to previous conflict.
wndConflictSolver.tbtGoto-previous-diff=Go to previous change.
wndConflictSolver.tbtView-layout-all=Show the left, merge and right file.
wndConflictSolver.tbtView-layout-left-merge=Show the left and merge file.
wndConflictSolver.tbtView-layout-left-right-above-merge=在合并文件上方显示左右文件。
wndConflictSolver.tbtView-layout-right-merge=Show the merge and right file.
wndDeepgit.btn"Go Deeper"=更深入
wndDeepgit.col"File"=文件
wndDeepgit.col"Modifications"=修改
wndDeepgit.ihp"The \*Origin View\*: it highlights the selected origin candidate. By invoking \*Blame \(go deeper\)\* DeepGit will move its /focus/ onto the shown file\\/commit and select the corresponding commit in the \*Navigation\* view."=\
 The \*Origin View\*: it highlights the selected origin candidate. By invoking \*Blame \(go deeper\)\* DeepGit will move its /focus/ onto the shown file\\/commit and select the corresponding commit in the \*Navigation\* view.
wndDeepgit.ihp"This view displays all /origin candidates/ for the selected line from the \*Blame\* view: If the selected line has not been modified\\/added in the \*Blame\* view commit itself, the \*Appeared here\* origin takes you to this commit. Otherwise, the \*Changed in-place\* entry shows the actual change. \*Moved\* entries denote possible moves. The selected origin candidate will be highlighted in the \*Blame\* view as well as the \*Origin\* view. To inspect changes of the origin candidate in greater detail, switch to the \*Origins\* perspective."=\
 This view displays all /origin candidates/ for the selected line from the \*Blame\* view: If the selected line has not been modified\\/added in the \*Blame\* view commit itself, the \*Appeared here\* origin takes you to this commit. Otherwise, the \*Changed in-place\* entry shows the actual change. \*Moved\* entries denote possible moves. The selected origin candidate will be highlighted in the \*Blame\* view as well as the \*Origin\* view. To inspect changes of the origin candidate in greater detail, switch to the \*Origins\* perspective.
wndDeepgit.ihp"This view displays all changes for the selected commit from the \*Navigation\* view. The selected file will be compared in the below view."=\
 This view displays all changes for the selected commit from the \*Navigation\* view. The selected file will be compared in the below view.
wndDeepgit.ihp"This view displays all files which have changed as part of the selected \*Blame\* line's commit. The selected file will be compared in the below view."=\
 This view displays all files which have changed as part of the selected \*Blame\* line's commit. The selected file will be compared in the below view.
wndDeepgit.ihp"This view shows how the selected line from the \*Blame\* view has changed in the past."=\
 This view shows how the selected line from the \*Blame\* view has changed in the past.
wndDeepgit.ihp"This view shows the Log for the investigated file and for all previous files you have navigated to. For the selected commit, more details will be displayed which depend on the current perspective: \n# in the \*Blame\* perspective the file's content will be displayed in the \*Blame\* view, \n# in the \*Diff\* perspective the file's modifications will be displayed, \n# in the \*Log\* perspective a summary of all modified files will be displayed in the \*Files\* view."=\
 This view shows the Log for the investigated file and for all previous files you have navigated to. For the selected commit, more details will be displayed which depend on the current perspective: \n# in the \*Blame\* perspective the file's content will be displayed in the \*Blame\* view, \n# in the \*Diff\* perspective the file's modifications will be displayed, \n# in the \*Log\* perspective a summary of all modified files will be displayed in the \*Files\* view.
wndDeepgit.ihp"This view shows the blame for the selected file\\/commit from the \*Navigation\* tree. When selecting a line DeepGit will start searching for the origin of this line and show results in the \*Origin Candidates\* view \(only available in the \*Blame+Origins\* perspective\). The best origin candidate will be selected and highlighted. DeepGit will follow across line moves and file renames and taking into account the line's vicinity, so origin candidates will usually be blocks, not just single lines."=\
 This view shows the blame for the selected file\\/commit from the \*Navigation\* tree. When selecting a line DeepGit will start searching for the origin of this line and show results in the \*Origin Candidates\* view \(only available in the \*Blame+Origins\* perspective\). The best origin candidate will be selected and highlighted. DeepGit will follow across line moves and file renames and taking into account the line's vicinity, so origin candidates will usually be blocks, not just single lines.
wndDeepgit.ihp"This view shows the diff for the selected file from the above \*Files\* view."=\
 This view shows the diff for the selected file from the above \*Files\* view.
wndDeepgit.ihp"This view shows the diff for the selected origin candidate\\/file from the above \*Origin Candidates\*\\/\*Files\* view."=\
 This view shows the diff for the selected origin candidate\\/file from the above \*Origin Candidates\*\\/\*Files\* view.
wndDeepgit.lbl"Similarity detection was only performed for single lines, some results may be omitted \(View\|Extend Lines to Blocks\)"=\
 Similarity detection was only performed for single lines, some results may be omitted \(View\|Extend Lines to Blocks\)
wndDeepgit.lblBlameHeader"Blame \(in progress...\)"=Blame \(in progress...\)
wndDeepgit.lblBlameHeader"Blame for"=Blame for
wndDeepgit.lblBlameMatchPopup"Appeared here"=Appeared here
wndDeepgit.lblBlameMatchPopup"Changed in-place"=Changed in-place
wndDeepgit.lblBlameMatchPopup"Lines first appeared at this position"=\
 Lines first appeared at this position
wndDeepgit.lblBlameMatchPopup"Lines have possibly been changed in-place"=\
 Lines have possibly been changed in-place
wndDeepgit.lblBlameMatchPopup"Lines have possibly been moved over from somewhere else"=\
 Lines have possibly been moved over from somewhere else
wndDeepgit.lblBlameMatchPopup"Moved"=Moved
wndDeepgit.lblBlameMatchPopup"other possible origins"=other possible origins
wndDeepgit.lblBlameMatchPopup"single origin, high likelihood"=single origin, high likelihood
wndDeepgit.lblCompareHeader"New contents"=New contents
wndDeepgit.lblCompareHeader"Old contents"=Old contents
wndDeepgit.lblOriginCandidate"Appeared here"=Appeared here
wndDeepgit.lblOriginCandidate"Changed in-place"=Changed in-place
wndDeepgit.lblOriginCandidate"Line has been introduced in this commit"=\
 Line has been introduced in this commit
wndDeepgit.lblOriginCandidate"Lines have been added"=Lines have been added
wndDeepgit.lblOriginCandidate"Lines have been introduced in this commit"=\
 Lines have been introduced in this commit
wndDeepgit.lblOriginCandidate"Lines have been modified"=Lines have been modified
wndDeepgit.lblOriginCandidate"Moved"=Moved
wndDeepgit.lblOriginCandidate"Origins from '$1' omitted: file is binary"=\
 Origins from '$1' omitted: file is binary
wndDeepgit.lblOriginCandidate"Similarity detection was only performed for single lines, some results may be omitted \(View\|Extend Lines to Blocks\)"=\
 Similarity detection was only performed for single lines, some results may be omitted \(View\|Extend Lines to Blocks\)
wndDeepgit.lblOriginCandidate"as 'git diff' sees it"=as 'git diff' sees it
wndDeepgit.lblOriginCandidate"for the first time"=for the first time
wndDeepgit.lblOriginCandidate"from $1 previous line"=from $1 previous line
wndDeepgit.lblOriginCandidate"from $1 previous lines"=from $1 previous lines
wndDeepgit.lblOriginCandidate"of"=of
wndDeepgit.lblOriginCandidate"over from somewhere else"=over from somewhere else
wndDeepgit.lblOriginCandidate"similarity for $1 origin line"=similarity for $1 origin line
wndDeepgit.lblOriginCandidate"similarity for $1 origin lines"=similarity for $1 origin lines
wndDeepgit.lblOriginHeader"No file to compare"=No file to compare
wndDeepgit.lblOriginHeader"Possibly modified \(or added\) as part of <b>surrounding block</b> in old contents"=\
 Possibly modified \(or added\) as part of <b>surrounding block</b> in old contents
wndDeepgit.lblOriginHeader"Possibly moved from <b>similar lines</b> from old contents"=\
 Possibly moved from <b>similar lines</b> from old contents
wndDeepgit.lblOriginHeader"Possibly originates from <b>in-place change</b> since old contents"=\
 Possibly originates from <b>in-place change</b> since old contents
wndDeepgit.lblTextHeader"Commit"=提交
wndDeepgit.lblTextHeader"File"=File
wndDeepgit.lblTextHeader"Msg"=Msg
wndDeepgit.lblTextHeader"at"=at
wndDeepgit.lblTextHeader"by"=by
wndDeepgit.lblTextHeader"on"=on
wndDeepgit.mni"Copy Details"=Copy Details
wndDeepgit.mni"Copy ID"=Copy ID
wndDeepgit.mni"Copy Selection in Column"=Copy Selection in Column
wndDeepgit.mni"Copy Selection"=Copy Selection
wndDeepgit.mni"Copy"=Copy
wndDeepgit.mni"File"=File
wndDeepgit.mni"Modifications"=Modifications
wndDeepgit.mni"Open File Log"=打开文件日志
wndDeepgit.mni"Open Repository Log"=打开仓库日志
wndDeepgit.mniAbout=关于 DeepGit
wndDeepgit.mniBack=回退
wndDeepgit.mniConfigureRefGroups=引用标签分组
wndDeepgit.mniEdit-copy=复制
wndDeepgit.mniExtendLineToBlock=将线延伸到块
wndDeepgit.mniFile-close=关闭
wndDeepgit.mniFilterAddSelection=将选定内容添加到筛选器
wndDeepgit.mniFilterReset=重置筛选器
wndDeepgit.mniFilterSetSelection=将选定内容设置为筛选器
wndDeepgit.mniFollowRenames=关注重命名
wndDeepgit.mniForward=前进
wndDeepgit.mniGoto-line=转到行
wndDeepgit.mniGoto-next-diff=下一处差异
wndDeepgit.mniGoto-previous-diff=上一处差异
wndDeepgit.mniHighlightBlameChanges=高亮当前追溯提交的变化
wndDeepgit.mniHighlightOriginChanges=高亮显示当前来源提交的更改
wndDeepgit.mniIgnoreWhitespaceOnlyChanges=忽略空白更改
wndDeepgit.mniLicenseAgreement=许可协议
wndDeepgit.mniNextChange=下一处更改
wndDeepgit.mniOpenFileLog=打开文件日志
wndDeepgit.mniOpenRepositoryLog=打开仓库日志
wndDeepgit.mniOptimizeCreationOrigins=优化 “出现在这里” 的来源
wndDeepgit.mniPerspectiveBlameOrigin=追溯起源视角
wndDeepgit.mniPerspectiveBlameSimple=追溯视角
wndDeepgit.mniPerspectiveCommit=记录视角
wndDeepgit.mniPerspectiveHistory=比较透视
wndDeepgit.mniPerspectiveOrigins=起源视角
wndDeepgit.mniPreviousChange=上一处更改
wndDeepgit.mniResetInlineHelp=重新显示所有内联帮助
wndDeepgit.mniSearch-find=查找
wndDeepgit.mniSearch-next=查找下一个
wndDeepgit.mniSearch-previous=查找上一个
wndDeepgit.mniSetEncoding=编码
wndDeepgit.mniShowAtRefs=Show At Refs
wndDeepgit.mniShowLinePrefixes=显示行前缀
wndDeepgit.mniShowOnRefs=显示引用
wndDeepgit.mniToggleLineHistory=行历史记录
wndDeepgit.mniViewToolbar=显示工具栏
wndDeepgit.mniWindowHorizontalLayout=水平追溯起源布局
wndDeepgit.mniWindowVerticalLayout=垂直追溯起源布局
wndDeepgit.mnu"Edit"=编辑
wndDeepgit.mnu"File"=文件
wndDeepgit.mnu"Go To"=转到
wndDeepgit.mnu"Help"=帮助
wndDeepgit.mnu"View"=视图
wndDeepgit.tab"Files \(in progress\)"=Files \(in progress\)
wndDeepgit.tab"Files changed in commit $1"=Files changed in commit $1
wndDeepgit.tab"Navigation \(initializing...\)"=Navigation \(initializing...\)
wndDeepgit.tab"Navigation"=Navigation
wndDeepgit.tab"Origin Candidates \($1 hunks processed...\)"=Origin Candidates \($1 hunks processed...\)
wndDeepgit.tab"Origin Candidates \(in progress\)"=Origin Candidates \(in progress\)
wndDeepgit.tab"Origin Candidates for line $1 of commit $2"=\
 Origin Candidates for line $1 of commit $2
wndDeepgit.tab"Origin Candidates"=Origin Candidates
wndDeepgit.tbr"Back"=后退
wndDeepgit.tbr"Blame"=追溯
wndDeepgit.tbr"Blame+Origins"=追溯起源
wndDeepgit.tbr"Diff"=差异
wndDeepgit.tbr"Forward"=向前
wndDeepgit.tbr"Log"=日志
wndDeepgit.tbr"Origins"=起源
wndDeepgit.tbt"Go to next change."=Go to next change.
wndDeepgit.tbt"Go to previous change."=Go to previous change.
wndDeepgit.tbtBack=Go back to previous blame...
wndDeepgit.tbtForward=Go forward to next blame...
wndDeepgit.tbtPerspectiveBlameOrigin=在需要从一个可能的起源中进行选择的情况下，查找线的起源位置。
wndDeepgit.tbtPerspectiveBlameSimple=在没有替代起源的情况下，在简单的情况下找到线的起源。
wndDeepgit.tbtPerspectiveCommit=调查记录。
wndDeepgit.tbtPerspectiveHistory=调查文件修订之间的差异。
wndDeepgit.tbtPerspectiveOrigins=找出该行的起源处所发生的其他情况。\n\n 为了检查可用的原点，必须首先对其进行评估。首先，使用文件\|打开选择要调查的文件，并选择其中的一行。然后等到可能原点的计算完成。
wndEditor.mni"CR \(classic macOS\)"=CR \(经典 macOS 系统\)
wndEditor.mni"CR+LF \(Windows\)"=CR+LF \(Windows 系统\)
wndEditor.mni"LF \(Unix, macOS\)"=LF \(Unix, macOS 系统\)
wndEditor.mniEdit-undo=撤销
wndEditor.mniEofEnforceLineEnding=在文件末尾强制使用行尾
wndEditor.mniReplaceTabsWithSpaces=将制表符 \(Tab\) 替换为空格
wndEditor.mniView-remember-as-default=记住为默认值
wndEditor.mniView-settings=设置
wndEditor.tbtFile-save=保存文件修改。
wndGit.indexEditor.mni"Discard Inner-line Change"=丢弃内线变更
wndGit.indexEditor.mni"Discard Line"=丢弃线
wndGit.indexEditor.mni"Discard Selection"=丢弃选择
wndGit.indexEditor.mni"Stage Inner-line Change"=暂存内线变更
wndGit.indexEditor.mni"Stage Line"=暂存线
wndGit.indexEditor.mni"Stage Selection"=暂存选择
wndGit.indexEditor.mni"Unstage Inner-line Change"=取消暂存内线变更
wndGit.indexEditor.mni"Unstage Line"=取消暂存线
wndGit.indexEditor.mni"Unstage Selection"=取消暂存选择
wndGit.indexEditor.mniView-layout-all=所有
wndGit.indexEditor.mniView-layout-head-index=HEAD 和 Index
wndGit.indexEditor.mniView-layout-head-index-wt=所有
wndGit.indexEditor.mniView-layout-head-wt-above-index=HEAD 和工作区在 Index 上方
wndGit.indexEditor.mniView-layout-index-wt=Index 和工作区
wndGit.indexEditor.mniView-layout-left-merge=左合并
wndGit.indexEditor.mniView-layout-left-right-above-merge=左右合并
wndGit.indexEditor.mniView-layout-right-merge=右合并
wndGit.indexEditor.tbtEdit-take-left=将左侧块移至合并结果。根据左侧块，这将在合并结果处插入，替换或删除。
wndGit.indexEditor.tbtEdit-take-right=Take the right block to the merge result. Depending on the right block, this will insert, replace or delete at the merge result.
wndGit.indexEditor.tbtFile-save=Save file modifications.
wndGit.indexEditor.tbtGoto-next-diff=下一处更改。
wndGit.indexEditor.tbtGoto-previous-diff=上一处更改。
wndLog.col"LFS"=LFS
wndLog.mni"Cherry-Pick $1 to '$2'"=Cherry-Pick $1 to '$2'
wndLog.mni"Committer Abbreviated"=Committer Abbreviated
wndLog.mni"Committer Avatar"=Committer Avatar
wndLog.mni"Committer with Full Name and Email"=\
 Committer with Full Name and Email
wndLog.mni"Committer with Full Name"=Committer with Full Name
wndLog.mni"Copy Branch"=Copy Branch
wndLog.mni"Copy Email Address"=Copy Email Address
wndLog.mni"Modification"=Modification
wndLog.mni"Select Branch"=Select Branch
wndLog.mni"Select Commit"=Select Commit
wndLog.mni"Send Mail"=Send Mail
wndLog.mni"Unstage Hunk"=Unstage Hunk
wndLog.mni"Unstage Innerline Change"=Unstage Innerline Change
wndLog.mni"Unstage Line"=Unstage Line
wndLog.mni"Unstage Selection"=Unstage Selection
wndLog.mniRemoteFetchAll=Fetch All
wndLog.mniRepositoryFavorite"Mark as Favorite"=Mark as Favorite
wndLog.mniRepositoryFavorite"Unmark as Favorite"=Unmark as Favorite
wndLog.tab"Changes \(EOL: Windows\)"=Changes \(EOL: Windows\)
wndLog.tbt"If selected and Index as well as Working Tree changes are available, show them separately."=\
 If selected and Index as well as Working Tree changes are available, show them separately.
wndLog.tbt"Reading incoming pull requests from '$1'."=\
 Reading incoming pull requests from '$1'.
wndLog.tbt"Refresh information from Bitbucket."=Refresh information from Bitbucket.
wndProject.mni"Log Selection"=Log Selection
wndProject.mniRemoteFetchAll=Fetch All
wnd(Annotate|Compare|ConflictSolver|Deepgit|Git.indexEditor|Editor|Log|Project|Std).lblStatusBarMessage"Ready"=就绪
wnd(Annotate|Compare|ConflictSolver|Deepgit|Git.indexEditor|Editor|Log|Project|Std).mniWindow-fullScreen=全屏
wnd(Annotate|Compare|ConflictSolver|Deepgit|Git.indexEditor|Editor|Log|Project|Std).mniWindow-maximizeMaximize=最大化
wnd(Annotate|Compare|ConflictSolver|Deepgit|Git.indexEditor|Editor|Log|Project|Std).mniWindow-maximizeRestore=还原
wnd(Annotate|Compare|ConflictSolver|Deepgit|Git.indexEditor|Editor|Log|Project|Std).mniWindow-minimize=最小化
wnd(Annotate|Compare|ConflictSolver|Deepgit|Git.indexEditor|Editor|Log|Project|Std).mniWindowMaximizeRestore"Maximize View"=最大化视图
wnd(Annotate|Compare|ConflictSolver|Deepgit|Git.indexEditor|Editor|Log|Project|Std).mniWindowMaximizeRestore"Restore Maximized View"=还原视图
wnd(Annotate|Compare|ConflictSolver|Deepgit|Git.indexEditor|Editor|Log|Project|Std).mnu"< No Windows >"=< 无窗口 >
wnd(Annotate|Compare|ConflictSolver|Deepgit|Git.indexEditor|Editor|Log|Project|Std).mnu"Window"=窗口
wnd(Compare|ConflictSolver|Git.indexEditor).mniEdit-take-left=使用左边文件块
wnd(Compare|ConflictSolver|Git.indexEditor).mniEdit-take-left-right=使用左边文件块，然后使用右边文件块
wnd(Compare|ConflictSolver|Git.indexEditor).mniEdit-take-right=使用右边文件块
wnd(Compare|ConflictSolver|Git.indexEditor).mniEdit-take-right-left=使用右边文件块，然后使用左边文件块
wnd(Compare|ConflictSolver|Git.indexEditor).mniEdit-undo=撤销
wnd(Compare|ConflictSolver|Git.indexEditor).mniFile-export-html=导出为 HTML 文件
wnd(Compare|ConflictSolver|Git.indexEditor).mniFile-open-base=打开基本文件更改
wnd(Compare|ConflictSolver|Git.indexEditor).mniGoto-next-conflict=下一处冲突
wnd(Compare|ConflictSolver|Git.indexEditor).mniGoto-next-diff=下一处差异
wnd(Compare|ConflictSolver|Git.indexEditor).mniGoto-previous-conflict=上一处冲突
wnd(Compare|ConflictSolver|Git.indexEditor).mniGoto-previous-diff=上一处差异
wnd(Compare|ConflictSolver|Git.indexEditor).mniShow-line-numbers=显示行号
wnd(Compare|ConflictSolver|Git.indexEditor).mniView-ignore-whitespaces-all=忽略所有空白字符变化
wnd(Compare|ConflictSolver|Git.indexEditor).mniView-ignore-whitespaces-leading-trailing=忽略前导/尾随空格以进行行比较
wnd(Compare|ConflictSolver|Git.indexEditor).mniView-ignore-whitespaces-none=忽略没有用于行比较的空格
wnd(Compare|ConflictSolver|Git.indexEditor).mniView-refresh=刷新
wnd(Compare|ConflictSolver|Git.indexEditor).mniView-remember-as-default=记住默认
wnd(Compare|ConflictSolver|Git.indexEditor).mniView-settings=设置
wnd(Compare|ConflictSolver|Git.indexEditor).mniView-show-current-line-control=显示长的当前行
wnd(Compare|ConflictSolver|Git.indexEditor).mniView-synchronize-scrolling=同步滚动
wnd(Compare|ConflictSolver|Git.indexEditor).tbr"Next Change"=下一处差异
wnd(Compare|ConflictSolver|Git.indexEditor).tbr"Prev. Change"=上一处差异
wnd(Compare|ConflictSolver|Git.indexEditor).tbr"Reload"=重新加载
wnd(Compare|ConflictSolver|Git.indexEditor).tbr"Take Left"=左边
wnd(Compare|ConflictSolver|Git.indexEditor).tbr"Take Right"=右边
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mni"Copy Selection"=复制选中
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniCustomize=自定义
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniEdit-copy=复制
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniEdit-cut=剪切
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniEdit-ignore-case-changes=忽略行比较的大小写更改
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniEdit-paste=粘贴
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniEdit-redo=重做
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniFile-close=关闭
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniFile-save=保存
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniGoto-line=转到行
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniSearch-find=查找
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniSearch-next=查找下一个
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniSearch-previous=查找上一个
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniSearch-replace=查找并替换
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mniSet-syntax=语法语言
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mnu"Edit"=编辑
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mnu"File"=文件
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mnu"Go To"=转到
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).mnu"View"=视图
wnd(Compare|ConflictSolver|Git.indexEditor|Editor).tbr"Save"=保存
wnd(Log|Project|Std)."Abort"=中止
wnd(Log|Project|Std)."Commit"=提交
wnd(Log|Project|Std)."Conflict Solver"=冲突解决器
wnd(Log|Project|Std)."Continue"=继续
wnd(Log|Project|Std)."Mark HEAD as Bad"=将 HEAD 标记为坏的
wnd(Log|Project|Std)."Mark HEAD as Good"=将 HEAD 标记为好的
wnd(Log|Project|Std)."Mark Resolved"=标记已解决
wnd(Log|Project|Std)."Recreate Conflict"=重现冲突
wnd(Log|Project|Std)."Rerun Thoroughly"=完全重运行
wnd(Log|Project|Std)."Reset"=重置
wnd(Log|Project|Std)."Reveal"=展示
wnd(Log|Project|Std)."Show Local Changes"=显示本地更改
wnd(Log|Project|Std)."Step"=步骤
wnd(Log|Project|Std)."Swap"=交换
wnd(Log|Project|Std)."Take Ours"=采用 我们的
wnd(Log|Project|Std)."Take Theirs"=采用 他们的
wnd(Log|Project|Std).btn"Abort"=中止
wnd(Log|Project|Std).btn"Commit"=提交
wnd(Log|Project|Std).btn"Conflict Solver"=冲突解决器
wnd(Log|Project|Std).btn"Continue"=继续
wnd(Log|Project|Std).btn"Mark HEAD as Bad"=将 HEAD 标记为坏的
wnd(Log|Project|Std).btn"Mark HEAD as Good"=将 HEAD 标记为好的
wnd(Log|Project|Std).btn"Mark Resolved"=标记已解决
wnd(Log|Project|Std).btn"Recreate Conflict"=重现冲突
wnd(Log|Project|Std).btn"Rerun Thoroughly"=完全重运行
wnd(Log|Project|Std).btn"Reset"=重置
wnd(Log|Project|Std).btn"Reveal"=展示
wnd(Log|Project|Std).btn"Show Local Changes"=显示本地更改
wnd(Log|Project|Std).btn"Stage"=暂存
wnd(Log|Project|Std).btn"Step"=步骤
wnd(Log|Project|Std).btn"Swap"=交换
wnd(Log|Project|Std).btn"Take Ours"=采用 我们的
wnd(Log|Project|Std).btn"Take Theirs"=采用 他们的
wnd(Log|Project|Std).chk"Add 'Signed-off-by' signature"=添加 'Signed-off-by' 签名
wnd(Log|Project|Std).chk"Amend last commit instead of creating new one"=\
 修订最后一次提交而不是创建新提交
wnd(Log|Project|Std).chk"Amend last commit"=修订最后一次提交
wnd(Log|Project|Std).chk"Bypass commit hook"=忽略提交钩子
wnd(Log|Project|Std).chk"Create simple commit \('squash'\)"=生成简单提交 \('压缩'\)
wnd(Log|Project|Std).chk"Push"=推送
wnd(Log|Project|Std).col"Assignee"=代理人
wnd(Log|Project|Std).col"Author"=作者
wnd(Log|Project|Std).col"Branch"=分支
wnd(Log|Project|Std).col"Copied From"=复制自
wnd(Log|Project|Std).col"Copied from"=复制自
wnd(Log|Project|Std).col"Date"=日期
wnd(Log|Project|Std).col"Entry"=登记
wnd(Log|Project|Std).col"Ext."=扩展名
wnd(Log|Project|Std).col"Index State"=索引状态
wnd(Log|Project|Std).col"Last Changed On"=最后更改于
wnd(Log|Project|Std).col"Modification"=修改
wnd(Log|Project|Std).col"Name"=名称
wnd(Log|Project|Std).col"Path"=路径
wnd(Log|Project|Std).col"Relative Directory"=相对目录
wnd(Log|Project|Std).col"Relative Path"=相对路径
wnd(Log|Project|Std).col"Renamed Path"=重命名路径
wnd(Log|Project|Std).col"Size"=大小
wnd(Log|Project|Std).col"State"=状态
wnd(Log|Project|Std).col"Submodule"=子模块
wnd(Log|Project|Std).col"Text"=文本
wnd(Log|Project|Std).col"Working Tree State"=工作区状态
wnd(Log|Project|Std).edt"Commit to"=提交到
wnd(Log|Project|Std).hnt"File Filter"=文件过滤器
wnd(Log|Project|Std).hnt"Filter or Tag Search"=过滤器或标签搜索
wnd(Log|Project|Std).lbl"$1 files hidden"=$1 个隐藏文件
wnd(Log|Project|Std).lbl"Directories"=目录
wnd(Log|Project|Std).lbl"Directory"=目录
wnd(Log|Project|Std).lbl"File"=文件
wnd(Log|Project|Std).lbl"Files"=文件
wnd(Log|Project|Std).lblStatusBarMessage"$1"=$1
wnd(Log|Project|Std).mni"  Show Rewritten Behind Commits"=\
 在提交后显示重写
wnd(Log|Project|Std).mni"<no entry>"=< 禁止输入 >
wnd(Log|Project|Std).mni"<none>"=<无>
wnd(Log|Project|Std).mni"Abbreviated"=简短的
wnd(Log|Project|Std).mni"Add GitHub Comment"=创建 GitHub 注释
wnd(Log|Project|Std).mni"Add GitLab Comment"=创建 GitLab 注释
wnd(Log|Project|Std).mni"Add Review Comment"=创建审阅注释
wnd(Log|Project|Std).mni"All"=所有
wnd(Log|Project|Std).mni"Apply Patch"=应用补丁
wnd(Log|Project|Std).mni"Assign"=分配
wnd(Log|Project|Std).mni"Assignee"=申请人
wnd(Log|Project|Std).mni"Author Abbreviated"=作者缩写
wnd(Log|Project|Std).mni"Author Avatar"=作者头像
wnd(Log|Project|Std).mni"Author with Full Name and Email"=\
 作者全名和电子邮件
wnd(Log|Project|Std).mni"Author with Full Name"=作者全名
wnd(Log|Project|Std).mni"Author"=作者
wnd(Log|Project|Std).mni"Branch Coloring"=分支着色
wnd(Log|Project|Std).mni"Branches and Tags"=分支和标签
wnd(Log|Project|Std).mni"Branching:"=分支：
wnd(Log|Project|Std).mni"Cancel"=取消
wnd(Log|Project|Std).mni"Check Out"=检出
wnd(Log|Project|Std).mni"Checkout"=检出
wnd(Log|Project|Std).mni"Cherry-Pick Commits to $1"=摘取提交至 $1
wnd(Log|Project|Std).mni"Clear History"=清除历史记录
wnd(Log|Project|Std).mni"Close"=关闭
wnd(Log|Project|Std).mni"Coloring:"=着色：
wnd(Log|Project|Std).mni"Columns"=列
wnd(Log|Project|Std).mni"Columns:"=列：
wnd(Log|Project|Std).mni"Comment $1"=评论 $1
wnd(Log|Project|Std).mni"Commit"=提交
wnd(Log|Project|Std).mni"Committer"=修订者
wnd(Log|Project|Std).mni"Compact Author"=紧凑作者
wnd(Log|Project|Std).mni"Copy Full ID"=复制完整 ID
wnd(Log|Project|Std).mni"Copy ID"=复制 ID
wnd(Log|Project|Std).mni"Copy Name"=复制名称
wnd(Log|Project|Std).mni"Copy Selection in Column"=复制列中的所选内容
wnd(Log|Project|Std).mni"Copy Selection"=复制选择
wnd(Log|Project|Std).mni"Copy URL"=复制 URL
wnd(Log|Project|Std).mni"Copy"=复制
wnd(Log|Project|Std).mni"Create Merge Request"=创建合并请求
wnd(Log|Project|Std).mni"Create Pull Request"=创建拉取请求
wnd(Log|Project|Std).mni"Cut"=剪切
wnd(Log|Project|Std).mni"Date"=日期
wnd(Log|Project|Std).mni"Default Coloring"=默认着色
wnd(Log|Project|Std).mni"Delete 'Comment $1'"=删除 '评论 $1'
wnd(Log|Project|Std).mni"Delete"=删除
wnd(Log|Project|Std).mni"Diff Tool"=差异工具
wnd(Log|Project|Std).mni"Discard Hunk"=丢弃块
wnd(Log|Project|Std).mni"Discard Inner-line Change"=丢弃内线变更
wnd(Log|Project|Std).mni"Discard Line"=丢弃行
wnd(Log|Project|Std).mni"Discard Selection"=丢弃选中
wnd(Log|Project|Std).mni"Drop Local Data"=删除本地数据
wnd(Log|Project|Std).mni"Edit 'Comment $1'"=编辑 '评论 $1'
wnd(Log|Project|Std).mni"Edit in Index Editor"=在索引编辑器中编辑
wnd(Log|Project|Std).mni"Edit"=编辑
wnd(Log|Project|Std).mni"Ext."=提取。
wnd(Log|Project|Std).mni"Fast-Forward Merge"=快进合并
wnd(Log|Project|Std).mni"Fetch Merge Request"=获取合并请求
wnd(Log|Project|Std).mni"Fetch Pull Request"=获取拉取请求
wnd(Log|Project|Std).mni"File Content \(very expensive\)"=文件内容 \(非常昂贵\)
wnd(Log|Project|Std).mni"File \(expensive\)"=文件 \(昂贵\)
wnd(Log|Project|Std).mni"Files from Subdirectories"=子目录文件
wnd(Log|Project|Std).mni"Follow All Parents"=关注所有父系
wnd(Log|Project|Std).mni"Follow Only First Parent"=只关注第一个父系
wnd(Log|Project|Std).mni"Forget Pattern"=忘记模式
wnd(Log|Project|Std).mni"Forget"=忘记
wnd(Log|Project|Std).mni"Format Patch"=格式补丁
wnd(Log|Project|Std).mni"Full Author With Email"=完整的电子邮件作者
wnd(Log|Project|Std).mni"Full Author"=完整作者
wnd(Log|Project|Std).mni"Full Name With Email"=电子邮件全名
wnd(Log|Project|Std).mni"Full Name"=全名
wnd(Log|Project|Std).mni"Git Config"=Git 配置
wnd(Log|Project|Std).mni"Git-LFS Version"=Git-LFS 版本
wnd(Log|Project|Std).mni"ID"=ID
wnd(Log|Project|Std).mni"Include Merge Only if File was Changed"=\
 仅当文件已更改时才包括合并
wnd(Log|Project|Std).mni"Integrate"=集成
wnd(Log|Project|Std).mni"Jump To"=跳转到
wnd(Log|Project|Std).mni"LFS"=LFS
wnd(Log|Project|Std).mni"Last Changed On"=最后更改于
wnd(Log|Project|Std).mni"Mark as Bad"=标记为坏的
wnd(Log|Project|Std).mni"Mark as Good"=标记为好的
wnd(Log|Project|Std).mni"Merge '$1'"=Merge '$1'
wnd(Log|Project|Std).mni"Merge Directly To"=直接合并到
wnd(Log|Project|Std).mni"Merge Merge Request"=合并合并请求
wnd(Log|Project|Std).mni"Merge Pull Request"=合并拉取请求
wnd(Log|Project|Std).mni"Merge"=合并
wnd(Log|Project|Std).mni"Message"=消息
wnd(Log|Project|Std).mni"More options"=更多选项
wnd(Log|Project|Std).mni"Move Commit"=移动提交
wnd(Log|Project|Std).mni"Move To"=移动到
wnd(Log|Project|Std).mni"Move and Squash Commit"=移动和压缩提交
wnd(Log|Project|Std).mni"Name"=名称
wnd(Log|Project|Std).mni"Neither"=两者都不是
wnd(Log|Project|Std).mni"New Group"=创建分组
wnd(Log|Project|Std).mni"No Group"=没有分组
wnd(Log|Project|Std).mni"Only If Changed"=仅当更改时
wnd(Log|Project|Std).mni"Only Selected"=仅选中
wnd(Log|Project|Std).mni"Open in Browser"=在浏览器中打开
wnd(Log|Project|Std).mni"Open in Web Browser"=在 Web 浏览器中打开
wnd(Log|Project|Std).mni"Other Branch"=其他分支
wnd(Log|Project|Std).mni"Paste"=粘贴
wnd(Log|Project|Std).mni"Path"=路径
wnd(Log|Project|Std).mni"Please select Index or Working Tree."=\
 请选择索引或工作区。
wnd(Log|Project|Std).mni"Print Git Version"=打印 Git 版本
wnd(Log|Project|Std).mni"Pull, then Push"=拉取然后推送
wnd(Log|Project|Std).mni"Push To"=推送到
wnd(Log|Project|Std).mni"Push"=推送
wnd(Log|Project|Std).mni"Push, then Pull"=推送然后拉取
wnd(Log|Project|Std).mni"Quick Stash All"=快速贮藏所有
wnd(Log|Project|Std).mni"Quick Stash Selection"=快速贮藏选中
wnd(Log|Project|Std).mni"Rebase $1 commit from $2 to $3"=\
 将 $1 提交 从 $2 变基为 $3
wnd(Log|Project|Std).mni"Rebase $1 commits from $2 to $3"=\
 将 $1 提交 从 $2 变基为 $3
wnd(Log|Project|Std).mni"Rebase HEAD to '$1'"=Rebase HEAD to '$1'
wnd(Log|Project|Std).mni"Regular Expressions"=常用表达
wnd(Log|Project|Std).mni"Reject Pull Request"=拒绝拉取请求
wnd(Log|Project|Std).mni"Relative Directory"=相对目录
wnd(Log|Project|Std).mni"Relative Path"=相对路径
wnd(Log|Project|Std).mni"Remember Pattern"=记住模式
wnd(Log|Project|Std).mni"Rename"=重命名
wnd(Log|Project|Std).mni"Renamed Path"=重命名路径
wnd(Log|Project|Std).mni"Reorder Commits"=重新排序提交
wnd(Log|Project|Std).mni"Reply '$1'"=回复 '$1'
wnd(Log|Project|Std).mni"Reply"=回复
wnd(Log|Project|Std).mni"Reset HEAD to $1"=重置 HEAD 为 $1
wnd(Log|Project|Std).mni"Reset to Default"=重置为默认
wnd(Log|Project|Std).mni"Resolve"=解决
wnd(Log|Project|Std).mni"Retract Merge Request"=撤消合并请求
wnd(Log|Project|Std).mni"Retract Pull Request"=撤消拉取请求
wnd(Log|Project|Std).mni"Revert $1"=撤销 $1
wnd(Log|Project|Std).mni"Review"=评阅
wnd(Log|Project|Std).mni"Rewrap"=重新包装
wnd(Log|Project|Std).mni"Select from JIRA"=从 JIRA 中选择
wnd(Log|Project|Std).mni"Select from Log"=从日志中选择
wnd(Log|Project|Std).mni"Set '$1' to $2"=设置 '$1' 为 $2
wnd(Log|Project|Std).mni"Show All Refs"=显示所有参考
wnd(Log|Project|Std).mni"Show Auxiliary Branch"=显示辅助分支
wnd(Log|Project|Std).mni"Show Branch Labels"=显示分支标签
wnd(Log|Project|Std).mni"Show Common Commits"=显示共同提交
wnd(Log|Project|Std).mni"Show Incoming Commits"=显示传入提交
wnd(Log|Project|Std).mni"Show More Commits \(Temporarily\)"=显示更多提交 \(暂时\)
wnd(Log|Project|Std).mni"Show Only Selected Branches and Tags"=\
 仅显示选定的分支和标签
wnd(Log|Project|Std).mni"Show Only Selected Refs"=仅显示选定的参考
wnd(Log|Project|Std).mni"Show Unchanged Directories"=显示未更改的目录
wnd(Log|Project|Std).mni"Show Working Tree On Demand"=按需显示工作区
wnd(Log|Project|Std).mni"Show Working Tree Permanently"=永久显示工作区
wnd(Log|Project|Std).mni"Size"=大小
wnd(Log|Project|Std).mni"Sort By Time"=按时间排序
wnd(Log|Project|Std).mni"Sort First Parents before Merge Parents"=\
 Sort First Parents before Merge Parents
wnd(Log|Project|Std).mni"Sort Merge Parents before First Parents"=\
 Sort Merge Parents before First Parents
wnd(Log|Project|Std).mni"Squash"=压缩
wnd(Log|Project|Std).mni"Stage Hunk"=暂存大块
wnd(Log|Project|Std).mni"Stage Inner-line Change"=暂存内线更改
wnd(Log|Project|Std).mni"Stage Innerline Change"=暂存内线更改
wnd(Log|Project|Std).mni"Stage Line"=暂存此行
wnd(Log|Project|Std).mni"Stage Lines"=暂存这些行
wnd(Log|Project|Std).mni"Stage Selection"=暂存选中
wnd(Log|Project|Std).mni"Stash Selection"=贮藏选中
wnd(Log|Project|Std).mni"State"=状态
wnd(Log|Project|Std).mni"Subtree"=子树
wnd(Log|Project|Std).mni"Template!"=模板！
wnd(Log|Project|Std).mni"Test"=测试
wnd(Log|Project|Std).mni"Text"=文本
wnd(Log|Project|Std).mni"Toggle Hosting Provider Integration"=切换托管服务提供商集成
wnd(Log|Project|Std).mni"Toggle"=切换
wnd(Log|Project|Std).mni"Varying Coloring"=变色
wnd(Log|Project|Std).mniAbout=关于 SmartGit
wnd(Log|Project|Std).mniAdd=创建
wnd(Log|Project|Std).mniAnnotate=追溯
wnd(Log|Project|Std).mniAssume-unchanged-toggle=切换 “假设不变”
wnd(Log|Project|Std).mniBisectBad=将 HEAD 标记为坏的
wnd(Log|Project|Std).mniBisectExit=重置
wnd(Log|Project|Std).mniBisectGood=将 HEAD 标记为好的
wnd(Log|Project|Std).mniBisectStart=开始
wnd(Log|Project|Std).mniBranchAbort=中止分支
wnd(Log|Project|Std).mniBranchAdd=创建分支
wnd(Log|Project|Std).mniBranchAddTag=创建标签
wnd(Log|Project|Std).mniBranchClose=关闭
wnd(Log|Project|Std).mniBranchContinue=继续
wnd(Log|Project|Std).mniBranchDelete=删除分支
wnd(Log|Project|Std).mniBranchRename=重命名
wnd(Log|Project|Std).mniBranchResetTracking=停止跟踪
wnd(Log|Project|Std).mniBranchSetTracking=设置跟踪分支
wnd(Log|Project|Std).mniBranchSplit=修改或拆分提交
wnd(Log|Project|Std).mniBranchSplitFiles=拆分文件
wnd(Log|Project|Std).mniBranchesGitFlowRemoteOnly=在 Git 工作流部分显示远程分支
wnd(Log|Project|Std).mniBranchesGitFlowTracked=显示远程，跟踪分支
wnd(Log|Project|Std).mniBranchesSectionize=按路径名称分组标签和分支 (foo/bar)
wnd(Log|Project|Std).mniBranchesSectionizeAfterLastSlash=在最后一个斜杠后
wnd(Log|Project|Std).mniBranchesSectionizeCompact=除了单项
wnd(Log|Project|Std).mniBranchesSectionsBeforeRefs=优先显示组
wnd(Log|Project|Std).mniBranchesSelectObsolete=选择过时的本地分支
wnd(Log|Project|Std).mniBranchesSortByName=按名称排序参考
wnd(Log|Project|Std).mniBranchesSortByNameReversed=按名称排序参考 (数字反转)
wnd(Log|Project|Std).mniBranchesSortByTime=按提交时间排序参考
wnd(Log|Project|Std).mniChangesView.compact=压缩
wnd(Log|Project|Std).mniChangesView.ignoreLineSeparators=忽略行尾更改
wnd(Log|Project|Std).mniChangesView.sideBySide=并排
wnd(Log|Project|Std).mniChangesView.unified=统一
wnd(Log|Project|Std).mniCheckForLatestBuild=检查更新 \(编译版本\)
wnd(Log|Project|Std).mniCheckForNewVersion=检查更新
wnd(Log|Project|Std).mniCheckout=检出
wnd(Log|Project|Std).mniCherryPick=摘取
wnd(Log|Project|Std).mniClean=清理工作区
wnd(Log|Project|Std).mniClearOutput=清理输出
wnd(Log|Project|Std).mniCommit=提交
wnd(Log|Project|Std).mniCompact-display=紧凑型显示
wnd(Log|Project|Std).mniCompareWithWorkingTree=与工作区比较
wnd(Log|Project|Std).mniConfigureTagGrouping=标签分组
wnd(Log|Project|Std).mniConfigureToolbar=配置工具栏
wnd(Log|Project|Std).mniConflictSolver=冲突解决器
wnd(Log|Project|Std).mniContactSupport=技术支持
wnd(Log|Project|Std).mniCopyCommitId=复制 ID
wnd(Log|Project|Std).mniCopyCommitMessage=复制消息
wnd(Log|Project|Std).mniCopyName=复制文件名
wnd(Log|Project|Std).mniCopyPath=复制路径
wnd(Log|Project|Std).mniCopyRelativePath=复制相对路径
wnd(Log|Project|Std).mniCustomize=自定义
wnd(Log|Project|Std).mniDebugCreateHeapDump=创建堆转储
wnd(Log|Project|Std).mniDebugCreateThreadDumps=创建定期线程转储
wnd(Log|Project|Std).mniDebugEnableRefreshTraceLogging=开始跟踪刷新
wnd(Log|Project|Std).mniDebugLogFileMonitorEvents=记录文件监控事件
wnd(Log|Project|Std).mniDebugLogFileMonitorState=记录文件监控状态
wnd(Log|Project|Std).mniDebugLogOpenRepositories=记录打开仓库
wnd(Log|Project|Std).mniDebugRestart=重新开始
wnd(Log|Project|Std).mniDebugRunGc=运行垃圾回收 \(GC\)
wnd(Log|Project|Std).mniDelete=删除
wnd(Log|Project|Std).mniDiscard=丢弃
wnd(Log|Project|Std).mniEdit-ignore-case-changes=忽略行比较的大小写更改
wnd(Log|Project|Std).mniEditCommitAuthor=编辑作者
wnd(Log|Project|Std).mniEditCommitMessage=编辑提交消息
wnd(Log|Project|Std).mniEditFile=编辑文件
wnd(Log|Project|Std).mniExit=退出
wnd(Log|Project|Std).mniFastForward=快进合并
wnd(Log|Project|Std).mniFetch=拉取
wnd(Log|Project|Std).mniFile-close=关闭
wnd(Log|Project|Std).mniFilterCommits=过滤提交
wnd(Log|Project|Std).mniFilterFiles=过滤文件
wnd(Log|Project|Std).mniFindAction=查找命令
wnd(Log|Project|Std).mniFindObject=查找对象
wnd(Log|Project|Std).mniFixup=修复
wnd(Log|Project|Std).mniFlowConfigure=配置
wnd(Log|Project|Std).mniFlowContext=Git 工作流
wnd(Log|Project|Std).mniFlowFeatureFinish=完成 Feature
wnd(Log|Project|Std).mniFlowFeatureStart=开始 Feature
wnd(Log|Project|Std).mniFlowHotfixFinish=完成 Hotfix
wnd(Log|Project|Std).mniFlowHotfixStart=开始 Hotfix
wnd(Log|Project|Std).mniFlowIntegrateDevelop=整合开发
wnd(Log|Project|Std).mniFlowReleaseFinish=完成 Release
wnd(Log|Project|Std).mniFlowReleaseStart=开始 Release
wnd(Log|Project|Std).mniFlowSupportStart=开始 Support 分支
wnd(Log|Project|Std).mniForgetCommit=忘记提交
wnd(Log|Project|Std).mniGoto-next-diff=下一处差异
wnd(Log|Project|Std).mniGoto-previous-diff=上一处差异
wnd(Log|Project|Std).mniGotoChildrenCommit=选择子提交
wnd(Log|Project|Std).mniGotoParentsCommit=选择父提交
wnd(Log|Project|Std).mniIgnore=忽略
wnd(Log|Project|Std).mniIgnore-line-separators=忽略行尾更改
wnd(Log|Project|Std).mniIgnoreReveal=编辑忽略文件
wnd(Log|Project|Std).mniIncludeTrackedRemoteBranches=包括跟踪远程分支
wnd(Log|Project|Std).mniIndexEditor=索引编辑器
wnd(Log|Project|Std).mniInvestigate=调查
wnd(Log|Project|Std).mniLfsInstall=安装
wnd(Log|Project|Std).mniLfsLock=加锁
wnd(Log|Project|Std).mniLfsPrune=修剪
wnd(Log|Project|Std).mniLfsTrack=跟踪
wnd(Log|Project|Std).mniLfsUnlock=解锁
wnd(Log|Project|Std).mniLicenseAgreement=许可协议
wnd(Log|Project|Std).mniLocalGc=运行垃圾收集器
wnd(Log|Project|Std).mniLog=日志
wnd(Log|Project|Std).mniLogCommitsColoringBranch=分支着色
wnd(Log|Project|Std).mniLogCommitsColoringDefault=默认着色
wnd(Log|Project|Std).mniLogCommitsColoringLegacy=变色
wnd(Log|Project|Std).mniLogCommitsColoringMerge=可合并着色
wnd(Log|Project|Std).mniLogRepository=日志窗口
wnd(Log|Project|Std).mniLogShowAllParents=关注所有父系
wnd(Log|Project|Std).mniLogShowOnlyFirstParents=只显示第一个父系
wnd(Log|Project|Std).mniLogTopoFiltering=筛选时显示图形
wnd(Log|Project|Std).mniLogWorkingTreeIndexOnDemand=按需显示工作区索引
wnd(Log|Project|Std).mniLogWorkingTreeIndexPermanent=永久显示工作区索引
wnd(Log|Project|Std).mniMailingList=SmartGit 官方网站
wnd(Log|Project|Std).mniMerge=合并
wnd(Log|Project|Std).mniModifyCommit=修改
wnd(Log|Project|Std).mniNewStandardWindow=显示标准窗口
wnd(Log|Project|Std).mniNewWindow=新窗口
wnd(Log|Project|Std).mniOpen=打开
wnd(Log|Project|Std).mniOpenDocumentation=在线文档
wnd(Log|Project|Std).mniOpenRootLog=打开根日志
wnd(Log|Project|Std).mniOpenUserEcho=功能请求
wnd(Log|Project|Std).mniOpenWorkingTree=打开工作区
wnd(Log|Project|Std).mniPreferences=偏好设置
wnd(Log|Project|Std).mniPreviewCommentNext=下一条注释
wnd(Log|Project|Std).mniPreviewCommentPrevious=上一条注释
wnd(Log|Project|Std).mniPreviewCompareAutomatic=自动
wnd(Log|Project|Std).mniPreviewCompareHeadVsIndex=HEAD 与索引
wnd(Log|Project|Std).mniPreviewCompareIndexVsWT=索引与工作区
wnd(Log|Project|Std).mniPreviewRefresh=重载
wnd(Log|Project|Std).mniPreviewShowCurrentLines=显示长的当前行
wnd(Log|Project|Std).mniPreviewUndo=撤销
wnd(Log|Project|Std).mniPush=推送
wnd(Log|Project|Std).mniPushCommits=推送提交
wnd(Log|Project|Std).mniPushTo=推送到
wnd(Log|Project|Std).mniPushToGerrit=推送到 Gerrit
wnd(Log|Project|Std).mniRebaseAbort=中止
wnd(Log|Project|Std).mniRebaseContinue=继续
wnd(Log|Project|Std).mniRebaseHeadTo=将 HEAD 变基到
wnd(Log|Project|Std).mniRebaseInteractive=交互式变基至
wnd(Log|Project|Std).mniRebaseSkip=跳过
wnd(Log|Project|Std).mniRebaseStep=步骤
wnd(Log|Project|Std).mniRebaseToHead=变基为 HEAD
wnd(Log|Project|Std).mniRebaseToHead"Rebase to HEAD \($1\)"=变基为 HEAD \($1\)
wnd(Log|Project|Std).mniRebaseToHead"Rebase to HEAD"=变基为 HEAD
wnd(Log|Project|Std).mniRefresh=刷新
wnd(Log|Project|Std).mniRegister=注册产品
wnd(Log|Project|Std).mniRemoteAdd=创建
wnd(Log|Project|Std).mniRemoteCopyUrl=复制网址
wnd(Log|Project|Std).mniRemoteDelete=删除
wnd(Log|Project|Std).mniRemoteFetch=获取
wnd(Log|Project|Std).mniRemoteFetchMore=获取更多
wnd(Log|Project|Std).mniRemoteProperties=属性
wnd(Log|Project|Std).mniRemoteRename=重命名
wnd(Log|Project|Std).mniRemove=移除
wnd(Log|Project|Std).mniRename=重命名
wnd(Log|Project|Std).mniRepositoryAdd=添加或创建
wnd(Log|Project|Std).mniRepositoryAddGroup=创建分组
wnd(Log|Project|Std).mniRepositoryClone=克隆
wnd(Log|Project|Std).mniRepositoryClose=关闭
wnd(Log|Project|Std).mniRepositoryEditConfig=仓库
wnd(Log|Project|Std).mniRepositoryEditConfigUser=用户
wnd(Log|Project|Std).mniRepositoryFavorite=取消标记为收藏夹
wnd(Log|Project|Std).mniRepositoryOpen=打开仓库
wnd(Log|Project|Std).mniRepositoryOpenInNewWindow=在新窗口中打开仓库
wnd(Log|Project|Std).mniRepositoryRemove=删除
wnd(Log|Project|Std).mniRepositoryRename=重命名
wnd(Log|Project|Std).mniRepositorySearch=搜索仓库
wnd(Log|Project|Std).mniRepositorySelectObsolete=选择过时的仓库
wnd(Log|Project|Std).mniRepositorySettings=设置
wnd(Log|Project|Std).mniReset=重置提交
wnd(Log|Project|Std).mniResetAdvanced=重置提交 \(高级\)
wnd(Log|Project|Std).mniResolve=解决
wnd(Log|Project|Std).mniResolveOurs=采用 我们的
wnd(Log|Project|Std).mniResolveRecreateConflict=重现冲突
wnd(Log|Project|Std).mniResolveTheirs=采用 他们的
wnd(Log|Project|Std).mniRevealCommit=显示提交
wnd(Log|Project|Std).mniRevealCommitExtend=与选中提交比较
wnd(Log|Project|Std).mniRevealCommitWithHead=与 HEAD 比较
wnd(Log|Project|Std).mniRevealPrevCommit=显示先前的提交
wnd(Log|Project|Std).mniRevealWorkingTree=显示工作区
wnd(Log|Project|Std).mniRevert=还原
wnd(Log|Project|Std).mniReviewCommentCreate=添加注释
wnd(Log|Project|Std).mniReviewConfigure=配置
wnd(Log|Project|Std).mniReviewDumpDatabase=转储数据库
wnd(Log|Project|Std).mniReviewPullRequestCreate=创建拉取请求
wnd(Log|Project|Std).mniReviewPullRequestCreate"Create Merge Request"=创建合并请求
wnd(Log|Project|Std).mniReviewPullRequestCreate"Create Pull Request"=创建拉取请求
wnd(Log|Project|Std).mniReviewShowClosedPullRequests=显示已关闭的拉取请求
wnd(Log|Project|Std).mniReviewSync=同步
wnd(Log|Project|Std).mniRewriteTextFile=修复换行符
wnd(Log|Project|Std).mniSaveAs=另存为
wnd(Log|Project|Std).mniSearch-find=查找
wnd(Log|Project|Std).mniSearch-next=查找下一处
wnd(Log|Project|Std).mniSearch-previous=查找上一处
wnd(Log|Project|Std).mniSelectCommittableFiles=选择可提交文件
wnd(Log|Project|Std).mniSelectDirectory=选择目录
wnd(Log|Project|Std).mniSelectRoot=选择仓库根目录
wnd(Log|Project|Std).mniSet-syntax=语法语言
wnd(Log|Project|Std).mniSetDepth=设置深度
wnd(Log|Project|Std).mniShow-line-numbers=显示行号
wnd(Log|Project|Std).mniShowChanges=显示更改
wnd(Log|Project|Std).mniSkipWorkTree=切换 “跳过工作区”
wnd(Log|Project|Std).mniSortCommitsAsIs=按时间排序提交
wnd(Log|Project|Std).mniSortCommitsFirstParentsBeforeMergeParents=Sort First Parents before Merge Parents
wnd(Log|Project|Std).mniSortCommitsMergeParentsBeforeFirstParents=Sort Merge Parents before First Parents
wnd(Log|Project|Std).mniSplitCommit=拆分
wnd(Log|Project|Std).mniSquashCommits=压缩提交
wnd(Log|Project|Std).mniStage=暂存
wnd(Log|Project|Std).mniStashApply=应用贮藏
wnd(Log|Project|Std).mniStashDrop=丢弃贮藏
wnd(Log|Project|Std).mniStashRename=重命名贮藏
wnd(Log|Project|Std).mniStashSave=贮藏所有
wnd(Log|Project|Std).mniStashSaveSelection=贮藏选中
wnd(Log|Project|Std).mniSubmoduleDeactivate=停用
wnd(Log|Project|Std).mniSubmoduleDeinit=定义
wnd(Log|Project|Std).mniSubmoduleInit=初始化
wnd(Log|Project|Std).mniSubmoduleRegister=创建
wnd(Log|Project|Std).mniSubmoduleReset=重置
wnd(Log|Project|Std).mniSubmoduleSync=同步
wnd(Log|Project|Std).mniSubmoduleUnregister=注销
wnd(Log|Project|Std).mniSubtreeAdd=创建
wnd(Log|Project|Std).mniSubtreeMerge=合并
wnd(Log|Project|Std).mniSubtreePush=推送
wnd(Log|Project|Std).mniSubtreeReset=重置
wnd(Log|Project|Std).mniSubtreeSplit=拆分
wnd(Log|Project|Std).mniSync=同步
wnd(Log|Project|Std).mniUndoLastCommit=取消最后一次提交
wnd(Log|Project|Std).mniUnstage=取消暂存
wnd(Log|Project|Std).mniView-ignore-whitespaces-all=忽略所有空白字符变化
wnd(Log|Project|Std).mniView-ignore-whitespaces-leading-trailing=行比较时忽略前导/尾随空格
wnd(Log|Project|Std).mniView-ignore-whitespaces-none=行比较时忽略没有用于比较的空格
wnd(Log|Project|Std).mniView-remember-as-default=记住默认
wnd(Log|Project|Std).mniView-settings=设置
wnd(Log|Project|Std).mniView-show-current-line-control=显示长的当前行
wnd(Log|Project|Std).mniViewFromSubmodules=从子模块显示文件
wnd(Log|Project|Std).mniViewIgnored=显示忽略文件
wnd(Log|Project|Std).mniViewRecursive=来自子目录的文件
wnd(Log|Project|Std).mniViewRenameSource=显示重命名源文件
wnd(Log|Project|Std).mniViewSeparateWtAndIndex=单独的工作区和 Index
wnd(Log|Project|Std).mniViewSetAnchorCommit=设置锚点提交
wnd(Log|Project|Std).mniViewSkipped=显示跳过文件
wnd(Log|Project|Std).mniViewStaged=显示暂存文件
wnd(Log|Project|Std).mniViewStyleIndex=只有索引
wnd(Log|Project|Std).mniViewStyleMixed=混合
wnd(Log|Project|Std).mniViewStyleWorkingTree=仅工作区
wnd(Log|Project|Std).mniViewToolBar=显示工具栏
wnd(Log|Project|Std).mniViewUnchanged=显示未更改的文件
wnd(Log|Project|Std).mniViewUnchangedAssumed=显示 “假设不变” 的文件
wnd(Log|Project|Std).mniViewUnversioned=显示无版本文件
wnd(Log|Project|Std).mniWindowBranches=分支视图
wnd(Log|Project|Std).mniWindowChanges=更改视图
wnd(Log|Project|Std).mniWindowClose=关闭
wnd(Log|Project|Std).mniWindowComments=注释视图
wnd(Log|Project|Std).mniWindowCommit=提交视图
wnd(Log|Project|Std).mniWindowDebugLog=调试记录
wnd(Log|Project|Std).mniWindowDirectories=仓库视图
wnd(Log|Project|Std).mniWindowFiles=文件视图
wnd(Log|Project|Std).mniWindowGraph=图形视图
wnd(Log|Project|Std).mniWindowHideView=隐藏选中视图
wnd(Log|Project|Std).mniWindowJournal=日志视图
wnd(Log|Project|Std).mniWindowLayoutSetMain=主要审阅
wnd(Log|Project|Std).mniWindowLayoutSetReview=审阅视角
wnd(Log|Project|Std).mniWindowOutput=输出视图
wnd(Log|Project|Std).mniWindowWorkingTree=工作区窗口
wnd(Log|Project|Std).mniWorktreeAdd=创建工作区
wnd(Log|Project|Std).mniWorktreePrune=修剪过时的工作区
wnd(Log|Project|Std).mniWorktreeRemove=Remove Worktree
wnd(Log|Project|Std).mnu"Bisect"=二分
wnd(Log|Project|Std).mnu"Branch"=分支
wnd(Log|Project|Std).mnu"Branches"=分支
wnd(Log|Project|Std).mnu"Changes"=更改
wnd(Log|Project|Std).mnu"Commits"=提交
wnd(Log|Project|Std).mnu"Debug"=调试
wnd(Log|Project|Std).mnu"Edit Git Config"=编辑 Git 配置文件
wnd(Log|Project|Std).mnu"Edit"=编辑
wnd(Log|Project|Std).mnu"Git-Flow"=Git 工作流
wnd(Log|Project|Std).mnu"Help"=帮助
wnd(Log|Project|Std).mnu"LFS"=LFS
wnd(Log|Project|Std).mnu"Local"=本地
wnd(Log|Project|Std).mnu"Query"=查询
wnd(Log|Project|Std).mnu"Rebase"=变基
wnd(Log|Project|Std).mnu"Remote"=远程
wnd(Log|Project|Std).mnu"Repositories"=仓库
wnd(Log|Project|Std).mnu"Repository"=仓库
wnd(Log|Project|Std).mnu"Resolve"=解决
wnd(Log|Project|Std).mnu"Review"=审阅
wnd(Log|Project|Std).mnu"Submodule"=子模块
wnd(Log|Project|Std).mnu"Subtree"=子树
wnd(Log|Project|Std).mnu"Tools"=工具
wnd(Log|Project|Std).mnu"View"=视图
wnd(Log|Project|Std).tab"Branches"=分支
wnd(Log|Project|Std).tab"Changes of $1 - $2 \($3\)"=\
 $1 的变化 - $2 \($3\)
wnd(Log|Project|Std).tab"Changes of $1 - $2"=$1 的变化 - $2
wnd(Log|Project|Std).tab"Changes of $1 \($2\) - $3"=\
 $1 的变化 \($2\) - $3
wnd(Log|Project|Std).tab"Changes of $1 \($2\)"=$1 的变化 \($2\)
wnd(Log|Project|Std).tab"Changes"=的变化
wnd(Log|Project|Std).tab"Comments \($1\)"=备注 \($1\)
wnd(Log|Project|Std).tab"Comments"=注释
wnd(Log|Project|Std).tab"Commit Message"=提交信息
wnd(Log|Project|Std).tab"Commit"=提交
wnd(Log|Project|Std).tab"Debug Log"=调试记录
wnd(Log|Project|Std).tab"Files \(Working Tree\)"=文件 \(工作副本\)
wnd(Log|Project|Std).tab"Files"=文件
wnd(Log|Project|Std).tab"Graph \(Initializing Log-Cache...\)"=图形 \(初始化 日志缓存...\)
wnd(Log|Project|Std).tab"Graph \(Initializing Subtree-Cache...\)"=图形 \(初始化 Subtree 缓存...\)
wnd(Log|Project|Std).tab"Graph \(Initializing...\)"=图形 \(初始化...\)
wnd(Log|Project|Std).tab"Graph \(Loading...\)"=图形 \(载入中...\)
wnd(Log|Project|Std).tab"Graph \(Running log...\)"=图形 \(运行日志...\)
wnd(Log|Project|Std).tab"Graph \(Scanning WT...\)"=图形 \(扫描 WT...\)
wnd(Log|Project|Std).tab"Graph"=图形
wnd(Log|Project|Std).tab"Journal"=日志
wnd(Log|Project|Std).tab"Output"=输出
wnd(Log|Project|Std).tab"Repositories"=仓库
wnd(Log|Project|Std).tbr"  History  "=历史
wnd(Log|Project|Std).tbr"Add Tag"=创建标签
wnd(Log|Project|Std).tbr"Add or Create"=添加或创建
wnd(Log|Project|Std).tbr"Add"=创建
wnd(Log|Project|Std).tbr"Apply Stash"=应用贮藏
wnd(Log|Project|Std).tbr"Blame"=追溯
wnd(Log|Project|Std).tbr"Branch"=分支
wnd(Log|Project|Std).tbr"Changes"=的变化
wnd(Log|Project|Std).tbr"Check Out"=检出
wnd(Log|Project|Std).tbr"Cherry-Pick"=摘取
wnd(Log|Project|Std).tbr"Clone"=克隆
wnd(Log|Project|Std).tbr"Commit"=提交
wnd(Log|Project|Std).tbr"Compact"=紧凑
wnd(Log|Project|Std).tbr"Conflict Solver"=冲突解决器
wnd(Log|Project|Std).tbr"Delete"=删除
wnd(Log|Project|Std).tbr"Discard"=丢弃
wnd(Log|Project|Std).tbr"Drop Stash"=丢弃贮藏
wnd(Log|Project|Std).tbr"Fetch"=拉取
wnd(Log|Project|Std).tbr"Finish"=完成
wnd(Log|Project|Std).tbr"Git-Flow"=Git 工作流
wnd(Log|Project|Std).tbr"Ignore"=忽略
wnd(Log|Project|Std).tbr"Index Editor"=索引编辑器
wnd(Log|Project|Std).tbr"Integrate"=集成
wnd(Log|Project|Std).tbr"Investigate"=调查
wnd(Log|Project|Std).tbr"Local Files"=本地文件
wnd(Log|Project|Std).tbr"Log Selection"=日志选择
wnd(Log|Project|Std).tbr"Log"=日志
wnd(Log|Project|Std).tbr"Main"=主
wnd(Log|Project|Std).tbr"Merge"=合并
wnd(Log|Project|Std).tbr"Pull"=拉取
wnd(Log|Project|Std).tbr"Push To"=推送到
wnd(Log|Project|Std).tbr"Push"=推送
wnd(Log|Project|Std).tbr"Rebase"=变基
wnd(Log|Project|Std).tbr"Refresh"=刷新
wnd(Log|Project|Std).tbr"Remove"=移除
wnd(Log|Project|Std).tbr"Reset Adv."=高级重置。
wnd(Log|Project|Std).tbr"Reset"=重置
wnd(Log|Project|Std).tbr"Revert"=还原
wnd(Log|Project|Std).tbr"Review"=审阅
wnd(Log|Project|Std).tbr"Save Stash"=贮藏
wnd(Log|Project|Std).tbr"Search"=搜索
wnd(Log|Project|Std).tbr"Side by Side"=并列
wnd(Log|Project|Std).tbr"Stage"=暂存
wnd(Log|Project|Std).tbr"Start"=开始
wnd(Log|Project|Std).tbr"Sync"=同步
wnd(Log|Project|Std).tbr"Unified"=已统一
wnd(Log|Project|Std).tbr"Unstage"=取消暂存
wnd(Log|Project|Std).tbt"Clear logging."=清除记录。
wnd(Log|Project|Std).tbt"Commit Message History"=提交消息历史
wnd(Log|Project|Std).tbt"Hosting provider is not configured for the current repository. Go to the Preferences to add a configuration."=\
 当前仓库未配置主机提供商。前往 “偏好设置” 创建配置。
wnd(Log|Project|Std).tbt"If selected, files from subdirectories are shown."=\
 如果选定该属性，将显示子目录中的文件。
wnd(Log|Project|Std).tbt"If selected, the directories will be shown."=\
 选中则显示目录.
wnd(Log|Project|Std).tbt"Indicates how many files or directories are selected."=\
 展示有多少个文件或目录被选中.
wnd(Log|Project|Std).tbt"Interpret the search pattern as regular expression."=\
 把搜索通配理解为正则表达式.
wnd(Log|Project|Std).tbt"Options"=选项
wnd(Log|Project|Std).tbt"Reading incoming merge requests from '$1'."=\
 从 '$1' 读取收到的合并请求.
wnd(Log|Project|Std).tbt"Reading repository info from '$1'."=从 '$1' 读取仓库信息.
wnd(Log|Project|Std).tbt"Refresh information from GitLab."=刷新 GitLab 的信息。
wnd(Log|Project|Std).tbt"Show directories tree"=显示目录树
wnd(Log|Project|Std).tbtAnnotate=显示所选文件的追溯 \(注释\) 视图。
wnd(Log|Project|Std).tbtBranchAdd=为当前提交添加新分支。
wnd(Log|Project|Std).tbtBranchAddTag=为当前提交添加新标签。
wnd(Log|Project|Std).tbtCheckout=检出一个现有提交。
wnd(Log|Project|Std).tbtCherryPick=合并来自其他分支的修改.
wnd(Log|Project|Std).tbtClearOutput=清除输出窗格。
wnd(Log|Project|Std).tbtCommit=提交本地更改。
wnd(Log|Project|Std).tbtConflictSolver=打开冲突解决进程 \(或配置的外部合并工具\) 以解决冲突。
wnd(Log|Project|Std).tbtDelete=删除选定的本地文件或目录。
wnd(Log|Project|Std).tbtDiscard=丢弃本地更改。
wnd(Log|Project|Std).tbtFetch=从远程仓库获取提交并 \(可选\) 将它们与本地提交集成。
wnd(Log|Project|Std).tbtFlowContext=完成 Git 工作流功能。
wnd(Log|Project|Std).tbtFlowFeatureFinish=完成 Git 流功能。
wnd(Log|Project|Std).tbtFlowFeatureStart=启动新的 Git 流功能。
wnd(Log|Project|Std).tbtFlowHotfixFinish=完成 Git 流热修复进程。
wnd(Log|Project|Std).tbtFlowHotfixStart=启动新的 Git 流热修复进程。
wnd(Log|Project|Std).tbtFlowIntegrateDevelop=将新的基本提交集成到 Git 流功能中。
wnd(Log|Project|Std).tbtGoto-next-diff=下一处差异。
wnd(Log|Project|Std).tbtGoto-previous-diff=上一处差异。
wnd(Log|Project|Std).tbtIgnore=标记要忽略的未版本控制的本地文件/目录。
wnd(Log|Project|Std).tbtIndexEditor=编辑所选文件的索引状态，例如：决定哪些行应该被暂存.
wnd(Log|Project|Std).tbtInvestigate=使用 DeepGit 逐行调查历史记录。
wnd(Log|Project|Std).tbtLog=显示所选文件或目录的历史日志。
wnd(Log|Project|Std).tbtLogRepository=显示整个仓库的历史日志。
wnd(Log|Project|Std).tbtMerge=合并来自其他分支的更改。
wnd(Log|Project|Std).tbtPreviewRefresh=重新加载预览的文件内容。
wnd(Log|Project|Std).tbtPush=将本地提交推送到远程源仓库。
wnd(Log|Project|Std).tbtPushTo=将本地提交推送到远程仓库，允许选择目标仓库。
wnd(Log|Project|Std).tbtRebaseHeadTo=将 HEAD 提交应用于所选提交。
wnd(Log|Project|Std).tbtRefresh=刷新日志视图。
wnd(Log|Project|Std).tbtRemoteFetch=从所有远程仓库获取提交。
wnd(Log|Project|Std).tbtRemove=从仓库中删除选定的文件或目录。
wnd(Log|Project|Std).tbtRepositoryAdd=添加或创建新的仓库。
wnd(Log|Project|Std).tbtRepositoryClone=克隆新的仓库。
wnd(Log|Project|Std).tbtRepositorySearch=搜索现有仓库。
wnd(Log|Project|Std).tbtReset=将当前 HEAD 重置为另一个提交。
wnd(Log|Project|Std).tbtResetAdvanced=将当前 HEAD 重置为另一个提交，并保留 Index 或工作区中的差异。
wnd(Log|Project|Std).tbtRevealHomeCommit=在图表中显示 HEAD/工作区.
wnd(Log|Project|Std).tbtRevealPrevCommit=在调用显示工作区之前显示所选的提交。
wnd(Log|Project|Std).tbtRevealWorkingTree=在图中显示工作区节点。
wnd(Log|Project|Std).tbtRevert=通过 "反向" 合并来撤销现有提交的修改。
wnd(Log|Project|Std).tbtShowChanges=打开所选文件的文件比较。
wnd(Log|Project|Std).tbtStage=将工作区文件暂存在索引中以准备下一次提交。
wnd(Log|Project|Std).tbtStashApply=从贮藏中重新应用本地更改。
wnd(Log|Project|Std).tbtStashDrop=从仓库中删除一个或多个贮藏。
wnd(Log|Project|Std).tbtStashSave=贮藏当前的本地更改。
wnd(Log|Project|Std).tbtStdSetModeHistory=显示历史记录视图。
wnd(Log|Project|Std).tbtStdSetModeWt=显示仓库 \(工作区\)的本地文件。
wnd(Log|Project|Std).tbtSync=推送当前分支的本地提交并拉取远程程更改。
wnd(Log|Project|Std).tbtUnstage=从索引中删除暂存更改。
wnd(Log|Project|Std).tbtViewFromSubmodules=如果选中，将显示子模块中的文件。
wnd(Log|Project|Std).tbtViewIgnored=如果选中，将显示忽略的文件。
wnd(Log|Project|Std).tbtViewRenameSource=如果选中，将显示检测到的重命名的已删除/丢失的源文件。
wnd(Log|Project|Std).tbtViewSkipped=如果选中，将显示跳过的文件。
wnd(Log|Project|Std).tbtViewStaged=如果选中，将显示具有暂存 \(Index\) 更改且未更改工作区的文件。
wnd(Log|Project|Std).tbtViewUnchanged=如果选中，将显示未更改的文件。
wnd(Log|Project|Std).tbtViewUnchangedAssumed=如果选中，将显示具有 “假设不变” 标志的文件。
wnd(Log|Project|Std).tbtViewUnversioned=如果选中，未加入版本控制的文件将会显示。
wnd(Log|Project|Std).tbtWindowLayoutSetMain=切换到主透视图。
wnd(Log|Project|Std).tbtWindowLayoutSetReview=切换到审阅透视图。
